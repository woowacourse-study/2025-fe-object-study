## 객체지향 설계의 추구미: 낮은 결합도와 높은 응집도

이 책에서는 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이라고 말하고 있다.

한 문장으로 말하면 객체지향 설계의 추구미는 낮은 결합도와 높은 응집도이다.

객체지향 설계는 어떻게 이 추구미에 도달할 수 있을까? 어떻게 낮은 결합도, 높은 응집도를 합리적으로 유지할 수 있을까?

## 객체의 상태가 아니라 행동에 초점을 맞추기

객체지향 설계가 낮은 결합도 그리고 높은 응집도를 합리적인 수준에서 유지하려면 결국 객체의 상태가 아니라 행동에 초점을 맞춰야 한다고 한다.
그 이유는

- 상태는 구현에 속한다. 그래서 상태를 중심으로 삼고 설계하면 구현에 관한 내용이 인터페이스에 스며들게되고 캡슐화의 원칙이 무너진다(내부의 상태를 외부가 알게되기 때문에)

- 하지만 객체의 책임은 인터페이스에 속하기 때문에 책임을 중심으로 삼고 설계하면 캡슐화가 유지될 수 있다.

그래서 책임을 중심으로 삼고 캡슐화를 하면 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지할 수 있다고 한다.

## 캡슐화: 객체지향의 가장 중요한 원칙

책에서 객체지향의 가장 중요한 원칙이 갑자기 캡슐화라고 말한다. 캡슐화가 중요한 이유는 변경이 일어났을 때 그 파급효과를 적절하게 조절할 수 있다.

그래서 이 책에서 반복적으로 캡슐화를 통해 외부에서는 인터페이스에만 의존해야 한다고 말한다.

결국 구현은 변경될 가능성이 높은 부분이고, 인터페이스는 안정적인 부분이기 때문에 캡슐화를 통해 변경될 가능성이 높은 부분을 숨기는 것이 가장 중요한 원칙이라고 말하고 있다.

## 왜? 낮은 결합도, 높은 응집도, 캡슐화를 유지해야 하나?

4장을 읽으면서 가장 중요하다고 생각한 단어는 바로 **변경**이다. 이 장에서는 객체지향 설계에 대해 설명하고 있는데, 결국 설계가 필요한 이유는 요구사항은 언제나 **변경**되기 때문이고, 캡슐화가 중요한 이유 또한 변화에 안정적, 불안정적인 부분을 나눠서, **변경**의 영향을 통제할 수 있기 때문이다. 낮은 결합도, 높은 응집도를 유지해야 하는 이유도 **변경**에 대한 파장을 외부로 퍼저나가지 않게하기 위해서이다.

결국. 객체지향이 높은 응집도, 낮은 결합도, 캡슐화를 추구하는 이유는 단 한가지, **변경에 유연하게 대응하기 위해서**라는 생각이 들었다. 그래서 구현과 인터페이스를 분리해서 변경에 불안정한 부분은 숨기고 변경에 안정적인 부분만 외부에 인터페이스로 제공하는 것이 중요한 것이라는 것을 깨달았다.

그럼 프론트에서 변경에 대응하기 위해서는 어떤 것을 할 수 있을까?

## 프론트에서 변경을 생각해보기

내가 가장 최근에 겪었던 변경은 매 미션에서 1단계 -> 2단계로 넘어가는 과정이였던 것 같다. 아마 우테코에서도 이런 요구사항의 추가나 변경을 계속 주었던 이유가 변경에 더 유연게 대응할 수 있는 코드를 작성하게 연습시키려고 그러지 않았을까? 이제서야 그 의미를 깨달은 것 같다.

프론트에서 변경을 생각해보면 다음과 같은 것들이 있을 것 같다.

- UI 변경
- 데이터 구조 변경
- 비즈니스 로직 변경

프론트에서도 마찬가지로 변경에 불안정한, 즉 구현에 대한 부분은 숨기고 변경에 안정적인 부분만 외부에 드러내야 한다고 생각했다

먼저 UI 변경에 대해서 생각해보자

## UI 변경

UI 변경에는 컴포넌트의 색상,크기,테두리,폰트 변경이 있다.
또 어떤 컴포넌트에는 원래 없었던 이미지가 들어가도록 변경될 수도 있다.

이런 UI 변화에 우리는 어떻게 유연하게 대응할 수 있을까?

아래의 코드는 내가 이전에 모달 모듈 미션을 진행하면서 작성했던 코드이다.

```tsx
const ConfirmButton = ({
  children = '확인',
  onConfirm,
  onHide,
  disabled,
  ...rest
}: ConfirmButtonProps) => {
  return (
    <ModalButton
      css={ConfirmButtonStyle(disabled)}
      onClick={handleClick}
      disabled={disabled}
      aria-label='확인'
      {...rest}
    >
      {children}
    </ModalButton>
  );
};

const CancelButton = ({ children = '취소', ...rest }: ModalButtonProps) => (
  <ModalButton css={CancelButtonStyle} aria-label='취소' {...rest}>
    {children}
  </ModalButton>
);

export const ConfirmButtonStyle = (disabled?: boolean) => css`
  // 배경이 검정색, 글자가 하얀색

  border: 0;
  background-color: ${disabled ? '#ccc' : '#333333'};
  color: ${disabled ? '#666' : '#ffffff'};
  padding-left: 18px;
  padding-right: 18px;
  height: 36px;
  border-radius: 5px;
  cursor: ${disabled ? 'not-allowed' : 'pointer'};
`;

export const CancelButtonStyle = css`
  // 배경이 하얀색, 글자가 검정색
  background-color: #fff;
  color: #333;
  border: 1px solid #ccc;
  padding-left: 18px;
  padding-right: 18px;
  height: 36px;
  border-radius: 5px;
`;
```

이렇게 스타일을 각 역할에 따라서 변경할 수 없도록 지정해주어서 확인 버튼은 무조건 배경이 검정색, 글자가 하얀색이여야 했고, 취소 버튼도 배경이 하얀색, 글자가 검정색이여야만 했다.

그런데 2단계 미션에서 확인 버튼의 스타일이 배경이 하얀색, 글자를 검정색으로 만들었어야 했다.

이 코드를 다시 보면, 나는 "확인 버튼", "취소 버튼"이라는 역할의 이름에 스타일 즉 구현 세부 사항을 직접 결합해버린 구조의 코드를 작성했다.

이렇게 역할과 구현이 강하게 묶여 있어서 "검은색 취소 버튼"이나 "하얀색 확인 버튼" 같은 변경이 허용되지 않았다.

결과적으로 역할의 의미를 바꾸지 않았지만 스타일을 변경하는 것만으로 컴포넌트를 새로 만들어야 했고, 기존 코드를 재사용할 수 없었다.

### 행동과 구현을 분리하자

이런 문제를 해결하려면 행동(인터페이스)와 스타일(구현)을 분리해야 한다. 즉, 버튼의 역할은 컴포넌트 이름으로 표현하고, 어떻게 보여줄지는 props나 스타일로 주입해야 한다.

```tsx
const ModalButton = ({
  children,
  variant = 'primary',
  ...props
}: {
  variant?: 'primary' | 'secondary';
  children: React.ReactNode;
}) => (
  <button css={styleByVariant[variant]} {...props}>
    {children}
  </button>
);
```

이렇게 리택터링 하면 이제 `<ModalButton variant="secondary">확인</ModalButton>` 처럼
이 컴포넌트가 행해야 할 행동(확인, 취소)은 유지하면서 구현(스타일)은 자유롭게 바꿀 수 있게 된다.

결국 결국 UI 변경에 유연하게 대응한다는 것은 **컴포넌트가 구현 방식이 아니라 역할에 집중할 수 있도록 만드는 것**이다.
스타일은 내부에 감추고, 역할과 의미만 외부에 드러내는 것이 변경에 강한 컴포넌트를 만들 수 있다.

## 데이터 구조 변경

데이터 구조 변경도 생각해보자.

이번 프로젝트에서

```ts
export interface PlaceCardProps {
  id: number; // 여기요 여기
  name: string;
  address: string;
  stayDurationMinutes: number;
  openAt: string;
  closeAt: string;
  breakStartAt: string;
  breakEndAt: string;
  closedDays: string[];
  onDelete: (id: number) => void;
  onPlaceChange: () => Promise<void>;
  selected: boolean;
  onSelect: () => Promise<void>;
}
```

id 가 string에서 number로 바뀌는 일이 발생했다.

외부에서 알아야 하는 인터페이스가 변경된 것이다. 때문에 이 인터페이스를 가져다 쓰는 컴포넌트는 모두 `id={props.id.toString()}` 해당 코드처럼 일일이 `.toString()`을 붙여줘야 했다.

나는 API에서 받은 데이터 구조(id: number)를 그대로 컴포넌트의 인터페이스로 노출하고 있었기 때문에, API의 작은 변화가 UI 코드 전반에 파급효과를 일으켰다.

UI가 데이터 구조에 너무 깊게 결합되어 있었기 때문이다.

### 어떻게 설계했으면 변경에 유연했을까?

내 컴포넌트는 id는 string일 것이라고 가정한다. 컴포넌트가 너무 구체적인 데이터 형식을 강요하고 있었던 것이 문제였다.

이 문제를 해결하기 위해서 중간에 가공해주는 계층을 하나 만들면 어떻까 생각해보았다.

API 데이터를 그대로 넘기지 않고, 컴포넌트가 사용하기 좋은 형태로 바꿔주는 가공함수를 하나 만들어보겠다.

```ts
export function toPlaceCardProps(place: ApiPlace): PlaceCardProps {
  return {
    id: place.id.toString(),
    name: place.name,
    ...
  };
}
```

컴포넌트에서는 이렇게 사용

```tsx
<PlaceCard {toPlaceCardProps(place)} />
```

이런 방식으로 컴포넌트는 무조건 string을 받는다고 가정해놓고 중간 가공 함수를 추가하면, 나중에 API 형태가 어떻게 변경되든 가공하는 함수 하나만 수정해주면 모든 컴포넌트를 변경할 필요가 없어진다.

이렇게 구현, 그리고 인터페이스를 분리해주면 데이터 구조 변경에 대해서도 훨씬 유연하게 대응할 수 있을 것 같다.

## 비즈니스 로직 변경

이번 프로젝트에서 다음과 같은 폼 관련 로직을 훅으로 분리했다.

```tsx
export const useAddPlaceForm = () => {
  const [form, dispatch] = useReducer(formReducer, initialFormState);

  const initializeForm = (data: FormState) =>
    dispatch({ type: 'INITIALIZE', payload: data });
  const handleInputChange = (field, value) =>
    dispatch({ type: 'UPDATE', field, value });
  const handleToggleDay = (index) => dispatch({ type: 'TOGGLE_DAY', index });
  const resetForm = () => dispatch({ type: 'RESET' });

  return {
    form,
    initializeForm,
    handleInputChange,
    handleToggleDay,
    resetForm,
  };
};
```
이 훅은 값 업데이트, 요일 토글, 폼 초기화, 리셋등 폼 관련 책임을 가지는 하나의 모듈로 볼 수 있다.

이 훅은 높은 응집도, 낮은 결합도를 유지시킨다.

### 높은 응집도
폼의 모든 비즈니스 로직이 한 곳에 모여 있어, 어떤 변화가 생겨도 로직에 집중해서 관리할 수 있다.

예를들어서 요일 토글 로직을 "주말만 선택 가능하게"  바꾼다거나, 필드가 추가되는 요구사항이 생겨도 useAddPlaceForm만 수정하면 된다.

### 낮은 결합도
이 훅은 UI와 완전히 분리되어 있고, UI는 단순히 form, handleInputChange 같은 값과 함수만 받아서 사용한다.

그래서 폼 UI가 바뀌어도 로직은 그대로 재사용할 수 있고, 반대로 로직이 바뀌어도 UI를 수정할 필요가 없다.

### 커스텀 훅 === 캡슐화
객체지향에서 캡슐화는 변경 가능성이 높은 구현을 숨기고, 안정적인 인터페이스만 외부에 노출하는 것이다.

리액트에서 커스텀 훅이 그 역할을 할 수 있는 것 같다.

외부에서는 useAddPlaceForm이 리턴하는 값과 함수만 알고 있으면 되고, 내부 로직이 어떻게 바뀌든 외부는 알 필요가 없다.

useAddPlaceForm은 구현을 캡슐화하고, 인터페이스만 노출하는 구조다.
그래서 비즈니스 로직 변경에 강한 구조를 만들 수 있었다.

## 결론

객체지향에서 높은 응집도와, 낮은 결합도 캡슐화를 중요하게 여기는 이유는 변경에 유연하게 대응하기 위해서이다.

프론트엔드 개발에서도 다양한 변경이 자주 일어나는 만큼, 이러한 객체지향적 원칙을 적용하면 더 유연한 코드를 만들 수 있을 것 같다.

이번 경험을 통해서 변화에 강한 구조를 고민하는 설계의 관점을 배울 수 있었다. 특히 커스텀 훅을 단순한 추상화 도구가 아니라, 구현을 숨기고 인터페이스만 외부에 드러내는 캡슐화의 수단으로 바라보면 앞으로 더 유연하고 재사용 가능한 컴포넌트를 만들 수 있을 것 같다.4


## 생각을 나눠보고 싶은 것
이 책에서 **변경에 대한 파장을 줄인다**는 문장을 보고, 프론트엔드에서 컴포넌트의 변경이 불필요한 리렌더링으로 이어지는 경우가 떠올랐다. 객체지향에서 말하는 변경은 보통 코드의 의미적 변경을 뜻하지만, 프론트에서는 코드 구조나 상태 설계 방식이 렌더링 성능에도 영향을 준다는 점에서 조금 다른 방향의 고민도 해볼 수 있지 않을까 생각했다.

- 객체지향에서 에서 말하는 "변경의 파장"과 React에서 말하는 "불필요한 리렌더링"을 연결 지을 수 있을까?
  - 상태가 상위 컴포넌트에 몰려 있어서 하위까지 전부 리렌더링되는 상황도 일종의 파장으로 볼 수 있을까...?

- 리렌더링을 줄이기 위한 React의 최적화 기법들도 객체지향에서 말하는 설계 원칙으로 설명할 수 있을까?
  - 관련된 컴포넌트만 리렌더링되고 관련 없는 컴포넌트는 영향을 받지 않는 구조를 객체지향에서 말하는 "낮은 결합도", "높은 응집도"를 가진 설계라고 볼 수 있을까?


