## 여러분들의 커스텀 훅은 안전하신가요?

커스텀 훅에서의 캡슐화, 그냥 로직만 분리하던 나를 되돌아보며...

### 어떻게 이 주제를 선택하게 되었는가

오브젝트 4장을 읽다가 가장 인상 깊었던 문장이 있었습니다.

“객체가 사용될 문맥을 추측할 수밖에 없는 경우, <br />
개발자는 어떤 상황에서도 해당 객체가 사용될 수 있게
최대한 많은 접근자 메서드를 추가하게 된다.”

이 문장을 보는 순간, 문득 떠오른 제 습관이 있었어요.

바로 리액트에서 커스텀 훅을 만들 때, 상태를 그대로 return해버리는 습관이었습니다. <br />
“컴포넌트는 UI만 담당해야 하니까”,<br />
“로직은 훅에 다 몰아넣으면 되는 거 아냐?” <br />
라고 생각하며 짜온 코드들이 떠오르더라고요.

과연 그게 캡슐화에 부합하는 방식이었을까?<br />
그 질문에 대한 탐색을 통해 이 글을 쓰게 되었습니다.

### 캡슐화를 지키지 않은 나의 예시

아래는 실제로 제가 사용했던 장바구니 커스텀 훅 코드입니다.

기존의 useCartData 훅 (문제있는 버전)

```ts
//이해를 위해 최대한 간단하게 수정하였습니다.
const useCartData = () => {
  const [cartData, setCartData] = useState<CartItemType[]>([]);

  const fetchCartData = async () => {
    const res = await getCart();
    setCartData(res.data);
  };

  const increaseCartItemQuantity = async (cartId: number) => {
    const item = cartData.find((item) => item.id === cartId);
    if (!item) return;
    await modifyCartItem(item.id, item.quantity + 1);
    await fetchCartData();
  };

  const decreaseCartItemQuantity = async (cartId: number) => {
    const item = cartData.find((item) => item.id === cartId);
    if (!item) return;
    if (item.quantity === 1) {
      await deleteCartItem(item.id);
    } else {
      await modifyCartItem(item.id, item.quantity - 1);
    }
    await fetchCartData();
  };

  return {
    cartData,
    increaseCartItemQuantity,
    decreaseCartItemQuantity,
    fetchCartData,
  };
};
```

그리고 컴포넌트에서는 아래처럼 사용합니다.

```tsx
const CartPage = () => {
  const { cartData, increaseCartItemQuantity, decreaseCartItemQuantity } =
    useCartData();

  return (
    <ul>
      {cartData.map((item) => (
        <li key={item.id}>
          {item.name} - {item.quantity}
          <button onClick={() => decreaseCartItemQuantity(item.id)}>-</button>
          <button onClick={() => increaseCartItemQuantity(item.id)}>+</button>
        </li>
      ))}
    </ul>
  );
};
```

### 이 코드의 문제가 뭘까요?

처음엔 문제가 없어 보입니다. <br />
커스텀 훅으로 로직을 분리했고, 컴포넌트는 UI에 집중하고 있으니까요.<br />
하지만 오브젝트 책의 관점으로 보면 이 구조는 캡슐화를 명확히 위반하고 있습니다.

#### 상태 구조가 외부에 노출되어 있다

    - cartData는 내부 상태인데, 그대로 컴포넌트에 전달됩니다.
    - 외부는 cartData의 구조를 알고 있어야 하고, 구조가 바뀌면 컴포넌트도 바뀌어야 합니다.

<details>
<summary>어떤 구조를 알고 있어야 하나요?</summary>
  - cartData는 배열이라는 것. <br />
  - 각 요소는 name, quantity, id 같은 필드를 갖는다는 것 <br />
  - decreaseCartItemQuantity는 item.id를 받아야 한다는 점도 이해하고 있어야 한다는 것 <br />
    => 이것은 구현의 세부 사항을 외부에 드러내는 것, 즉 캡슐화 실패입니다.
</details>

<br />

#### 만약 서버에서 반환 형식이 바뀐다면?

```ts
// 기존
{
  id: 1,
  name: '초코우유',
  quantity: 2
}

// 변경
{
  productId: 1,
  productName: '초코우유',
  amount: 2
}
```

cartData를 return한 훅 내부도 수정해야 하고 <br />
그것을 사용하는 컴포넌트 모두 수정해야 해요.

### 리팩토링: 한 번 더 감싸서 객체로 만들어보자

이제 커스텀 훅이 진정한 캡슐화를 지키도록 리팩토링해봅시다.<br />
방법은 간단합니다. 한 번 더 감싸서 내보내는거에요!

즉, cartItems 배열 안에는 데이터와 행동이 함께 존재합니다.

- 개선된 useCartData 훅

```ts
const useCartData = () => {
  const [cartData, setCartData] = useState<CartItemType[]>([]);
  const { openToast } = useToast();

  const fetchCartData = async () => {
    const { data } = await tryApiCall(() => getCart());
    if (data) setCartData(data);
  };

  const updateQuantity = async (id: number, newQuantity: number) => {
    await tryApiCall(() => modifyCartItem(id, newQuantity));
    await fetchCartData();
  };

  const removeItem = async (id: number) => {
    await tryApiCall(() => deleteCartItem(id));
    await fetchCartData();
  };

  const cartItems = cartData.map((item) => ({
    //한 번 더 감쌈
    id: item.id,
    name: item.name,
    quantity: item.quantity,
    increase: () => updateQuantity(item.id, item.quantity + 1),
    decrease: () =>
      item.quantity === 1
        ? () => removeItem(item.id)
        : () => updateQuantity(item.id, item.quantity - 1),
    remove: () => removeItem(item.id),
  }));

  return {
    cartItems,
  };
};
```

사용하는 컴포넌트는 아래처럼 매우 단순해집니다.

```tsx
const CartPage = () => {
  const { cartItems } = useCartData();

  return (
    <>
      <ul>
        {cartItems.map((item) => (
          <li key={item.id}>
            {item.name} - {item.quantity}
            <button onClick={item.decrease}>-</button>
            <button onClick={item.increase}>+</button>
            <button onClick={item.remove}>삭제</button>
          </li>
        ))}
      </ul>
    </>
  );
};
```

⸻

- 이 방식이 좋은 이유는?
  - 컴포넌트는 상태 구조에 대해 전혀 모릅니다.
  - 단지 increase, decrease, remove라는 행동을 사용할 뿐입니다.
  - cartItems는 단순한 데이터가 아니라, 한 번 더 감싼 객체입니다.
  - 캡슐화가 유지되고, 협력은 메시지 기반으로 명확해졌습니다.

⸻

#### 여러분들의 커스텀 훅은 안전하신가요?

⸻

<details>
<summary>읽으면서 들었던 생각들</summary>

책임이 가장 중요하다.

훌륭한 설계는 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 말하는 것

상태를 분할의 중심축? -> 객체의 상태에 초점 <br />
책임을 분할의 중심축? 무슨말이지 -> 객체의 행동에 초점

책임에 초점을 맞춰야 한다.<br />
응집도는 높고 결합도는 낮아야되네.

```java
public class Movie {

  private Money fee;

  public Money getFee() {

  return fee;

}

  public void setFee(Money fee) {

  this.fee = fee;

}

}
```

위 코드가 캡슐화가 안되어있다고..?<br />
Money 타입의 fee가 있다는 것을 노출시켜서..?

- 지난주 나의 글에 대한 책의 답변이네

설계할 때 협력에 관해 고민하지 않으면 캡슐화를 위반하게 될 수 있다.
객체가 사용될 문맥을 추측할 수밖에 없는 경우 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 되는 것
-> 예시가 있을까?

- 객체는 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다.

<h1>그렇다면 커스텀 훅에서 상태를 return으로 내보내는 것은 안티패턴인가?</h1><br />
=> 리액트의 안티패턴에는 뭐가 있지?

</details>
