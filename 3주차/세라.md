책을 읽으며 그동안 작성한 코드 중 캡슐화를 위반한 부분, 응집도가 낮은 부분, 결합도가 높은 부분이 어디였는지 되돌아보고, 이를 어떻게 개선할 수 있을지 고민해보았다.

생각해보니 이러한 설계 관점에서 문제를 가장 명확하게 드러내는 코드 형태는 class 기반 코드였다. 그중에서도 구조가 비교적 명확한 Lotto 프로젝트를 중심으로 분석을 진행했다.

## 캡슐화 위반 문제

### [문제1] 내부 데이터 구조가 public static으로 노출되어 외부에서 직접 접근이 가능

**problem**

```jsx
class LottoMachine {
  #issuedLottoNumbers = [];
  #matchedLottoStatus;

  static LOTTO_STATUS = Object.freeze([
    { RANK: 1, COUNT: 6, REWORD: 2_000_000_000, IS_BONUS: false },
    { RANK: 2, COUNT: 5, REWORD: 30_000_000, IS_BONUS: true },
    { RANK: 3, COUNT: 5, REWORD: 1_500_000, IS_BONUS: false },
    { RANK: 4, COUNT: 4, REWORD: 50_000, IS_BONUS: false },
    { RANK: 5, COUNT: 3, REWORD: 5000, IS_BONUS: false },
  ]);

  //..
}
```

책 속에서도 `할인 정책의 종류` 를 노출시켜 금액 할인 정책, 비율 할인 정책, 미적용의 세 가지가 존재한다는 사실을 만천하에 드러내고 있었는데 사실 내 코드도 로또 등수가 5개 존재한다는 것과 보너스 번호 여부, 데이터 구조 등등 외부로 노출시키고 있었다.

문제점을 정리하면 총 4가지가 된다.

1. 구현에 대한 직접 접근

   외부에서 내부 상태 구조에 직접 접근할 수 있어, 구조가 변경되면 외부 코드도 함께 수정해야 한다. 이는 곧 구현에 의존하고 있음을 의미하고 추상화 실패를 뜻한다.

2. 변경 전파의 위험

   `REWORD`를 `PRIZE`로 네이밍을 변경하게 되면 모든 외부 코드 수정이 필요하다. 한 곳의 변경이 여러 곳의 변경을 강제하기 때문에 결합도 또한 높다는 것을 보여준다.

3. 정보 은닉 실패

   `LOTTO_STATUS`
   는 구현 세부 사항인데, 이를 그대로 노출하고 있어 객체 설계 원칙인 정보 은닉이 되지 않고 있다. 이는 캡슐화를 위반한 것이다.

4. 메시지 기반 협력 미흡

   구조를 사용하는 쪽이 내부 구현을 알아야 사용이 가능한데, 이는 객체 간 협력이 메시지 기반이 아닌 구조 기반으로 이루어진다는 것을 의미한다.

**solution**

```jsx
class LottoMachine {
  #issuedLottoNumbers = [];
  #matchedLottoStatus;

  static #LOTTO_STATUS = Object.freeze([
    { RANK: 1, COUNT: 6, REWORD: 2_000_000_000, IS_BONUS: false },
    { RANK: 2, COUNT: 5, REWORD: 30_000_000, IS_BONUS: true },
    { RANK: 3, COUNT: 5, REWORD: 1_500_000, IS_BONUS: false },
    { RANK: 4, COUNT: 4, REWORD: 50_000, IS_BONUS: false },
    { RANK: 5, COUNT: 3, REWORD: 5000, IS_BONUS: false },
  ]);

  static getFirstPrize() {
    return this.#LOTTO_STATUS[0].prize;
  }

  static getPrizeByRank(rank) {
    return LottoMachine.#LOTTO_STATUS.find((item) => item.RANK === rank)?.PRIZE;
  }
}
```

이렇게 개선함으로써 좋아진 점은 다음과 같다.

1. 캡슐화와 정보 은닉

   `LOTTO_STATUS`는 원래 외부에서 직접 접근 가능한 공개(static) 데이터였기 때문에, 외부에서 내부 구조를 마음대로 읽거나 구조에 의존해 사용하는 문제가 있었다.

   이 데이터를 private static으로 숨기고, `getFirstPrize()`, `getPrizeByRank(rank)` 등의 메서드(메시지)를 통해서만 접근하도록 변경하면, 외부에서는 내부 구조를 몰라도 되고 필요한 정보만 전달받는 협력 방식이 된다.

   > 내부 구현은 숨기고, 필요한 결과만 전달하는 메시지 기반 협력 구조가 만들어진다.

2. 변경에 강한 구조 (유지보수성 향상)

   개선 전에는 외부에서 `LottoMachine.LOTTO_STATUS[0].REWORD`처럼 직접 구조에 접근하고 있어, 모든 호출부에서 필드명을 고쳐야 했다.

   개선 후에는 내부 필드명이 `REWORD`든 `PRIZE`든 외부는 상관없고, getFirstPrize()만 유지되면 코드 수정이 전혀 필요가 없다.

   > 단일 책임 원칙과 \*\*\*\*변경 파급 최소화가 보장된다.

3. 응집도 증가

   데이터 구조와 그것에 접근하는 로직(등수별 상금 조회)이 LottoMachine 안에 응집되어 있으므로, 해당 객체만 보면 이 데이터가 어떻게 정의되고, 어떤 방식으로 제공되는지 명확히 파악이 가능하다.

   > 관심사의 집중으로 인해 유지보수가 쉬워지고, 다른 객체로 로직이 흩어지지 않아 구조가 명료해진다.

4. 결합도 하락: 구조에 대한 의존 제거

   외부에서 `LOTTO_STATUS[0].REWORD`처럼 구조에 접근하던 방식은 내부 배열 구조와 프로퍼티명을 외부가 알고 있어야 동작한다.

   반면 `getFirstPrize()`처럼 메서드를 사용하는 방식은 구조를 몰라도 되는 추상화된 협력입니다.

   > 결합도가 낮아져 내부 구조 변경이 외부에 영향을 미치지 않는다.

### [문제2] Lotto 클래스의 검증 메서드 노출

**problem**

```jsx
class Lotto {
  #numbers = [];

  constructor(numbers) {
    const lottoNumbers = numbers.map((num) => new LottoNumber(num));
    this.#numbers = this.sortLottoNumber(lottoNumbers);
    this.validate(this.#numbers);
  }

  isDuplicate(numbers) {
    const values = numbers.map((num) => num.getValue());
    if (new Set(values).size !== values.length) {
      throwError(ERROR.DUPLICATE);
    }
  }

  checkLength(numbers) {
    if (numbers.length !== LottoNumber.LOTTO_NUMBER.LENGTH) {
      throwError(ERROR.LENGTH);
    }
  }

  validate(numbers) {
    this.isDuplicate(numbers);
    this.checkLength(numbers);
  }

  // ...
}
```

`validate`, `isDuplicate`, `checkLength`가 외부에서 접근 가능한 퍼블릭 메서드로 존재한다. 이는 외부에서 객체의 정상 상태 보장을 강제할 수 있다는 뜻이며, 객체가 자기 자신을 책임지지 못하는 구조이다.

**solution**

```jsx
class Lotto {
  #numbers = [];

  constructor(numbers) {
    const lottoNumbers = numbers.map((num) => new LottoNumber(num));
    this.#numbers = this.sortLottoNumber(lottoNumbers);
    this.#validate(this.#numbers);
  }

  #isDuplicate(numbers) {
    const values = numbers.map((num) => num.getValue());
    if (new Set(values).size !== values.length) {
      throwError(ERROR.DUPLICATE);
    }
  }

  #checkLength(numbers) {
    if (numbers.length !== LottoNumber.LOTTO_NUMBER.LENGTH) {
      throwError(ERROR.LENGTH);
    }
  }

  #validate(numbers) {
    this.#isDuplicate(numbers);
    this.#checkLength(numbers);
  }
```

1. 캡슐화 실현

   `#validate`, `#isDuplicate`, `#checkLength`를 private 메서드로 내부화하여 외부에서 호출할 수 없도록 private 메서드로 감쌌다. 객체 내부에서만 유효성 검사를 수행하게 하여, 객체의 일관성과 무결성을 보장한다.

2. 책임의 명확화

   객체 스스로가 자신의 유효한 상태를 책임지는 구조로 개선되어 객체 지향 설계 원칙을 준수하게 된다.

3. 외부 오용 방지

   외부에서 유효성 검사를 반복하거나 생략하는 상황이 사라지므로, 예측 가능한 방식으로 객체가 사용된다.

## 낮은 응집도

### [문제1] 외부 유틸리티 의존한 유효성 검증

**problem**

```jsx
import { isEmpty, isNumber, isRange } from "../utils/validation.js";

class LottoNumber {
  #number;

  static LOTTO_NUMBER = Object.freeze({
    MIN: 1,
    MAX: 45,
    LENGTH: 6,
  });

  validate(number) {
    isEmpty(number);
    isNumber(number);
    isRange(
      {
        min: this.constructor.LOTTO_NUMBER.MIN,
        max: this.constructor.LOTTO_NUMBER.MAX,
      },
      this.constructor.LOTTO_NUMBER.LENGTH
    );
  }

  //..
}
```

`LottoNumber`의 핵심 책임은 로또 번호가 유효한지 검사하고 상태를 관리하는 것인데, 이 검증 로직이 `utils/validation.js`에 위임되어 있어 로또 번호의 유효성 판단을 위해 다른 파일까지 열어봐야한다.

응집도가 낮은 구조에서는 다음과 같은 문제가 발생한다.

1. **변경의 영향 범위 확대**

   로또 번호 검증 규칙이 변경되면 `LottoNumber.js`뿐 아니라 `validation.js`도 함께 수정해야 하며, `validation.js`를 사용하는 다른 모듈에도 영향을 줄 수 있다.

2. **책임의 분산**

   검증이라는 핵심 책임이 외부에 흩어져 있어 `LottoNumber`클래스만으로는 자신의 상태를 완전히 설명하거나 관리할 수 없다.

3. **이해도 저하**

   특정 번호가 왜 유효한지 판단하려면 `validation.js` 내부까지 살펴야 하므로 클래스의 자체적인 이해가 어려워진다.

**solution**

```jsx
import { isEmpty, isNumber, isRange } from "../utils/validation.js";

class LottoNumber {
  #number;

  static LOTTO_NUMBER = Object.freeze({
    MIN: 1,
    MAX: 45,
  });

  #validateAndSet(number) {
    this.#validateNotEmpty(number);
    this.#validateIsNumber(number);
    this.#validateRange(number);
    this.#number = number;
  }

  #validateNotEmpty(number) {
    if (number === null || number === undefined || number === "") {
      throw new Error("로또 번호는 필수입니다.");
    }
  }

  #validateIsNumber(number) {
    if (!Number.isInteger(number)) {
      throw new Error("로또 번호는 정수여야 합니다.");
    }
  }

  #validateRange(number) {
    const { MIN, MAX } = LottoNumber.LOTTO_NUMBER;
    if (number < MIN || number > MAX) {
      throw new Error(`로또 번호는 ${MIN}부터 ${MAX} 사이여야 합니다.`);
    }
  }
  //..
}
```

1. **응집도 향상**

   검증 로직이 모두 클래스 내부에 통합되어, `LottoNumber` 객체만 보아도 어떤 기준으로 유효성 판단을 받는지 바로 이해할 수 있다. 객체가 자신의 역할을 온전히 책임지므로 응집도가 높아집니다.

   > 하나의 책임이 한 곳에 집중되어 있어, 유지보수와 확장이 쉬워진다.

2. **외부 의존 제거**

   외부 유틸 `utils/validation.js`에 대한 의존성이 제거되어, 다른 모듈이나 파일의 변경이 `LottoNumber`에 영향을 주지 않으며, 반대로 `LottoNumber`의 변경이 외부에 영향을 미치지도 않는다.

   > 변경의 파급 범위가 최소화된다.

3. **캡슐화 강화**

   검증 메서드를 private으로 숨김으로써 외부에서 임의로 호출할 수 없게 되었고, 생성자 내부에서 객체 생성 시점에만 유효성을 검증하도록 명확히 제어한다.

   > 객체의 내부 상태와 동작이 잘 보호되어, 불변성과 안정성이 강화된다.

4. **이해 용이성 증가**

   유효성 규칙과 책임이 클래스 내부에 명확히 드러나 있어, 객체의 생성 조건과 동작 방식을 빠르게 파악할 수 있다.

   > 문맥 전환 없이 코드 이해가 가능하다.

## 높은 결합도

### [문제1] 구현 클래스에 직접 의존

**problem**

```jsx
const LottoShop = {
  issueLottoNumbers: () => {
    const randomNumberStore = new Set();
    while (randomNumberStore.size < LottoNumber.LOTTO_NUMBER.LENGTH) {
      const number = getRandomNumber(
        LottoNumber.LOTTO_NUMBER.MIN,
        LottoNumber.LOTTO_NUMBER.MAX
      );
      LottoShop.checkAndAddLottoNumbers(randomNumberStore, number);
    }
    return new Lotto([...randomNumberStore]);
  },
};
```

이 코드는 여러 구체적인 구현에 강하게 결합되어 있어 하나의 변경에 여러가지 변경 사항이 생긴다. 예를 들면 다음과 같다.

1. `Lotto` 클래스에 직접 의존

   ex. Lotto가 SuperLotto로 변경된다면, LottoShop 내부 생성 코드도 수정해야 한다.

2. `LottoNumber.LOTTO_NUMBER` 상수에 직접 의존

   ex. `LOTTO_NUMBER` 가 `LOTTO_CONFIG`로 변경되면 `.LENGTH`, `.MIN`, `.MAX` 등도 함께 수정되어야 한다.

3. `getRandomNumber` 함수에 강하게 의존

   ex. `getRandomNumber` 함수 이름이 바뀌면 해당 호출부도 수정이 필요하다.

또 높은 결합도로 인한 문제점은 다음과 같다.

1. 의존성 역전 원칙(DIP) 위반

   고수준 모듈(LottoShop)이 저수준 모듈(Lotto, getRandomNumber)에 직접 의존하고 있어 추상화가 제대로 적용되지 않았다.

2. 변경에 취약

   내부 구현이 바뀌면 외부 모듈(LottoShop)도 함께 수정해야 하므로 유지보수가 어렵다.

3. 확장성 부족

   새로운 로또 클래스나 번호 생성 방식 추가 시 기존 구조를 수정해야 하며, 개방-폐쇄 원칙을 위반하게 된다.

**solution
로또 번호 생성 class**

```jsx
class RandomNumberStrategy {
  constructor(min, max, length) {
    this.min = min;
    this.max = max;
    this.length = length;
  }

  generateNumbers() {
    const numberSet = new Set();
    while (numberSet.size < this.length) {
      const num =
        Math.floor(Math.random() * (this.max - this.min + 1)) + this.min;
      numberSet.add(num);
    }
    return [...numberSet];
  }
}
```

**로또 생성 class**

```jsx
class LottoGenerator {
  constructor(strategy, LottoClass) {
    this.strategy = strategy;
    this.LottoClass = LottoClass;
  }

  generate() {
    const numbers = this.strategy.generateNumbers();
    return new this.LottoClass(numbers);
  }
}
```

LottoGenerator는 구체적인 구현이 아닌 인터페이스(메서드)에만 의존한다.

**LottoShop이 추상화된 생성기에만 의존하도록 변경**

```jsx
const LottoShop = {
  issueLottoNumbers(generator) {
    return generator.generate();
  },
};
```

LottoShop은 이제 LottoGenerator의 generate() 메서드만 알면 되고, 내부 구현에 전혀 의존하지 않는다.

**최종**

```jsx
const strategy = new RandomNumberStrategy(1, 45, 6);
const lottoGenerator = new LottoGenerator(strategy, Lotto);

const lotto = LottoShop.issueLottoNumbers(lottoGenerator);
```

1. 낮은 결합도

   `LottoShop`은 구체적인 구현(`Lotto`, `getRandomNumber`, 상수값 등)을 알 필요 없고, `generate()` 인터페이스만 사용하여 추상화에 의존하면 된다.

2. 높은 확장성

   새로운 로또 타입 추가 시에도 기존 코드에 변경을 하지 않아도 된다.

   ex. `const powerBallStrategy = new RandomNumberStrategy(1, 69, 5);`

동작하는 코드와 좋은 코드는 다르다는 것을 깨달았다. 캡슐화를 통해 내부 구현을 숨기고, 의존성 주입으로 결합도를 낮추니 코드가 변경에 유연해졌다. 설계 원칙들이 단순한 이론이 아니라 실제 개발에서 유지보수성을 크게 좌우하는 실용적 도구임을 느낄 수 있는 시간이었다.
