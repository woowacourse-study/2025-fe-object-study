이번 챕터에서 데이터 중심 설계의 문제점에 대해 알게 되었는데,
정말 내가 진행하고 있는 프로젝트의 코드가 데이터 중심 설계가 아닐까 하는 생각이 들었다. 물론 제대로 된 설계 없이 구현에 들어간 코드이기 때문에 이런 일이 발생한 것도 있지만 내가 데이터 중심 설계의 문제점에 대해 더 제대로 인지하고 있고 책임 중심 설계를 하는 것에 익숙해져 있었다면 이런 일이 일어나지 않지 않았을까 하는 생각도 들었다.

그렇기 때문에 Sidebar 컴포넌트의 문제점을 책임 중심 설계 관점에서 살펴보고 간단하게 수정을 어떻게 하면 좋을지 다시 구현해 보았다.

#### 문제의 Sidebar 컴포넌트

```tsx
const getDragProps = useCardDrag(routiePlaces, setRoutiePlaces);
const [addModalOpen, setAddModalOpen] = useState(false);
const [isValidateActive, setIsValidateActive] = useState(false);
const [time, setTime] = useState(initialTime);
const [isValidateRoutie, setIsValidateRoutie] = useState(false);

useEffect(() => {
  const validateRoutie = async () => {
    try {
      const response = await getRoutieValidation(time);
      console.log(response);
      setIsValidateRoutie(response.isValid);
    } catch (error) {
      console.error(error);
    }
  };

  if (isValidateActive) {
    validateRoutie();
  } else {
    return;
  }
}, [isValidateActive, time]);

useEffect(() => {
  if (!routiePlaces) return;

  const updated = routiePlaces.map((item, index) => ({
    ...item,
    sequence: index + 1,
  }));

  const isSequenceChanged = routiePlaces.some(
    (item, index) => item.sequence !== index + 1
  );
  if (isSequenceChanged) {
    const sortedPlaces = updated.sort((a, b) => a.sequence - b.sequence);

    setRoutiePlaces(sortedPlaces);
    editRoutieSequence(sortedPlaces);
  }
}, [routiePlaces]);

const openAddModal = () => {
  setAddModalOpen((prev) => !prev);
};

const closeAddModal = () => {
  setAddModalOpen((prev) => !prev);
};

const handleValidateToggle = () => {
  setIsValidateActive((prev) => !prev);
};

const handleTimeChange = (field: string, value: string) => {
  setTime((prev) => ({ ...prev, [field]: value }));
};

const handleDelete = (id: number) => {
  editRoutieSequence(routiePlaces.filter((item) => item.placeId !== id));
  setRoutiePlaces(routiePlaces.filter((item) => item.placeId !== id));
};

///...
```

#### 현재 컴포넌트의 문제라고 생각되는 부분들

1. `setter`를 다른 컴포넌트에 넘기는 일을 통해서 캡슐화를 위반하고 있다.
2. 하나의 컴포넌트가 너무 많은 상태를 조작하고 있다. (**컴포넌트의 역할이 명확하지 않고, 응집도가 떨어진다**)
3. 컴포넌트가 상태 + 로직 + UI를 모두 담당하고 있어 관심사 분리가 전혀 이루어지지 않고 있다.
4. 의사결정 주체가 컴포넌트에 몰려 있다.
5. 컴포넌트 간 협력이 **"데이터 공유"** 기반이다 (메시지 전달이 아님)
6. 이벤트 핸들러가 단순 setxxx or toggle() 호출에 불과하다.

## 코드 리팩토링

### 책임 단위로 훅 추출

우선 Sidebar 컴포넌트의 상태를 외부로 추출해보고자 한다. 아래 3가지 상태는 모두 동선 검증 기능에 관련된 상태이니 이를 하나의 훅으로 분리해보자.

#### 수정 전 동선 검증 로직

```tsx
const [isValidateActive, setIsValidateActive] = useState(false);
const [time, setTime] = useState(initialTime);
const [isValidateRoutie, setIsValidateRoutie] = useState(false);

useEffect(() => {
  const validateRoutie = async () => {
    try {
      const response = await getRoutieValidation(time);
      setIsValidateRoutie(response.isValid);
    } catch (error) {
      console.error(error);
    }
  };

  if (isValidateActive) {
    validateRoutie();
  } else {
    return;
  }
}, [isValidateActive, time]);
```

#### 수정 후

```tsx
const useRoutieValidation = (initialTime) => {
  const [time, setTime] = useState(initialTime);
  const [isValidateActive, setIsValidateActive] = useState(false);
  const [isValid, setIsValid] = useState(false);

  useEffect(() => {
    if (!isValidateActive) return;

    (async () => {
      try {
        const res = await getRoutieValidation(time);
        setIsValid(res.isValid);
      } catch (err) {
        console.error(err);
      }
    })();
  }, [isValidateActive, time]);

  const toggleValidate = () => {
    setIsValidateActive((prev) => !prev);
  };

  const updateTime = (field, value) => {
    setTime((prev) => ({ ...prev, [field]: value }));
  };

  return {
    isValidateActive,
    toggleValidate,
    isValid,
    time,
    updateTime,
};
```

### 장소 관련 로직 분리

```tsx
const useRoutiePlaceList = (initialPlaces, onChange) => {
  const [routiePlaces, setroutiePlaces] = useState(initialPlaces);

  const handleReorder = (newList) => {
    setroutiePlaces(newList);
    editRoutieSequence(newList);
    onChange?.(newList);
  };

  const handleDelete = (id) => {
    const updated = places.filter((p) => p.placeId !== id);
    handleReorder(updated);
  };

  return {
    routiePlaces,
    reorder: handleReorder,
    remove: handleDelete,
  };
};
```

## 변경된 사이드바

```tsx
const { isValidateActive, toggleValidate, isValid, time, updateTime } =
  useRoutieValidation();

const { routiePlaces, reorder, remove } = useRoutiePlaceList(
  initialPlaces,
  onPlaceChange
);
```

## 리팩토링을 통해서 얻을 수 있는 이점

### 의도를 드러내는 설계가 된다

```tsx
const [isValidateActive, setIsValidateActive] = useState(false);
```

-> 뭘 위한 상태인지 이름만 보고 파악이 어렵다.

```tsx
const { isValidateActive, toggleValidate } = useRoutieValidation();
```

-> 루티 동선 검증 유효성 로직을 담당하는 훅임을 바로 알 수 있다.

### 상태 + 로직 + 책임이 하나의 단위로 응집된다

- useRoutieValidation은 검증 기능의 상태, 로직, API 호출까지 모두 자기 내부에서 판단하고 실행한다
- 외부에선 toggleValidate()라는 메시지 하나만 전달한다

→ 즉, “어떻게”가 아니라 “무엇”을 하라고 요청만 하면 된다

### 컴포넌트가 협력이 느슨해지고, 메시지 기반이 된다

- Sidebar는 더 이상 상태를 직접 setXxx하지 않는다
- 단지 toggleValidate(), updateTime(), remove() 같은 명령을 요청한다

### 역할별 책임 분리로 유지보수가 쉬워진다

#### useRoutieValidation

유효성 검증 상태 + 실행 로직 관리

#### useRoutiePlaceList

장소 리스트 상태 + 재정렬/삭제 책임
