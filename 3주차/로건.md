# 데이터 중심 설계..?

도대체 데이터 중심 설계가 뭘까?

책의 예제(128p, 130p)와 비슷한 코드를 드디어 내 코드에서 찾을 수 있었다.

장바구니 미션에서 쿠폰의 타입에 따라 유효성 검증을 하는 코드가 책의 예제와 비슷했다.

## 기존 장바구니 코드

```ts
const validateExpirationDate = ({
  expirationDate,
  today,
}: {
  expirationDate: string
  today: Date
}): boolean => {
  const expiration = new Date(`${expirationDate}T23:59:59`)
  return expiration >= today
}

export const validateCoupons = ({
  cartItems,
  coupon,
  today = new Date(),
}: {
  cartItems: CartItem[]
  coupon: Coupon
  today?: Date
}) => {
  const { expirationDate } = coupon
  if (!validateExpirationDate({ expirationDate, today })) {
    return false
  }

  const totalPrice = calculateTotalPrice(cartItems)

  switch (coupon.discountType) {
    case CouponType.FIXED: {
      return validateFixedDiscountCoupon({
        totalPrice,
        coupon,
      })
    }
    case CouponType.FREE_SHIPPING: {
      return validateFreeShippingCoupon({
        totalPrice,
        coupon,
      })
    }
    case CouponType.PERCENTAGE: {
      return validatePercentageDiscountCoupon({
        coupon,
        time: {
          hour: today.getHours(),
          min: today.getMinutes(),
          sec: today.getSeconds(),
        },
      })
    }
    case CouponType.BUY_X_GET_Y: {
      return validateBuyXGetYCoupon({
        coupon,
        cartItems,
      })
    }
    default:
      return false
  }
}
```

이 당시에 이 코드를 만들 때는 쿠폰의 타입에 따라 유효성 검증이 다르고, 필요한 데이터도 다르므로 switch 케이스를 써서 정말 잘 구현했다고 생각했다.
그렇다. 이 코드를 만들 때 데이터 중심 설계를 했었다.

이 당시 내 코드를 짜기 위한 과정을 돌아봤다.

1. 유효성 검사를 하기 위해 뭐가 필요하지?
2. 쿠폰에 만료일 있으니까 이걸로 만료일 유효 검사 해야겠다.
3. 쿠폰 타입마다 유효성 검사해야겠네.
4. 고정 금액 할인 쿠폰은 총 금액이 있어야 유효성 검사 할 수 있겠네.
5. 무료 배송 할인 쿠폰은 총 금액이 있어야 유효성 검사 할 수 있겠네.
6. 퍼센티지 금액 할인 쿠폰은 날짜가 있어야 유효성 검사 할 수 있겠네.
7. ....

이런 식으로 유효성 검사에 필요한 데이터를 먼저 생각한 후에 코드를 구현했었다.

### 현재 코드의 문제점

그러다보니 고정 할인 금액 쿠폰에서는 쓰지 않는 today까지 알게 되는 것처럼,
'필요한 데이터만 알아야 한다'는 정보 은닉 원칙에 위배되었다.

또한 요구사항이 변경되었을 때 대응하기 매우 좋지 않은 코드라고 느껴졌다.
현재 validateCoupons 함수는 cartItems, coupon, today 인자로 받고 있는데
만약 고정 금액 할인 쿠폰의 유효성 검사에 필요한 데이터에 tomorrow가 추가된다면 props를 추가해야한다.
이처럼 구현에 의존하게 되는 코드라 결합도가 높다고 볼 수 있다.
따라서 변경이 발생했을 때 파급 효과가 크고 유지보수가 어렵다는 문제가 있었다.

- 높은 결합도: validateCoupons 함수가 모든 CouponType의 존재를 알고 있어야 하며, 각 타입별로 어떤 유효성 검사 함수를 호출해야 하는지 직접적으로 연결되어 있다. 새로운 쿠폰 타입이 추가되면 validateCoupons 함수도 항상 수정되어야 한다.

### 개선 방향

그렇다면 어떻게 해야 높은 응집도, 낮은 결합도를 갖게 될까?
책임 중심 설계를 해야 한다는데 그렇다면 협력 -> 행동 -> 상태를 생각해보자.

협력: 유효한 쿠폰을 얻는다.
행동: 각 쿠폰이 유효한지 검증한다.
상태: 쿠폰의 정보와 유효성 검증이 있어야 한다.

- 만료일을 확인한다.
- 쿠폰 타입에 따라 유효성을 검증한다.
  - 쿠폰 타입에 따라 필요한 정보는 다르다.

"쿠폰 객체에 필요한 데이터(타입, 만료일 등)가 다 있을 테니까
이 쿠폰 객체가 스스로 유효성 검증을 하면 되겠다." 라는 생각이 들었다.

기존 코드를 바꿔보면 다음과 같이 바뀌게 될 것 같다.

## 변경된 장바구니 코드

```ts
// 1. 유효성 검사에 필요한 외부 정보를 캡슐화하는 컨텍스트 (상태)
interface ValidationContext {
  totalPrice: number
  cartItems: CartItem[]
  currentDate: Date
}

// 2. 쿠폰 객체가 수행해야 할 책임(행동)을 정의하는 인터페이스
interface BaseCoupon {
  expirationDate: string // 모든 쿠폰에 공통적으로 있는 만료일
  isValid(context: ValidationContext): boolean // 각 쿠폰 타입에 따라 유효성 검증 메소드
}

// 3. 구체적인 쿠폰 유형들 (인터페이스를 직접 구현)

class FixedDiscountCoupon implements BaseCoupon {
  expirationDate: string // 인터페이스 구현을 위해 명시
  minimumAmount: number // 고유 상태

  constructor(expirationDate: string, minimumAmount: number) {
    this.expirationDate = expirationDate
    this.minimumAmount = minimumAmount
  }

  // 행동: 고정 할인 쿠폰의 유효성 검증
  isValid(context: ValidationContext): boolean {
    // 만료일 검증 로직이 여기에 중복되거나,
    // 아니면 validateExpirationDate 같은 유틸리티 함수를 사용해야 함.
    const expiration = new Date(`${this.expirationDate}T23:59:59`)
    if (!(expiration >= context.currentDate)) {
      return false
    }
    return context.totalPrice >= this.minimumAmount
  }
}

// ... 나머지 쿠폰들도 BaseCoupon 인터페이스를 직접 구현

// 4. 유효한 쿠폰을 "얻는" 협력을 수행하는 상위 함수 (변경 없음)
// 이 함수는 'BaseCoupon' 인터페이스에만 의존한다.
function createCouponObject(coupon: Coupon): BaseCoupon {
  switch (coupon.discountType) {
    case CouponType.FIXED: {
      return new FixedDiscountCoupon(
        coupon.expirationDate,
        coupon.minimumAmount,
      )
    }
    // ...다른 쿠폰 타입
    default:
      throw new Error("Unknown coupon type")
  }
}

// 사용처
const useAvailableCoupons = (coupons: Coupon[]) => {
  const context: ValidationContext = {
    totalPrice: 100, // 예시 값, 실제로는 계산된 총 가격
    cartItems: [], // 예시 값, 실제로는 선택된 장바구니 아이템
    currentDate: new Date(), // 현재 날짜
  }

  // 5. 쿠폰의 유효성을 검증하는 로직
  const availableCoupons = coupons
    .map((coupon) => createCouponObject(coupon))
    .filter((coupon) => validateCoupons(coupon, context))

  return availableCoupons
}

function validateCoupons(
  coupon: BaseCoupon,
  context: ValidationContext,
): boolean {
  return coupon.isValid(context)
}
```

이제 쿠폰은 자기 스스로 유효성 검증을 하고, 유효한지 여부만 반환하면 된다.

### 변경된 코드의 장점

이렇게 되었을 때의 장점은 다음과 같다.

- 낮은 결합도

  - validateCoupon 함수는 이제 특정 쿠폰 유형(CouponType.FIXED, CouponType.PERCENTAGE 등)이나 그들의 세부 로직(validateFixedDiscountCoupon, validatePercentageDiscountCoupon)에 전혀 의존하지 않는다. 오직 BaseCoupon 인터페이스라는 추상화된 역할에만 의존한다.

- 높은 응집도

  - 각 쿠폰 클래스(예: FixedDiscountCoupon, PercentageDiscountCoupon)는 자신의 유효성을 판단하는 책임에만 집중한다. 관련된 상태(속성)와 행동(메서드)이 하나의 클래스 내부에 응집된다.

  - validateCoupons 함수는 단순히 "주어진 쿠폰 객체에게 유효성을 물어본다"는 단일 책임만을 수행한다.

- 변경에 유연함 (Open-Closed Principle):

  - 새로운 쿠폰 유형이 추가될 경우: BaseCoupon 인터페이스를 구현하는 새로운 쿠폰 클래스를 만들고 isValid 메서드만 구현하면 된다. validateCoupons 함수는 전혀 수정할 필요가 없다.

  - 기존 쿠폰 유형의 유효성 검사 로직이 변경될 경우: 해당 쿠폰 클래스 내부의 isValid 메서드만 수정하면 된다. validateCoupon 함수나 다른 쿠폰 클래스들은 영향을 받지 않는다.
