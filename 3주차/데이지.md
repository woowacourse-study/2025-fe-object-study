4장 설계 품질과 트레이드 오프를 읽고 내가 요약한 것은 아래와 같다.

- 캡슐화는 객체지향에서 가장 중요한 원리. 캡슐화는 변경될 수 있는 모든것을 숨겨야한다.
- 낮은 결합도와 높은 응집도를 지향하자. 이렇게 하면 변경에 대응하기 쉬운 코드가 된다.
- 캡슐화를 지키면 낮은 결합도 높은 응집도가 따라온다.
- 책임 중심의 설계는 내부 구현을 안정적인 인터페이스 뒤로 캡슐화한다. 따라서 책임 중심의 설계는 낮은 결합도와 높은 응집도를 가져온다.

낮은 결합도와 높은 응집도를 가지는 설계가 중요하다고 하고있다. 결합도와 응집도에 대해서 생각으르 하다보니 이런 생각이 들었다.

"응집도를 높이기 위해서 관련된 모든 것들을 하나의 컴포넌트에 훅을 다 몰아넣어야 하는 것 아닌가? 비즈니스 로직이 담긴 훅을 반드시 다 분리해야 할까?"

## 도메인 로직을 포함한 훅

예약신청을 위한 폼을 예시로 들겠다.

여기서 입력폼과 검증 훅은 높은 결합도를 가질 수 밖에 없다. 분리를 하나 마나 높은 결합도를 가지는 것인데, 그러면 응집도를 높이기 위해 같은 컴포넌트파일에 존재하는게 맞는 거 아닌가? 라는 생각이 들었다.

입력 폼 코드

```tsx
function BookingForm({
  handleBookingButtonClick,
  mentoringId,
}: BookingFormProps) {
  const {
    menteeName,
    handleMenteeNameChange,
    errorMessage: menteeNameErrorMessage,
  } = useMenteeNameInput();

  const { phoneNumber, inputRef, handlePhoneNumberChange } =
    useFormattedPhoneNumber();
  const [counselContent, setCounselContent] = useState('');

  const phoneNumberErrorMessage = getPhoneNumberErrorMessage(phoneNumber);

  const handleCounselContentChange = (
    e: React.ChangeEvent<HTMLTextAreaElement>
  ) => {
    setCounselContent(e.target.value);
  };

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    handleBooking();
  };

  return (
    <StyledContainer onSubmit={handleSubmit}>
      <StyledInfoText>
        아래 정보를 입력해주시면 멘토에게 상담 신청이 전송됩니다.
      </StyledInfoText>
      <StyledFieldWrapper>
        <FormField
          label="상담자명 *"
          htmlFor="name"
          errorMessage={menteeNameErrorMessage}
        >
          <Input
            placeholder="홍길동"
            id="name"
            value={menteeName}
            onChange={handleMenteeNameChange}
            errored={menteeNameErrorMessage !== ''}
            data-testid="mentee-name-input"
            required
          />
        </FormField>
        <FormField
          label="전화번호 *"
          htmlFor="phone"
          errorMessage={phoneNumberErrorMessage}
        >
          <Input
            placeholder="010-1234-4986"
            id="phone"
            value={phoneNumber}
            onChange={handlePhoneNumberChange}
            errored={phoneNumberErrorMessage !== ''}
            ref={inputRef}
            maxLength={13}
            type="tel"
            data-testid="phone-number-input"
            required
          />
        </FormField>
        <FormField label="상담 내용(선택사항)" htmlFor="details">
          <StyledTextarea
            id="details"
            placeholder="구체적으로 궁금한 내용이나 현재 상황을 적어주시면 
더 정확한 조언을 받을 수 있습니다."
            onChange={handleCounselContentChange}
            errored={false}
            value={counselContent}
          />
        </FormField>
      </StyledFieldWrapper>
      <BookingSummarySection />
    </StyledContainer>
  );
}

export default BookingForm;
```

이 코드는 현재 도메인 로직이 분리된 코드다. 분리되지 않았을때와 비교하여 분리했을때의 장점은 아래와 같다.

### 파급효과 감소

```
const useMenteeNameInput = () => {
  const [menteeName, setMenteeName] = useState('');

  const handleMenteeNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setMenteeName(e.target.value);
  };

  const getMenteeNameErrorMessage = () => {
    if (menteeName === '') return '';

    if (menteeName.length < 1 || menteeName.length > 5) {
      return ERROR_MESSAGE.INVALID_MENTEE_NAME_LENGTH;
    }

    const regex = /^[ㄱ-ㅎ가-힣]+$/; // 한글만 허용

    if (!regex.test(menteeName)) {
      return ERROR_MESSAGE.INVALID_MENTEE_NAME_CHARACTERS;
    }

    return '';
  };
```

현재는 상담자 이름을 한글만 허용하게 했다. 영어도 가능하게 하려면 해당 훅만 바꾸면 된다. 컴포넌트 파일 전체에 영향이 가는게 아니라 도메인 로직을 담당하는 훅만 변경에 대한 영향을 받기에 파급 효과가 줄어든다.

분리는 파급효과를 줄이는 수단이 된다.

### 응집도 증가

오브젝트 책에는 다음과 내용이 있다.

> "하나의 변경이 있을 때, 해당 변경이 하나의 모듈 안에서만 이뤄진다면 응집도가 높다"

반대로 말하면 아래와 같다.

> "하나의 변경이 여러 모듈을 동시에 바꾸게 만든다면 응집도가 낮다."

그런데 응집도가 낮은 경우는 꼭 여러 모듈에 변경이 분산되는 경우만을 뜻하지 않는다.
모듈 내부에서 여러 책임이 분산되어 있어도 응집도가 낮다고 할 수 있다.

예를 들어, `BookingForm.tsx`가 다음과 같은 여러 책임을 동시에 가진다면:

1. UI 렌더링
2. 전화번호 입력 포맷팅
3. 전화번호 검증
4. 서버 요청 로직

이 모듈이 바뀌는 이유가 여러 개 존재하므로,
이는 하나의 책임으로 뭉쳐있지 않고 응집도가 낮은 상태다.

따라서, 서로 다른 변경 이유(책임)가 섞여 있다면 모듈 내부 응집도가 낮아지고
UI와 검증 로직을 같은 컴포넌트에 포함시키는 것도 응집도를 떨어뜨릴 수 있다.

## 결론

단순하게 연관된 기능들끼리 모아두는 것이 응집도를 높이는 것이 아니다.
응집도를 높이려다 보면 오히려 파급효과가 커질 수 있고, 여러 관심사가 섞이면서 하나의 변경이 아닌 여러 변경 이유가 한 모듈에 뒤섞이게 된다. 이는 응집도를 오히려 낮추는 구조이다.
분리는 관심사를 나누기 위함이 아니라, 변경을 범위를 줄이고 파급 효과를 줄이기 위한 것이라고 생각한다.
