## 좋은 설계의 특징은 무엇일까?

우리가 궁극적으로 목표하는, 좋은 설계란 무엇일까? 오브젝트 4장에선 이 질문에 대해 **변경에 쉽게 대응할 수 있는 설계**라고 답하고 있다.

우리가 아무리 처음에 코드를 잘 만든다 해도 요구사항이 변하는 등 예상치 못한 변화에 맞춰 코드는 변화할 수 밖에 없다. 이 경우 변경 가능성이 높은 구현부를 바꾼다 하더라도 인터페이스에는 변화가 없어 기존에 작동하던 기능을 문제 없이 제공한다면 변경에 별다른 두려움이 없을 것이다. 이처럼 어느 특정 부분에 변경이 있더라도 전체적으로 크게 수정할 부분이 없다면 그 코드는 좋은 코드로 바라볼 수 있다.

앞서서 구현부를 숨기고 인터페이스를 노출하는 캡슐화를 알아봤다. 이 외에도 변경에 쉽게 대응할 수 있는 설계인지 확인하는 지표에는 두 가지가 더 있다.

### 응집도

- 모듈에 포함된 내부 요소들이 연관되어 있는 정도 -> 높을수록 좋다.
  - 모듈 내 요소들이 서로 다른 목적을 추구하면 응집도가 낮아진다.
- 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도를 알 수 있다.
  - 변경이 필요할 때 그 범위를 뚜렷이 알 수 있다.

### 결합도

- 의존성(= 다른 모듈에 대해 얼마나 많은 지식을 알고 있는지)의 정도 -> 낮을수록 좋다.
- 한 모듈이 변경되지 위해서 다른 모듈의 변경을 요구하는 정도를 의미한다.
  - 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는 지를 의미한다.

## 일단 설계하고, 품질을 생각해보자.

개인적으로 좋은 코드를 짜는 것 만큼이나 내가 짠 코드의 품질이 어떤지 잘 아는 것이 중요하다고 생각한다. 그렇기에 이번 장에서 제시한 응집도와 결합도는 앞으로 내가 코드를 살펴볼 때 중요한 지표가 될 수 있다고 생각했다.

이번 레벨3에서 우리 팀이 만드는 서비스에는 사용자의 정보를 끊임없이 요구하는 기능이 있다. 이 때 한 번에 사용자한테 너무 많은 정보를 표시하면 쉽게 지치고 혼란을 겪을 수 있다. 그래서 여러 페이지에 걸쳐 정보를 조금씩 받는 방식을 채택하기로 했다.

토스 오픈소스에선 이러한 패턴을 "퍼널"이라고 지칭하고 있다. 이제부터 **퍼널을 설계하고, 설계 품질을 생각해보자.**

![퍼널이미지](https://github.com/user-attachments/assets/dd3d2037-927a-487a-82c3-16a600eacc09)

## 데이터 중심 설계로 구현한 퍼널

오브젝트 4장에선 캡슐화, 응집도, 결합도의 측면에서 데이터 중심 설계를 신랄하게 비판하고 있다. 진짜 데이터 중심 설계로 구현하면 응집도와 결합도 측면에서 좋지 않은 결과가 나올까? 억지로 퍼널을 [데이터 중심](https://github.com/MinSungJe/my_own_funnel_sketch/tree/main/src/data-driven)으로 설계해보자.

### 데이터를 각 페이지(객체)에서 받기

데이터 중심 설계에선 객체에 들어갈 데이터를 먼저 생각한다. 프론트엔드에서 대표적인 객체는 컴포넌트, 즉 페이지이다. 그러므로 먼저 각 페이지에서 받을 데이터를 controlled input 형태로 받을 수 있도록 설계한다.

![데이터한곳으로](https://github.com/user-attachments/assets/4a547dec-db2c-464b-ba77-e6e37a70eca9)

### 각 데이터를 한 곳으로 모으기

그 다음 페이지 별 데이터를 Check 페이지에서 받을 수 있도록 useContext를 이용해 페이지간 하나의 데이터를 공유하도록 구현한다.

![useContext로묶기](https://github.com/user-attachments/assets/584f9f62-4590-41ac-98ab-40fa69dbede0)

### 마지막 페이지에서 모은 데이터를 fetch하기

Check 페이지에서 모은 데이터를 불러올 수 있다면 이 데이터로 fetch 요청을 보낸다. 앞서서 Context에 데이터를 모아주었으므로 Context의 내용을 넣어 요청을 보내기만 하면 된다.

![fetch요청](https://github.com/user-attachments/assets/3b7caaef-70dc-4b3e-9ad4-0fc5e0ec3f03)

```tsx
const Check = () => {
  const navigate = useNavigate();
  const { dataFunnelData } = useDataFunnelContext();

  // Check 페이지에서 다음 버튼을 누르면 fetch 요청
  const handleCheckNextButton = async () => {
    try {
      await fetch('/api/submit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(dataFunnelData),
      });
    } catch (error) {
      console.error('POST 요청 실패:', error);
    } finally {
      navigate('/data/complete'); // 마지막 페이지로 이동
    }
  };

  return (
    <div>
      <p>입력한 내용을 확인해주세요.</p>
      <p>{JSON.stringify(dataFunnelData)}</p>
      <button onClick={handleCheckNextButton}>확인</button>
    </div>
  );
};

export default Check;
```

이렇게 데이터 중심 설계로 퍼널을 구현할 수 있었다.

## 변경과 관련지어 응집도, 결합도 확인하기

이제 남은 작업은 이 설계가 좋은 설계인지 확인하는 것이다. 앞서 언급했듯 좋은 설계란 변경이 쉬운 설계를 의미하며, 이는 응집도와 결합도 측면에서 검사해볼 수 있다.

### 응집도

페이지 중 하나인 Name 컴포넌트를 살펴보자.

```tsx
const Name = () => {
  const { dataFunnelData, setDataFunnelData } = useDataFunnelContext();
  const navigate = useNavigate();
  const [name, setName] = useState(dataFunnelData.name ?? '');

  // controlled input
  const handleChangeName = (e: ChangeEvent<HTMLInputElement>) => {
    setName(e.target.value);
  };

  // 다음 페이지로 넘어가는 navigate 로직 
  // + Context에 반영하는 로직
  const handleNameNextButton = () => {
    navigate('/data/date');
    setDataFunnelData((prev) => ({ ...prev, name }));
  };

  return (
    <div>
      <p>이름을 입력해주세요.</p>
      <input placeholder="이름 입력" value={name} onChange={handleChangeName} />
      <button onClick={handleNameNextButton}>다음</button>
    </div>
  );
};

export default Name;
```

코드를 보면 하나의 객체 안에 여러 책임을 하고 있다는 것을 알 수 있다.
- controlled input을 이용해 name이라는 자체 상태를 관리한다.
- 조건을 만족했을 시 다음 step으로 넘기는 navigate 로직이 있다.
- 조건을 만족했을 시 Context에 자체 상태를 반영하는 로직이 있다.

페이지를 전체적으로 넘긴다는 navigate 로직만을 생각한다면 Name 뿐만 아니라 Date, Check에도 분산되어 있음을 알 수 있다.

navigate 로직 뿐 아니라, Context에 반영하는 로직도 마찬가지로 분산되어 있다. 즉 **데이터 중심 설계로 만든 퍼널은 응집도가 낮은 구조**이다.

설계의 응집도가 낮기 때문에 navigate 로직에 변화가 생길 경우 어디를 건드려야 할 지 범위를 정하기 쉽지 않다. 만약 navigate가 아니라 다른 메서드를 통해 라우터를 이동시키기로 변경한다면? Name과 Date, Check 등 분산되어 있는 모든 로직을 살펴봐야 할 것이다.

### 결합도

만약 퍼널로 새로운 3번째 값 Password를 받는다고 가정해보자. 이 변경에 상당히 많은 모듈이 영향을 받게 된다.

![새로운추가](https://github.com/user-attachments/assets/7f829166-2b23-4fc7-97d7-6a901ad37e31)

- useFunnelDataContext가 전달하는 Data의 인터페이스가 변경되므로 Provider를 비롯한 관련 코드가 전부 변경된다.
- Date -> Check로 가는 navigate를 Date -> Password로 수정해주어야 한다.
  - 지금은 구현하지 않았지만 이전 화면으로 돌아가는 로직이 있다면 Check -> Date로 가는 navigate도 수정해주어야 한다.
- Check의 fetch 함수에 Password를 data로 담아야 한다.

이처럼 변경이 발생할 때 이에 맞춰 변화하는 모듈이 많으므로 우리는 변경하기 어려운 구조라고 볼 수 있다. **데이터 중심 설계로 만든 퍼널은 결합도가 높은 구조**이기 때문이다.

## 결론

데이터 중심 설계는 객체 내부 데이터를 우선적으로 고려해 설계를 하는 방식이다. 우리는 앞서 이 방식을 통해 퍼널 설계를 하게 되면 변경이 발생할 때 수정해야 할 범위가 명확하기 않고 여러 모듈이 동시에 영향을 받게 된다는 것을 알 수 있었다.

오브젝트 4장에서 말하는 좋은 설계란 변경이 일어났을 때 유연하게 대응할 수 있는 구조를 의미한다. 이를 위해선 설계를 할 때 책임을 중심으로 고려해야 한다. 즉, 우리는 단순히 데이터를 모으는 것이 아닌, 객체의 책임과 역할을 명확히 하는 설계를 지향해야 한다.


<details><summary><b>책 내용 정리(4장)</b></summary>

## 트레이드오프

- 좋은 설계의 특징은 무엇인가?
  - 캡슐화, 응집도, 결합도

### 캡슐화

- 추상화 방법 중 하나
- 변경 가능성이 높은 부분(구현)은 숨기고, 상대적으로 안정적인 부분(인터페이스)만 공개

### 응집도

- 모듈에 포함된 내부 요소들이 연관되어 있는 정도
- 모듈 내 요소들이 서로 다른 목적을 추구하면 응집도가 낮음
- 객체에 얼마나 관련 높은 책임들을 할당했는지?

### 결합도

- 의존성의 정도
  - 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지
- 객체가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지?

## 모든 트레이드오프는 설계와 관련있다.

- 좋은 설계란 각 요소가 응집도가 높고 느슨하게 결합되어 있어야 함
- 특히, 변경과 깊은 관계
  - 설계를 변경하기 쉬운 코드가 좋은 설계
- 캡슐화의 정도가 응집도와 결합도에 영향

### 응집도 with 변경

- 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도
  - 높을수록 변경 대상과 범위가 명확 → 코드의 변경이 쉬워짐

### 결합도 with 변경

- 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
  - 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는가?

## 데이터 중심 설계의 문제

- 데이터 중심 설계: 객체가 포함해야 하는 데이터에 집중한 설계
- 데이터에 초점을 맞추는 설계는 변경에 취약
  - 데이터는 구현에 속함
  - 구현에 대한 세부사항이 객체의 인터페이스에 스며들게 됨
  - 상태 변경이 인터페이스의 변경을 초래
  - 인터페이스에 의존하는 모든 객체에 영향

### 캡슐화

- 내부의 데이터가 있다는 점을 공개 (추측에 의한 설계 전략)
- 캡슐화를 지켜야 함 → 객체가 자기 스스로를 책임져야 함

### 결합도

- 어디의 수정이 무조건 다른 모듈의 변화를 요구 → 높은 결합도

### 응집도

- 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존
  - SRP에선 책임 → 변경의 이유

## 결론

### 데이터 중심 설계

- 본질적으로 너무 이른 시기에 데이터에 대해 결정하도록 강요
- 협력이라는 문맥 없이 객체를 고립시킨 채 오퍼레이션을 결정

</details>

<details><summary><b>부록: 정리노트</b></summary>

![정리노트](https://github.com/user-attachments/assets/8a9e76d9-6643-4ac2-8541-9aba7bf498aa)

</details>
