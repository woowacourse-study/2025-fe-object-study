책에서 잘 설계된 객체지향은 작고 응집도 높은 객체들로 구성된다고 이야기 합니다. 또 두가지 조건을 제시하는데요. **첫번째, 책임의 초점이 명확하고 한가지 일만 한다. 두번째, 다른 객체의 도움을 요청을 해야한다.**

두번째 조건에서 의존성이 불가피하게 생기게 됩니다. 의존성은 코드의 확장성을 방해하는 요소가 되는데요. 이 의존성을 어떻게 잘 다뤄야 할지 이야기를 합니다. 해당 주차에서는 책에서 이야기 한 내용을 토대로 리액트에서 의존성을 어떻게 관리하면 좋을지에 대해 이야기 해보려 합니다.

## 변경과 의존성

의존성은 의존 대상이 변경될때, 그 영향을 함께 받을 수 있다는 특징이 있습니다.
예를 들어 PeriodCondition → Screening → Movie, Customer처럼 객체들이 서로 이어져 있으면, 겉으로는 PeriodCondition이 Screening만 의존하는 것처럼 보여도, 변경에 따라 Movie나 Customer까지 간접적으로 영향을 받을 수 있습니다. 그러나 항상 그런것은 아니고 캡슐화를 통해 세부 구현을 감추면 영향 범위를 줄일 수도 있다고 합니다.

**의존성이 높은 코드**

```tsx
export const NotificationButton = () => {
  const { permission } = useNotification();
  const handleNotificationClick = async () => {
    if (permission === "granted") {
      alert("이미 알림을 받고 있습니다.");
      return;
    }

    try {
      const token = await requestFCMPermission();
      if (!token || !isAuthenticated()) return;

      await registerFCMToken(token);
      alert("알림 설정이 완료되었습니다.");
    } catch (error) {
      console.error("알림 설정 실패:", error);
      alert("알림 설정에 실패했습니다.");
    }
  };

  return (
    <Button onClick={handleNotificationClick}>
      {permission === "granted" ? "알림 허용됨" : "알림 받기"}
    </Button>
  );
};
```

겉으로 보기에는 단순 네이밍을 통해 어떤 역할을 하는지 알렸고 `NotificationButton` 라는 이름에 걸맞은 책임을 한다고 느낄 수 있습니다.

하지만 내부에는 너무 많은 책임을 지고 있습니다. 권한 확인, 토큰 발급, 인증 여부 체크, 서버 등록 등 너무 많은 책임을 가지고 있습니다. 결론적으로 응집도가 낮고 불필요하고 의존도가 높아 책에서 이야기하는 객체지향과 멀어진 것 같다고 느꼈습니다.

**의존성을 낮춘 코드**

```tsx
const useNotificationRequest = () => {
  const { permission } = useNotification();

  const requestNotification = async () => {
    if (permission === "granted") {
      alert("이미 알림을 받고 있습니다.");
      return;
    }

    try {
      const token = await requestFCMPermission();
      if (!token || !isAuthenticated()) return;

      await registerFCMToken(token);
      alert("알림 설정이 완료되었습니다.");
    } catch (error) {
      console.error("알림 설정 실패:", error);
      alert("알림 설정에 실패했습니다.");
    }
  };

  return { permission, requestNotification };
};

type NotificationButtonProps = {
  permission: "granted" | "default" | "denied";
  onClick: () => void;
};

export const NotificationButton = ({
  permission,
  onRequestNotification,
}: NotificationButtonProps) => {
  return (
    <Button onClick={onRequestNotification}>
      {permission === "granted" ? "알림 허용됨" : "알림 받기"}
    </Button>
  );
};
```

구조를 바꿔보았는데요. `NotificationButton`은 오직 UI 책임만 수행하고,알림 요청 로직은 훅으로 캡슐화했습니다. 버튼은 클릭시 `onRequestNotification` 을 호출한다는 사실만 알게 함으로써 훨씬 유연하고 꼭 알아야하는 메시지만 알 수 있게 되었습니다.

또 이렇게 변경하면, `onRequestNotification` 내부 구현이 바뀌어도 버튼은 영향을 받지 않으니 책에서 이야기하는 구현 시점 의존성도 낮아진다고 느꼈습니다.

## 의존성 해결하기

책에서는 컴파일타임 의존성을 **런타임 의존성으로 전환**하는 과정을 의존성 해결이라고 설명합니다. 리액트에서 적용하자면 다음과 같이 생각해 볼 수 있습니다.

1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결 → props로 주입 받기

   자바에서 생성자 인자로 의존성을 넘기는 것 처럼, 리액트에서는 비슷한 역할을 props가 한다고 생각했습니다.

   ```tsx
   type NotificationButtonProps = {
     service: NotificationService;
   };

   export const NotificationButton = ({ service }: NotificationButtonProps) => {
     const handleClick = () => {
       service.requestPermission();
     };

     return <Button onClick={handleClick}>알림 받기</Button>;
   };
   ```

   예를 든다면, 컴포넌트가 마운트 되는 시점에 props를 통해 NotificationService를 주입받아 의존성을 해결할 수 있다고 생각했습니다. (NotificationButton은 오직 UI만 책임지고, 알림 요청 로직은 외부에서 주입된 service가 처리합니다.)

2. 객체 생성 후 setter 메서드를 통해 의존성 해결 → Context

   자바의 setter는 객체가 이미 생성된 후에 의존 대상을 교체할 수 있게 합니다.리액트에서는 state나 context를 통해 런타임에 교체 가능한 의존성을 관리할 수 있지 않을까? 생각해봤습니다.

   ```tsx
   const NotificationContext = createContext<{
     service: NotificationService;
     setService: (s: NotificationService) => void;
   } | null>(null);

   export const NotificationProvider = ({
     children,
   }: {
     children: ReactNode;
   }) => {
     const [service, setService] = useState<NotificationService>(
       new FirebaseNotificationService()
     );

     return (
       <NotificationContext.Provider value={{ service, setService }}>
         {children}
       </NotificationContext.Provider>
     );
   };

   const NotificationButton = () => {
     const notification = useContext(NotificationContext)!;

     return (
       <Button onClick={() => notification.service.requestPermission()}>
         알림 받기
       </Button>
     );
   };
   ```

   필요에 따라 setService를 통해 다른 NotificationService로 교체 가능하므로 유연성이 높아진다고 생각했습니다.

3. 메서드 실행시 인자를 이용해 의존성 해결 → 콜백함수 실행

   ```tsx
   type NotificationButtonProps2 = {
     onRequestNotification: (service: NotificationService) => void;
     service: NotificationService;
   };

   const NotificationButton2 = ({
     service,
     onRequestNotification,
   }: NotificationButtonProps2) => {
     return (
       <Button onClick={() => onRequestNotification(service)}>알림 받기</Button>
     );
   };

   export const NotificationCenter = () => {
     const emailService = EmailNotificationService();
     const pushService = PushNotificationService();
     const smsService = SMSNotificationService();

     return (
       <>
         <NotificationButton2
           service={emailService}
           onRequestNotification={(service) => service.sendWelcomeEmail()}
         />
         <NotificationButton2
           service={pushService}
           onRequestNotification={(service) => service.sendUrgentAlert()}
         />
         <NotificationButton2
           service={smsService}
           onRequestNotification={(service) => service.sendVerificationCode()}
         />
       </>
     );
   };
   ```

   책에서는 메서드가 실행될 때마다 의존 대상이 매번 달라져야 하는 경우에 유용하다고 이야기합니다. `onRequestNotification` 핸들러에 다양한 함수가 들어오게 되는 경우, 하나의 버튼 컴포넌트로 여러 서비스 + 여러 액션 조합이 가능하기 때문에

## 조합 가능한 행동

유연하고 재사용 가능한 설계는 응집도 높은 책임을 가진 작은 컴포넌트들을 다양한 방식으로 연결함으로써 애플리케이션의 기능을 쉽게 확장할 수 있다고 이야기 합니다.

**어떻게 구현하는지를 내부에 감추고**, **조합을 통해 무엇을 하는지를 명확하게 표현**하는 설계를 의미하는데, 이는 곧 리액트 공식문서에서 이야기하는 것과 비슷하다는 생각을 하게 됐습니다.

조금 더 리액트 관점에서 생각해보자면, 유연하고 재사용 가능한 설계는 **작**은 컴포넌트들의 행동을 조합함으로써 새로운 기능을 이끌어낼 수 있는 설계이지 않을까? 하는 생각도 했습니다. 객체지향적인 리액트 설계는 개별 컴포넌트의 구현 세부사항에 집착하지 않고, 컴포넌트들의 조합을 선언적으로 표현함으로써 애플리케이션이 무엇을 하는지를 드러내는 방식이 아닐까 생각하게 됐습니다.
