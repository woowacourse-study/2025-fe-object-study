## 8장의 핵심 - 좋은 객체지향 설계는 '의존성 관리'다
유연하고 재사용 가능한 설계를 위해서는, 코드의 의존성을 '구체적인 것(Concrete Implementation)'이 아닌 '추상적인 것(Abstraction)'에 두어야 하며, 이 관계를 명확하게 드러내야 합니다.

## 코드가 아닌, 관계를 설계하라
개발을 시작할 때 우리는 종종 '이 객체는 어떤 데이터를 가져야 하는가?' 또는 '이 객체는 어떤 기능을 수행해야 하는가?'라는 질문부터 던집니다. 하지만 8장을 읽고 나면, 이보다 더 중요한 질문이 있다는 것을 깨닫게 됩니다. 바로 '이 객체는 누구와, 어떻게 협력해야 하는가?' 입니다. 즉, 객체 간의 '의존성'을 어떻게 설정할 것인가의 문제입니다.

8장에서는 객체지향 설계의 본질이 '의존성을 관리하는 기술'이라고 말합니다. 어떤 객체가 다른 객체를 필요로 할 때 둘 사이에 의존성이 생기며, 이 의존성은 변경의 전파 가능성을 의미합니다. 한 객체의 변경이 의존하는 다른 모든 객체에 연쇄적인 수정을 일으킨다면, 그 설계는 변경에 취약할 수밖에 없습니다.

이 문제를 해결하기 위해 8장에서 제시하는 핵심 원칙은 '추상화에 의존하라' 입니다. 예를 들어, Movie 객체가 구체적인 할인 정책 클래스인 AmountDiscountPolicy에 직접 의존한다면, 이 Movie 객체는 오직 금액 할인 정책이라는 특정 문맥에서만 사용 가능합니다. 다른 할인 정책을 적용하려면 Movie 클래스의 코드를 직접 수정해야만 합니다.

하지만 Movie가 AmountDiscountPolicy와 PercentDiscountPolicy를 아우르는 추상 클래스나 인터페이스인 DiscountPolicy에 의존한다면 이야기가 달라집니다. Movie의 코드는 '어떤 할인 정책'이라는 추상적인 존재에만 의존하고, 실제 어떤 구체적인 할인 정책과 협력할지는 실행 시점에 결정됩니다. 이로써 Movie 클래스는 특정 문맥에서 벗어나 독립적으로 재사용될 수 있게 됩니다.

이처럼 코드의 의존성(컴파일타임)과 실제 실행 시점의 의존성을 분리하는 것이 유연한 설계의 핵심입니다. 컴파일타임 의존성은 추상화에 고정시키고, 런타임 의존성은 얼마든지 바꿀 수 있는 구조를 만들어야 합니다.

## 'new'는 해롭다?
추상화에 의존하는 설계를 방해하는 가장 큰 장애물 중 하나는 new 키워드입니다. new는 특정 '구체 클래스'의 인스턴스를 직접 생성하기 때문에, new를 사용하는 코드는 그 구체 클래스에 강하게 결합될 수밖에 없습니다.

이 문제를 해결하기 위해 8장에서는 '사용과 생성의 책임을 분리하라' 고 조언합니다. 즉, 객체를 사용하는 쪽에서 직접 생성하지 말고, 외부에서 생성된 객체를 전달받아(주입받아) 사용하라는 것입니다. 이를 통해 의존성을 객체의 인터페이스에 명시적으로 드러낼 수 있으며, 내부 구현에 대한 불필요한 결합을 제거할 수 있습니다.

결국 좋은 객체지향 설계는 단순히 잘 캡슐화된 객체를 만드는 것에서 그치지 않습니다. 객체와 객체 사이의 관계, 즉 의존성의 그물을 어떻게 짜 나갈 것인지에 대한 깊은 고민이 필요합니다. 8장은 우리에게 코드를 작성하는 행위가 곧 의존성을 설계하는 과정임을 일깨워주며, 변경에 유연하게 대처할 수 있는 견고한 소프트웨어를 만들기 위한 구체적인 방향을 제시합니다.
