# 8장 의존성 관리하기

객체와 다른 객체는 협력을 한다.
협력을 하기 위해 서로 메시지를 주고 받는다.

협력에 의해 객체간에 의존성이 생긴다.

## 1. 의존성 이해하기

### 변경과 의존성

"의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다." 라는 말이 이해가 안갔었다.

- 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

이 둘은 같은 말 아닐까? 왜 시점에 따라 다르게 나눠놨을까? 라는 의문점이 생겼었다.

코드를 보고 정리해보면서 다음과 같이 이해했다.

- 실행 시점: 코드가 **실제로 실행되는 시점**이다. Movie 객체가 할인을 계산하려면 AmountDiscountPolicy나 PercentDiscountPolicy라는 구체적인 실체가 반드시 존재해야 한다.
- 구현 시점: 개발자가 **코드를 작성하는 시점**이다. 이때 Movie는 DiscountPolicy라는 추상적인 개념만 알면 된다.

즉, 시점에 따라 **"아는 것"의 수준이 다르다** 는 차이점이 있었다.

실행 시점에서 신경써야 할 것은 구체적인 구현부가 될 것 같다.
구현 시점에서 신경써야 할 것은 추상적인 인터페이스가 될 거 같다.

### 의존성 전이

의존성 전이가 의미하는 것은 의존하는 대상이 다른 대상에 의존한다면, 그 다른 대상에도 자동적으로 의존하게 된다는 것이다.

직접 의존성: 직접 연결되어 의존
간접 의존성: 직접 연결되어 있지는 않지만, 한 다리 건너 의존.

의존성 전이 = 직접 의존성 + 간접 의존성

이 말은 의존성은 한 단계에서 끝나는 게 아니라, 계속 전파 될 수 있다는 것으로 이해했다.

> 비유하자면 최상위 함수에서 any를 쓰면 이 함수를 쓰는 모든 것들은 전부 반환값이 any로 잡히게 된다와 비슷한 것 같다.

두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다.
의존성이란 결국 변경에 의한 영향의 전파 가능성을 암시한다.

> 이 말을 보고 의존성을 낮춘다는 말이 결합도를 낮춘다는 말과 같은 말이라고 느껴졌다.

### 런타임 의존성과 컴파일 의존성

런타임은 애플리케이션이 실행되는 시점.
컴파일 타임 의존성은 시간이 아니라 우리가 작성한 코드의 구조.

런타임 의존성과 컴파일타임 의존성이 다를 수 있다.

- 컴파일타임 의존성 (p258).
  Movie는 추상화된 DiscountPolicy와 관계가 있다.
  구체화된 Amount DiscountPolicy나 Percent DiscountPolicy와는 직접적으로 연결되어 있지 않다.

- 런타임 의존성 (p259)
  그러나 런타임 의존성을 살펴보면, 구체화된 인스턴스와 직접 연결되어 있어야 한다.
  금액 할인 정책을 적용하기 위해서는 AmountDiscountPolicy의 인스턴스와 협력해야 한다. 비율 할인 정책을 적용하기 위해서는 PercentDiscountPolicy의 인스턴스와 협력해야 한다.

코드를 작성하는 시점 (컴파일타임 의존성)에서는 몰라도 된다.
실행 시점(런타임 의존성)은 알아야 한다.

Movie의 인스턴스가 이 두 클래스의 인스턴스와 함께 협력할 수 있게 만드는 더 나은 방법은 Movie가 두 클래스 중 어떤 것도 알지 못하게 만드는 것이다. 대신 두 클래스 모두를 포괄하는 DiscountPolicy라는 추상 클래스에 의존하도록 만들고 이 컴파일타임 의존성을 실행 시에 PercentDiscountPolicy 인스턴스나 AmountDiscountPolicy 인스턴스에 대한 런타임 의존성으로 대체해야 한다.

코드 작성 시점의 Movie 클래스는 할인 정책을 구현한 두 클래스의 존재를 모르지만 실행 시점의 Movie 객체는 두 클래스의 인스턴스와 협력할 수 있게 된다.

**결론: 컴파일타임에는 추상적인 대상에 의존하고, 런타임에 구체적인 협력 대상을 결정해야 한다. 이를 통해 인터페이스와 구현을 분리할 수 있으며, 코드 변경 없이 협력 대상을 교체할 수 있다.**

> 결론을 내고 보니까, 이 원칙에 따르면 OCP를 지킬 수 있게 되는 것 같다.
> OCP는 "확장에는 열려 있고, 변경(수정)에는 닫혀 있다." 이다.
> 추상화된 인터페이스로 접근할 수 있다면 위 코드 예시처럼 확장에는 열려 있고, 변경에는 닫혀 있을 것 같다.

프론트엔드에서 UI는 추상적인 데이터에 의존하고, 런타임에 구체적인 UI가 결정된다.
조건부 렌더링이 걸려 있다면 더더욱 그런 것 같다.

```tsx
const Component = ({ data }) => {
  if (!data.length) {
    return <div>로딩중입니다.</div>
  }

  return <div>{data.length}개</div>
}
```

- Component의 컴파일타임 의존성: 이 컴포넌트는 data라는 추상적인 props에 의존하고 있다. data가 어떤 데이터인지(배열, 객체 등)만 알면 된다.
- Component의 런타임 의존성: 실제로는 data가 length 속성을 가진 배열일 때만 <div>{data.length}개</div>라는 구체적인 UI를 렌더링하고, 배열이 아닐 때는 <div>로딩중입니다.</div>라는 다른 UI를 렌더링한다.

**이처럼 데이터의 상태에 따라 구체적인 UI가 런타임에 결정된다** 라고 이해했다.

## 2. 유연한 설계

### 의존성과 결합도

협력, 행동(책임), 상태

객체간에 협력을 통해 애플리케이션을 이룬다.
협력이 있으므로 의존성이 있다.
의존성은 필연적이다. 다만 좋은 의존성과 나쁜 의존성이 있다.

**바람직한 의존성이란 설계를 재사용하기 쉽게 만드는 의존성**이다.

컨텍스트에 독립적인 의존성은 바람직한 의존성이고 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.

바람직한 의존성과 바람직하지 못한 의존성을 가리키는 용어가 바로 **결합도**다.
의존성이 **바람직할 때** 두 요소가 **느슨한 결합도(loose coupling)** 또는 **약한 결합도(weak coupling)** 를 가진다.
반대로 두 요소 사이의 의존성이 **바람직하지 못할 때** **단단한 결합도(tight coupling)** 또는 **강한 결합도(strong coupling)** 를 가진다.

> OCP와 연관이 있는 것 같다.
> 의존성이 독립적이지 않고 특정한 컨텍스트에 강하게 결합되면, 재사용이 어려워지고 내부 구현이 항상 바뀌어야 한다.
> 내부가 고정 금액 할인으로 고정되어 있으면, 퍼센트 금액 할인이 필요할 경우 구현을 바꿔야만 한다.
> 이처럼 구현에 의존하게 되는 코드는 바람직한 의존성이 아니다.
>
> 바람직한 의존성을 만든다면 OCP(수정(확장)에는 열려 있고, 변경에는 닫혀있다.) 원칙을 지키게 되는 것 같다.
> **바람직한 의존성이란 설계를 재사용하기 쉽게 만드는 의존성**이다.

상품목록 미션에서 장바구니에 담긴 수량을 헤더에서 보여줘야 했었다.
cartItem을 꺼내기 위해 context api를 사용해 CartHeader 컴포넌트를 만들었었다.

```tsx
// 기존 CartHeader
function CartHeader() {
  const { cartItems } = useShoppingCartData();

  ...

  return (
    <Styled.Container>
      <a href="./">
        <Styled.Title>SHOP</Styled.Title>
      </a>
      <Styled.ButtonWrapper>
        <Styled.Button onClick={handleOpenModal}>
          <Styled.Image src={shoppingBag} />
          <Styled.ShoppingBag>{cartItems.length}</Styled.ShoppingBag>
        </Styled.Button>
      </Styled.ButtonWrapper>
      ...
    </Styled.Container>
  );
}

```

그러나 context가 강하게 결합된 헤더는 재사용하기 어렵다는 단점이 있었다.
배경 색상도 같고, 위치도 같은데 세부 UI에 변화가 생겨서 더이상 장바구니에 담긴 수량을 보여주지 않고, 로고 버튼이 뒤로가기로 달라져야 할 때 기존의 CartHeader는 재사용할 수 없었다.
그렇다면 어떻게 해야 재사용하기 좋게 만들 수 있을까?
특정한 컨텍스트, 즉 CartItems와 강하게 결합된 의존성을 끊어내면 될 것 같다.

```tsx
// 공용 헤더 컴포넌트
function Header({ children }: { children?: React.ReactNode }) {
  return <Styled.Container>{children}</Styled.Container>;
}

// 변경된 CartHeader
function CartHeader() {
  const { cartItems } = useShoppingCartData();

  ...

  return (
    <Header>
      <a href="./">
        <Styled.Title>SHOP</Styled.Title>
      </a>
      <Styled.ButtonWrapper>
        <Styled.Button onClick={handleOpenModal}>
          <Styled.Image src={shoppingBag} />
          <Styled.ShoppingBag>{cartItems.length}</Styled.ShoppingBag>
        </Styled.Button>
      </Styled.ButtonWrapper>
      ...
    </Header>
  );
}

// 추가된 주문 확인 Header

function OrderConfirmationHeader({
  handleGoBackToHomeButton,
}: {
  handleGoBackToHomeButton: () => void;
}) {
  return (
    <Header>
      <Styled.GoBackButton onClick={handleGoBackToHomeButton}>
        <Styled.GoBackIcon src={goBack} alt="Go back" />
      </Styled.GoBackButton>
    </Header>
  );
}

```

UI와 context 의 의존성을 끊어내면서 재사용 가능한 컴포넌트인 Header 컴포넌트가 만들어졌다.

**Header 컴포넌트는 오직 레이아웃이라는 단일 책임만 가지게 되었고, children이라는 추상적인 인터페이스에 의존함으로써 모든 컨텍스트로부터 자유로워졌다.**

어디선가 결합은 반드시 이루어지기 마련인데, 어떻게 해야 느슨한 결합을 만들 수 있을지 조금은 알게 된 것 같다.

### 지식이 결합을 낳는다.

서로에 대해 알고 있는 지식의 양이 결합도를 결정한다.

많이 알면 결합도가 올라간다. 이는 곧 낮은 응집도를 의미한다.
적게 알면 결합도가 낮아진다. 이는 곧 높은 응집도를 의미한다.

결합도를 낮추기 위해서 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다.
그 방법으로는 **추상화**가 있다.

> **추상화: 결합도를 낮추기 위해서 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것**

### 추상화에 의존하라

추상화와 결합도의 관점에서 의존 대상을 다음과 같이 구분하는 것이 유용.
목록에서 아래쪽으로 갈수록 클라이언트가 알아야 하는 지식의 양이 적어지기 때문에 결합도가 느슨해진다.

- 구체 클래스 의존성(concrete class dependency)
- 추상 클래스 의존성(abstract class dependency)
- 인터페이스 의존성(interface dependency)

**실행 컨텍스트에 대해 알아야 하는 정보를 줄일수록 결합도가 낮아진다**.
**의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다**.

**의존성은 명시적으로 표현돼야 한다.**

명시적인 의존성: 퍼블릭 인터페이스에 의존성을 명시적으로 노출.
숨겨진 의존성: 의존성이 퍼블릭 인터페이스에 표현되지 않음.

로또 미션을 생각해보면 1~45의 숫자를 입력받는 게 생각난다.
최소가 1, 최대가 45였는데 이 최소, 최대를 인자로 전달 받으면 명시적인 의존성이다. 재사용도 가능해진다.
그러나 이 값들을 내부에 숨겨두면, 이는 숨겨진 의존성이다. 재사용이 불가능해진다.

```tsx
// bad case
const getRandomNumber = () => {
  return Math.ceil(Math.random() * (45 - 1) + 1)
}

// good case
const getRandomNumber = (min, max) => {
  return Math.ceil(Math.random() * (max - min) + min)
}
```

### 컨텍스트 확장하기

일반적으로 어떤 값이 적용되지 않거나, 정책이 적용안된다는 것은 null로 두고 내부 코드에서 조건문으로 처리한다.
그런데 이러면 내부 코드가 변경된다. if(어떤 조건 === null) 이런 조건문이 생기게 된다.
예외라고 생각하지 말고, 이를 정책의 한 케이스라고 생각하자.
예를 들자면, 할인 정책이 존재하지 않는다는 사실을 할인 정책의 한 종류로 간주하는 것이다.

### 조합 가능한 행동

유연하고 재사용 가능한 설계는 객체가 어떻게(how) 하는지를 장황하게 나열하지 않고도 객체들의 조
합을 통해 **무엇(what)을 하는지를 표현하는 클래스들**로 구성된다.
따라서 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지를 쉽게 파악할 수 있다.
코드에 드러난 로직을 해석할 필요 없이 객체가 어떤 객체와 연결됐는지를 보는 것만으로도 객체의 행동을 쉽게 예상하고 이해할 수 있기 때문이다.
다시 말해 선언적으로 객체의 행동을 정의할 수 있는 것이다.

훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라
객체들의 조합을 선언적으로 표현함으로써 **객체들이 무엇을 하는지를 표현하는 설계**다.
그리고 지금까지 설명한 것처럼 이런 설계를 창조하는 데 있어서의 핵심은 **의존성을 관리하는 것**이다.
