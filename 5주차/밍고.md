# 의존성 관리하기

## 개요

객체간의 협력을 통해 기능을 구현하는 객체지향 설계에서 객체간의 의존성은 당연히 존재한다. 다른 객체와 협력을 하려면 다른 객체가 있는지, 해당 객체는 어떤 정보를 가지고 있는지 당연히 알아야 한다.

하지만 과도한 의존성은 쉽게 변경하지 못하는 구조를 만든다. 하나의 객체가 바뀌었으므로 이에 직접적으로 의존하고 있던 객체들도 맞춰 바뀌어야 한다. 뿐만 아니라 의존성은 전이된다. 따라서 전이된 의존성에 의해 간접적으로 의존하고 있던 객체들도 맞춰 바뀌어야 한다. 이처럼 의존성은 하나의 변경이 여러 객체에 영향을 미칠 수 있는 구조를 만들기 때문에 적절하게 관리하는 게 중요하다.

오브젝트 8장은 의존성을 관리하는 것, 즉 객체가 변화를 받아들일 수 있게 의존성을 정리하는 것이 객체지향 설계의 핵심이라고 소개하고 있다. 그렇다면 프론트엔드에선 어떻게 의존성을 관리할 수 있을까?

## 컨텍스트 독립성

의존성은 **런타임 의존성**과 **컴파일타임 의존성**으로 나누어 생각할 수 있다.

런타임 의존성은 실제로 앱을 실행했을 때 누구랑 의존하고 있는지를 말한다. 반면 컴파일타임 의존성은 실제 코드에서 해당 객체가 누구랑 의존하고 있는지이다. 여기서 컴파일타임 의존성에 집중할 필요가 있다. 런타임 의존성은 실제 기능을 실행할 때 어떤 특정한 객체와 협력해야 한다. 그러므로 당연히 특정한 객체에 의존할 수 밖에 없다. 하지만 그렇다고 컴파일타임에서도 해당 객체와 의존해야 한다는 게 아니다.

컴파일타임에서 구체적인 객체를 알지 말고, 런타임에서 알려주자. 구체적인 객체를 알려주는 순간 그 객체가 사용하는 특정 문맥에 강하게 결합된다. 이처럼 객체가 사용된 특정 문맥에 대해 최소한의 가정을 제공하면 다른 문맥에서 재사용하기 더 수월해지는데, 이를 **컨텍스트 독립성**이 높다고 말한다.

리액트에서 컨텍스트 독립성을 잘 파악할 수 있는 환경은 스토리북이다. 만약 한 컴포넌트의 props가 다른 객체에 의존한다고 생각해보자. 어떤 커스텀 훅을 보인다거나, 다른 유틸함수에 의존하는 형태일 것이다. 이 경우 스토리북을 통해 컴포넌트를 표시하는 것은 어려움을 겪을 것이다. 컨텍스트 독립성이 없기 때문이다.

대신 인터페이스에만 집중하여 컴포넌트를 구성한다면 충분히 스토리북에 표시할 수 있을 것이다. setState와 같은 "어떤 함수"를 받는 게 아니라, 버튼을 눌렀을 때 실행할 `() => void` 형태를 받을 수 있다고 구현하자.

![선택바](https://github.com/user-attachments/assets/46844903-1301-4e45-b5f9-b02d7bebc179)

## 의존성과 결합도

사실 의존성은 결합도랑 거의 비슷한 개념이다. 의존성이 적을수록 결합도는 느슨하다. 한 객체가 다른 객체에 대해 많이 알수록, 의존할수록 더 많이 결합된다. 즉 지식이 결합을 낳는다. 이를 반대로 생각해보자. **한 컴포넌트 내에 어떤 지식을 다루고 있는지 생각하면 결합도 / 의존성 정도를 확인할 수 있다.**

`ProgressBar` 컴포넌트를 살펴보자. 개발하고 있는 서비스에서 단계는 'name', 'date', 'check' 세 가지이다. 이 정보를 `ProgressBar`도 알고 있어야 할까? 해당 컴포넌트를 구상할 때 처음에는 해당 정보를 알고 있게 구현했다. 그러니 요구사항이 변경되어 단계가 수시로 추가되거나 삭제되는 경우에 이에 맞춰 컴포넌트도 변경해주어야 했다. 현재 단계가 어떤 값인지에 따라 표시해야 하는 정도가 달라져야 했기 때문이다.

![프로그래스바](https://github.com/user-attachments/assets/3b18af0d-cffb-41e3-bf15-6949badf2b54)

따라서 현재는 `ProgressBar`의 인터페이스에 단계 정보가 아니라 숫자 정보를 넣도록 변경하고, 컴포넌트 안쪽에서 단계를 계산하는 게 아니라 바깥에서 계산하여 숫자만 넘겨주도록 설계를 변경했다. 이를 통해 특정 단계에만 의존적인 컴포넌트가 아닌 전체 단계가 필요한 경우에 언제든 활용할 수 있는 컴포넌트를 만들 수 있었다.

## 추상화에 의존하라

그렇다면 적은 결합으로 협력하려면 어떻게 해야할까? 오브젝트에선 **"추상화"에 의존하라**는 해결책을 제시한다. 특히 서로의 의존성을 **인터페이스 의존성**으로 가져갈 것을 강조한다.

인터페이스 의존성을 가진 객체 사이엔 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만 공유한다. 이를 프론트엔드에선 Typescript를 이용해 의존성을 제공하고 있다. 말 그대로 `interface` 키워드를 이용해 인터페이스 의존성을 챙길 수 있다.

## 명시적인 의존성

모든 경우에 의존성은 명시적으로 퍼블릭 인터페이스에 노출된다. 만약 명시적으로 의존성을 명시하지 않으면 다음과 같은 문제가 발생하게 된다.

- 의존성 파악을 위해 내부 구조를 참고해야 한다.
- 객체를 다른 컨텍스트에서 재사용하고 싶다면 내부 구현을 이에 맞춰 직접 바꿔줘야 한다.

![LeftTimeInformationBox](https://github.com/user-attachments/assets/bedcd4cb-2875-413b-bc91-90ac442e9917)

`LeftTimeInformationBox`는 스페이스를 생성하기까지 남은 시간을 표시하는 컴포넌트이다. 이 때 남은 시간을 초마다 이동시키기 위해 useLeftTimer라는 훅을 이용해 시간을 1초마다 남은 시간을 계산하는 로직을 가지고 있다.

컴포넌트를 `남은 시간 정보 박스`라는 이름으로 마침 지었겠다, 해당 훅을 컴포넌트 내부에서 불러와서 붙여 넣을 수도 있다. 하지만 이렇게 되면 의존성이 명시적이지 못하고 숨겨지게 된다. 그렇다면 변경이 필요한 경우 큰 불편함이 따르게 된다.

만약 해당 부분에 남은 시간을 표시할 때 1일 이상일때 "1일"이라는 문자를 보이고 싶다면? useLeftTimer의 반환값을 이에 맞춰 1일로 바꿔줘야 할까? 이렇게 되면 커스텀 훅이 컴포넌트의 표시에 너무 의존적이게 되지 않을까?

그보다는, 차라리 의존성을 명시하자. 해당 부분을 string으로 받을 수 있는 인터페이스로 분리하면 해결할 수 있다.

![스토리북](https://github.com/user-attachments/assets/e412e8c3-79c2-496a-b41b-84428c848c45)

## 결론

객체지향 설계의 핵심은 의존성 관리이다. 의존성 관리를 통해 과도한 결합을 피하고 컴포넌트를 다양한 문맥에서 재사용 가능하게 만들 수 있다. 이를 위해 오브젝트 6장에선 여러 방법을 제시했고 이를 프론트엔드 환경에서 어떻게 활용할 수 있을 지 생각해보았다.

<details><summary><b>부록: 정리노트</b></summary>

![정리노트](https://github.com/user-attachments/assets/b599f77e-6b2a-42d8-a328-c2dfa3d0b738)

</details>
