# 9장: 유연한 설계

## 개방-폐쇄 원칙

책에서 한 줄로 요약한 개방-폐쇄 원칙은 다음과 같다.

- 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

문장으로 보자면 당연하고도 옳은 이야기가 아닐 수 없다. 새로운 기능 확장을 위해 기존 코드를 뜯어내야 한다면 이는 변화에 제대로 대응하지 못하는 코드임이 분명하다. 개방-폐쇄 원칙을 위해 책에선 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라는 대안을 내놓는데, 이를 추상화로 구현할 수 있다.

### 행성이 홈 화면 익스텐션: LocalStorage 값 가져오기

행성이 익스텐션에선 LocalStorage 내 값을 가져와 이를 state에 반영해야 하는 요소가 있었다.

![행성익스텐션state반영요소](https://github.com/user-attachments/assets/00097dbe-295f-4cfc-a211-1ffe21a6f520)

따라서 LocalStorage를 읽어 state로 적용하는 로직이 필요했고, 이를 useInitStorage라는 훅으로 구현했다. LocalStorage의 값을 읽거나 쓰는 get, set 등의 함수를 객체로 묶어 관리하고 이를 이용해 useEffect로 setState를 실행하는 방식으로 구현한다.

```ts
const LocalStorage: LocalStorage = {
  setJSON(key, data) {
    localStorage.setItem(key, JSON.stringify(data));
  },

  getJSON<T>(key: string) {
    try {
      const data = localStorage.getItem(key);
      if (data) return JSON.parse(data) as T;
      return null;
    } catch {
      throw new Error('로컬 스토리지에서 정보를 가져오는 과정에 오류가 발생했습니다.');
    }
  },
};

export default LocalStorage;
```

![추상화구현전](https://github.com/user-attachments/assets/abfd4690-f6d4-44ac-afab-24d327af8b0b)

이 구조가 왜 좋지 않을까? **useInitStorage가 LocalStorage에 강하게 의존하고 있다.** 만약 LocalStorage가 아니라 SessionStorage 혹은 쿠키로 정보를 옮긴다면 어떻게 될까? 기존 코드를 전부 뜯어 고쳐야 할 것이다. 원칙에 따라 수정에 대해서는 닫혀 있어야 하지만 그렇지 않은 것이다.

따라서 useStorage라는 중간 도메인을 두어 이를 해결할 수 있었다.

```ts
import { useCallback } from 'react';
import LocalStorage from '../utils/LocalStorage';

const useStorage = () => {
  const getStorageValue = useCallback(<T>(key: string) => LocalStorage.getJSON<T>(key), []);
  const setStorageValue = useCallback(
    (key: string, data: unknown) => LocalStorage.setJSON(key, data),
    []
  );
  const initStorageValue = useCallback(
    <T>(key: string, initData: unknown) => {
      if (!getStorageValue<T>(key)) setStorageValue(key, initData);
    },
    [getStorageValue, setStorageValue]
  );

  return { getStorageValue, setStorageValue, initStorageValue };
};

export default useStorage;
```

![추상화구현후](https://github.com/user-attachments/assets/48d1480c-7122-415d-b497-0e9269ad2bbc)

중간 도메인을 둠으로써 어떤 문제를 해결할 수 있었을까?

- useInitStorage는 useStorage에 의존한다. useStorage의 인터페이스는 추상화된 메서드를 반환한다.
  - LocalStorage든, 쿠키든 Storage로써 할 수 있는 행위(get, set, init)가 가능하다면 어떤 경우에서도 적용이 가능하다.
- 새로운 형태의 storage가 와도 get, set, init만 할 수 있다면 대응이 가능하다.

우테코의 수업에서도 API 로직에 중간 도메인을 두는 것을 배웠다. 이처럼 중간 도메인을 통해 받아올 수 있는 형태를 추상화하면 확장에 대해 열려있고 수정에 대해 닫혀있는 구조를 생각해볼 수 있다.

## 표현적 분해와 행위적 분해

객체지향의 배우를 꼽자면 역시 객체이다. 객체지향 설계에 따르면 각 책임을 가지고 있는 객체의 협력으로 전체적인 기능을 구성한다. 따라서 객체를 적절하게 나누는 것도 중요한데, 책에서는 이를 표면적 분해와 행위적 분해로 구분하고 있다.

표면적 분해는 실제 세계처럼 객체를 분해하는 기준을 정하는 것이다. 반면 행위적 분해는 실제 세계가 아니고, 행위를 바탕으로 객체를 분리하는 기준을 정하는 것이다. 이는 책에서 누차 이야기한 것처럼 객체지향의 세계를 실제세계랑 완전히 같다고 보면 안되는 이유가 된다.

이렇게 객체를 다양하게 생성할 수 있다고 언급한 이유는 무엇일까? 행위 하나하나에 객체를 전부 만들어 낼 수 있다는 뜻은 모든 책임마다 객체를 생성할 수 있음을 뜻한다. 즉 추상화를 위해서라면 실세계에 없는 객체여도 과감하게 분리할 수 있는 가능성을 제시한다.

### 예시

책에서는 객체의 생성과 조작을 한 번에 하지 않도록 FACTORY와 같이 생성하는 책임에 대한 객체를 따로 둔 것을 예시로 둘 수 있다. 행성이 익스텐션에선 어떤 객체가 행위적 분해에 의해 만들어졌을까? [위성이 자체와 위성이를 움직이는 OrbitalMoving 컴포넌트를 분리한 것](https://github.com/woowacourse-study/2025-fe-object-study/blob/c543bb490fcf7bae58872dd00ac58409f75fd224/2%EC%A3%BC%EC%B0%A8/%EB%B0%8D%EA%B3%A0.md#%EC%B1%85%EC%9E%84-%EA%B4%80%EC%A0%90%EC%9C%BC%EB%A1%9C-%EB%B0%94%EB%9D%BC%EB%B3%B4%EB%A9%B4-%EC%96%B4%EB%96%A8%EA%B9%8C)을 생각해볼 수 있다.

행성이 주변을 도는 위성이는 자체적으로 표시되고, 움직인다. 그렇기에 표면적 분해에 의해 하나의 위성이 컴포넌트로 생각한다면 두 책임을 한 번에 구현해야 한다.

하지만 책임 관점으로 바라보고 행위적 분해를 한다면 위성이는 두 객체로 분리할 수 있다.

- OrbitalMoving: 위성이의 움직임을 담당하는 컴포넌트
- Satellite: 위성이를 표시하는 컴포넌트

```tsx
<OrbitalMoving
  center={{ x: 0, y: 0, zIndex: 13 }}
  radius={{ x: 200, y: 80 }}
  speed={50}
  initialAngle={0}
  initialOrbitRotationAngle={-30}
>
  <Satellite name={selectedSatellite.name} size={80} />
</OrbitalMoving>
```

"위성이의 움직임"은 실제 세계에서 객체로 보기 어렵다. 하지만 이러한 움직임도 추상화를 통해 분리한다면 OrbitalMoving에 Satellite 뿐만 아니라 다양한 요소가 들어갈 수 있는 유연한 구조를 만들 수 있다.

## 의존성 주입

사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해 의존성을 해결하는 방법을 의존성 주입이라고 부른다. 의존성 주입은 사용하는 객체에선 어떤 객체가 올지는 모르지만 외부에서 어떤 요소가 오든 이를 활용하라는 뜻을 가지고 있고, 이 역시 추상화로 볼 수 있다.

리액트의 관점에서 외부 객체가 인스턴스를 생성하고 이를 전달하는 방식을 생각해보면 render props와 합성 컴포넌트를 생각해볼 수 있었다.

### render props

- 컴포넌트 자체는 아무 것도 렌더링하지 않는다.
- render를 하는 함수를 props로 받아 호출한다.
- 특정 데이터를 동시에 사용하는 컴포넌트(객체)를 주입받아 표시한다.

```tsx
export default function App() {
  return (
    <div className="App">
      <h1>☃️ Temperature Converter 🌞</h1>
      <Input>
        {(value) => (
          <>
            <Kelvin value={value} />
            <Fahrenheit value={value} />
          </>
        )}
      </Input>
    </div>
  );
}

function Input(props) {
  const [value, setValue] = useState('');

  return (
    <>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
        placeholder="Temp in °C"
      />
      {props.children(value)}
    </>
  );
}
```

### 합성 컴포넌트

- 상위 컴포넌트에서 모든 컴포넌트를 표시하지 않는다.
- 상위 컴포넌트 내에 하위 컴포넌트를 조합해 하나의 컴포넌트를 구성한다.
- 상위 컴포넌트 입장에서 표시할 하위 컴포넌트(객체)를 children props로 주입받는다.

```tsx
<Modal isOpen={isOpen} onClose={() => setIsOpen(false)}>
  <Modal.Overlay />
  <Modal.Content>
    <p>모달열림</p>
    <input placeholder="첫 번째 인풋" data-testid="first-input" />
    <button data-testid="second-button">두 번째 버튼</button>
    <a href="#" data-testid="third-link">
      세 번째 링크
    </a>
  </Modal.Content>
</Modal>
```

## 추상화에 의존하라

결국 오브젝트 9장의 모든 이야기는 **"추상화에 의존하라"**는 한 문장으로 귀결된다. 개방-폐쇄 원칙, 표현적 분해와 행위적 분해, 의존성 주입 전부 객체가 추상화에 의존해야 하는 이유를 설명한다.

이 글에선 리액트에선 어떻게 추상화가 이루어지고 있는지 알아봤다. 객체가 다른 객체와 유연하게 협력할 수 있도록 돕는 추상화를 잘 사용한다면 요구하는 변화에 잘 대응할 수 있는 유연한 구조를 만들 수 있을 것이다.