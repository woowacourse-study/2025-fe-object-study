이번 장을 읽으면서 특히 기억에 남았던 부분은개방-폐쇄 원칙과 의존성 역전이었습니다. 처음엔 추상적이라고 느꼈는데, 곱씹다 보니 제가 자주 다루는 **Button 컴포넌트**가 자연스럽게 떠올랐습니다.

## 개방- 폐쇄 원칙

개방-폐쇄 원칙은 소프트웨어 개체가 확장에는 열려 있고, 수정에는 닫혀 있어야 한다는 원칙입니다.

- 확장에 열려 있다 = 요구사항이 변경될 때 이 변겡에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있다.
- 수정에 닫혀 있다 = 기존 코드를 수정하지 않고도 애플리케이션 동작을 추가하거나 변경할 수 있다.

책에서는 이 원칙을 “컴파일타임 의존성은 고정하고, 런타임 의존성은 바꿔라”라고 설명합니다. 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경시키라는 말이 잘 와닿지 않아서 이에 대해 생각을 먼저 해봤습니다.

**컴파일타임 의존성이란** TypeScript 컴파일러가 코드를 해석하고 JavaScript로 변환하는 과정에서 결정되는 의존 관계를 말합니다. 이 시점에서는 코드가 구체적인 구현체가 아니라 **어떤 인터페이스나 추상화에 의존하고 있는지만** 확인할 수 있습니다. 예를 들어, Button 컴포넌트가 ButtonProps 타입을 받는다는 사실까지만 알 수 있습니다.

```tsx
type ButtonProps = {
  variant: "primary" | "secondary" | "danger";
  size?: "sm" | "md" | "lg";
  onClick: () => void;
  children: ReactNode;
};

function OrderForm() {
  return (
    <Button variant="primary" onClick={handleSubmit}>
      주문하기
    </Button>
  );
}
```

이 시점에서 컴파일러는 Button이 variant, onClick, children을 받아야 한다는 사실만 알지, 실제 어떤 스타일이나 동작이 들어가는지는 모릅니다.

**런타임 의존성이란** 코드가 실제 실행될 때 결정되는 구체적인 구현입니다. 같은 인터페이스를 구현하더라도 실행 환경이나 조건에 따라 다른 구현체가 사용될 수 있습니다.

```tsx
function Button({ variant, size, onClick, children }: ButtonProps) {
  return (
    <button className={buttonVarint[variant]} onClick={onClick}>
      {children}
    </button>
  );
}
```

개방-폐쇄 원칙의 핵심은 추상화에 있다고 하는데요. 만약, 일반적인 버튼, 삭제와 같이 위험 요소에 대해 나타내는 버튼, 보조 작업을 위한 버튼 등이 있다고 했을 때 추상화 없이 만든다면 다음과 같아집니다.

```tsx
function PrimaryButton({ onClick, children }) {
  return (
    <button
      className="bg-blue-500 hover:bg-blue-700 text-white"
      onClick={onClick}
    >
      {children}
    </button>
  );
}

function DangerButton({ onClick, children }) {
  return (
    <button
      className="bg-red-500 hover:bg-red-700 text-white"
      onClick={onClick}
    >
      {children}
    </button>
  );
}

function SecondaryButton({ onClick, children }) {
  return (
    <button
      className="bg-gray-500 hover:bg-gray-700 text-white"
      onClick={onClick}
    >
      {children}
    </button>
  );
}
```

그러나 이렇게 구현하면 새로운 스타일의 버튼이 필요할 때마다 새로운 컴포넌트를 만들어야 하고 공통된 로직(클릭 처리, 기본 스타일 등등)을 계속 반복해야 되는 문제가 생기게 됩니다.

이때 책에서 이야기한 변경되지 않을 부분과 변경되는 부분을 나눠 처리하면 책에서 이야기한 추상화를 통해 복잡성을 극복할 수 있습니다.

```tsx
type ButtonProps = {
  variant: "primary" | "secondary" | "danger";
  onClick: () => void;
  children: React.ReactNode;
};

const variantClasses = {
  primary: "bg-blue-500 hover:bg-blue-700 text-white",
  secondary: "bg-gray-500 hover:bg-gray-700 text-white",
  danger: "bg-red-500 hover:bg-red-700 text-white",
} as const;

function Button({ variant, onClick, children, ...props }: ButtonProps) {
  return (
    <button
      className={cn(
        "px-4 py-2 rounded font-medium transition-colors",
        variantClasses[variant]
      )}
      onClick={onClick}
      {...props}
    >
      {children}
    </button>
  );
}
```

다음과 같이 수정하면, 확장에는 열리고 수정에는 닫힌 구조가 되는데요. 하나의 잘 추상화된 버튼 덕분에 여러군데에서 사용하기가 용이해짐을 알 수 있습니다.

```tsx
function UserProfile() {
  const handleEdit = () => {
    /* 편집 로직 */
  };
  const handleDelete = () => {
    /* 삭제 로직 */
  };

  return (
    <div>
      <Button variant="primary" onClick={handleEdit}>
        편집
      </Button>
      <Button variant="danger" onClick={handleDelete}>
        삭제
      </Button>
    </div>
  );
}

function OrderSummary() {
  const handleOrder = () => {
    /* 주문 로직 */
  };
  const handleCancel = () => {
    /* 취소 로직 */
  };

  return (
    <div>
      <Button variant="primary" onClick={handleOrder}>
        주문하기
      </Button>
      <Button variant="secondary" onClick={handleCancel}>
        취소
      </Button>
    </div>
  );
}
```

여기서 중요한 것은 `UserProfile`과 `OrderSummary` 컴포넌트들이 Button의 구체적인 구현에 대해서는 전혀 알 필요가 없다는 점입니다. 이들은 오직 `ButtonProps` 인터페이스에만 의존하고 있습니다.

따라서 개방-폐쇄 원칙을 제대로 적용하면 기존 코드를 수정하지 않고도 기능을 확장할 수 있습니다.

## 의존성 역전

일반적인 구조에서는 상위 레벨 모듈(비즈니스 로직)이 하위 레벨 모듈(구체적인 구현체)에 직접 의존합니다.

예를 들어, PaymentForm이 신용카드, 페이팔, 계좌이체 버튼 같은 구체적인 버튼 컴포넌트를 직접 사용한다면, 새로운 결제 수단이 추가될 때마다 PaymentForm의 코드를 수정해야 합니다.

```tsx
function PaymentForm() {
  const handleCreditCard = () => {
    /* 신용카드 처리 */
  };
  const handlePayPal = () => {
    /* PayPal 처리 */
  };
  const handleBankTransfer = () => {
    /* 계좌이체 처리 */
  };

  return (
    <div>
      <CreditCardButton onClick={handleCreditCard} /> {/* 구체적 구현에 의존 */}
      <PayPalButton onClick={handlePayPal} /> {/* 구체적 구현에 의존 */}
      <BankTransferButton onClick={handleBankTransfer} />{" "}
      {/* 구체적 구현에 의존 */}
    </div>
  );
}
```

문제는 이 구조가 확장에는 닫혀 있다는 점입니다. 새로운 결제 방식(예: 암호화폐 결제)을 추가하려면 PaymentForm 내부에 코드를 또 넣어야 합니다. 즉, 변경의 이유가 계속 누적되면서 유지보수성이 떨어지게 됩니다.

이때 의존성 역전을 적용해보면, 구조가 훨씬 유연해집니다. 핵심은 상위 레벨 모듈이 구체적 구현이 아니라 추상화(인터페이스)에 의존하도록 만드는 겁니다.

```tsx
// 의존성 역전된 구조
interface PaymentMethod {
  type: string;
  label: string;
  handler: () => void;
}

function PaymentForm({ paymentMethods }: { paymentMethods: PaymentMethod[] }) {
  return (
    <div>
      {paymentMethods.map((method) => (
        <Button key={method.type} variant="primary" onClick={method.handler}>
          {method.label}
        </Button>
      ))}
    </div>
  );
}

const paymentMethods: PaymentMethod[] = [
  { type: "card", label: "신용카드", handler: handleCreditCard },
  { type: "paypal", label: "PayPal", handler: handlePayPal },
  { type: "bank", label: "계좌이체", handler: handleBankTransfer },
  { type: "crypto", label: "암호화폐", handler: handleCrypto },
];
```

이제 PaymentForm은 단순히 PaymentMethod라는 인터페이스만 바라봅니다.
실제로 어떤 결제 방식이 있는지는 외부에서 주입(props)될 뿐, PaymentForm 내부 로직은 건드릴 필요가 없습니다.

이 책을 읽으면서 가장 크게 느낀 건, 저자가 처음부터 끝까지 사실상 같은 메시지를 다양한 예시로 반복하고 있다는 점이었습니다. 결국 핵심은 하나였던 것 같아요. 책임이 제대로 분리되어 있는가? 이 질문으로 모든 설계 원칙이 연결되는 느낌이었습니다. (가추한게 맞았던..)

책을 읽기 전에는 솔직히 의문이 많았습니다. “프론트엔드 개발자가 객체지향을 꼭 알아야 할까?” 하고요. 객체지향이라고 하면 보통 Java나 C++ 같은 언어가 떠올랐었고, 프론트엔드랑은 거리가 있다고 여겼으니까요. 하지만 책을 어느정도 읽은 지금 시점에서는 생각이 많이 바뀌었습니다. 제가 중요하게 여겨왔던 **응집도, 결합도, 모듈 간 의존성 관리** 같은 개념들이 결국 다 객체지향 설계 원칙에서 이어진다는 걸 느꼈어요. 언어가 달라도 설계의 본질은 동일하다는 사실을 깨달았습니다.

그럼에도 책을 읽는 내내 하나의 의문은 남아 있었습니다. 저자가 결국 같은 메시지를 계속 다른 방식으로 풀어내고 있다면, 과연 끝까지 읽는 의미는 무엇일까? 마지막에 새로운 통찰을 얻을 수 있을까? 하는 생각이 자주 들었습니다.

또 한가지 흥미로웠던 점은, 객체지향에 대해 백엔드 크루들이나 스터디원들과 이야기를 나눌 때마다 서로 관점이 달랐는데요. 같은 원칙을 두고도 각자가 중요하게 여기는 지점/해석하는 방향이 달랐습니다. 이런 상황들을 경험하면서, 객체지향이라는 게 결국 어떤걸 중점으로 두고 해석하느냐에 따라 달라지고, 명확히 정의하기 어려운 개념이라는 생각이 들었습니다.

따라서 저는 “객체지향은 기술적인 방법론이라기보다는 철학에 가깝다!”라는 생각이 많이 들었습니다. 절대적인 정답도, 완벽한 객체지향 설계도 존재하지 않는다. 중요한 것은 주어진 상황과 맥락에 따라 원칙을 얼마나 적절히 적용할 수 있느냐(혹은 정말 객체지향이 필요한 상황인가?)인 것 같다. 물론 이 생각 역시 앞으로 더 많은 경험을 쌓으면서 또 달라질 수 있을 거라 생각합니다. 그럼 스터디 끗!
