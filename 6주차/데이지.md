유연한 설계를 위한 기법들로 아래의 기법들이 나온다.

- 개방-폐쇄 원칙
  - 수정에는 열려있되, 그 수정을 위해 기존 코드를 수정하면 안된다.
  - 이걸 위해서 추상화를 사용한다. 수정되지 않는 추상화에 의존하고, 새로운 기능은 런타임 시점의 클래스나 구현체로 확장한다.
- 생성 사용 분리 원칙(팩토리 등)
  - 객체를 생성하는 책임과 사용하는 책임을 분리한다.
  - 객체의 생성과 사용을 분리하면 사용에 관한 책임만 해당 클래스에 있어서 유연한 설계를 가질 수 있다.
- 의존성 주입
  - 필요한 의존성을 외부에서 주입받는다.
  - 하위 컴포넌트나 클래스가 내부에서 직접 생성하지 않으므로 변경에 유연하다.
- 의존성 역전 원칙
  - 상위 모듈이 하위 모듈에 직접 의존하면 안된다.
  - 상위와 하위 모두 추상화에 의존하고, 구체 구현체는 런타임에 주입한다.

<br />

# 개방-폐쇄 원칙

- 소프트웨어 개체(클래스, 모듈, 함수 등등)은 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
- 확장에 대해 열려 있다: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 ‘동작’을 추가해서 애플리케이션의 기능을 확장할 수 있다.
- 수정에 대해 닫혀 있다: 기존의 ‘코드’를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.
- 사실 개방-폐쇄 원칙은 런타임 의존성과 컴파일 타임 의존성에 관한 이야기다.

그리고 이 책에서는 개방-폐쇄 원칙에 대해 **추상화**가 핵심이라고 한다. 개방-폐쇄 원칙(OCP) 관점에서 리액트에서 추상화를 활용하는 사례를 소개하겠다.

## 1. 합성 컴포넌트

```jsx
function Modal({ title, children, onClose }: ModalProps) {
  return (
    <Overlay>
      <Container>
        <Header>
          <h2>{title}</h2>
          <button onClick={onClose}>닫기</button>
        </Header>
        <Content>{children}</Content>
      </Container>
    </Overlay>
  );
}

// 사용 예시
<Modal title="알림" onClose={handleClose}>
  <p>여기에 원하는 내용 삽입</p>
</Modal>;
```

- 합성 컴포넌트를 활용한 예시: 모달, 헤더 등
- 상위 컴포넌트는 내부 구조/스타일을 그대로 유지하면서, 하위로 전달되는 children에 따라 동작/내용 변경할 수 있다.
- 하위 컴포넌트가 달라져도 상위는 수정할 필요 없다.

## 2. 공통 컴포넌트 + props로 확장

```jsx
function Button({
  onClick,
  variant = 'primary',
  size = 'fit',
  customStyle,
  children,
  ...rest
}: PropsWithChildren<ComponentProps<'button'> & ButtonProps>) {
  return (
    <StyledContainer
      customStyle={customStyle}
      variant={variant}
      size={size}
      onClick={onClick}
      {...rest}
    >
      {children}
    </StyledContainer>
  );
}
```

- Button처럼 기본 구조를 고정하고, `variant`, `size`, `customStyle` 같은 props로 확장성 제공
- 컴포넌트 구조를 바꾸지 않고, props만으로 다양한 UI/동작 지원 → 수정 없이 확장 가능

## 3. Render Props 패턴

```jsx
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return <ul>{items.map(renderItem)}</ul>;
}

// 사용 예시
<List
  items={['사과', '바나나']}
  renderItem={(item) => <li key={item}>{item}</li>}
/>;
```

- 동작/렌더링을 함수(props)로 외부에서 주입 → 내부는 추상 인터페이스에 의존
- 컴포넌트 내부는 “어떻게 렌더링될지”를 모름 → 런타임 시점에 주입된 함수에 따라 동작
- 새로운 렌더링 방식이 필요해도 컴포넌트 자체 수정 불필요

<br />

# 의존성 주입

- 의존성 주입이란 필요한 의존성을 외부에서 주입받는 것이다.
- 리액트 관점에서 다른 props가 아닌 handler 를 주입하는 것을 의존성 주입중 하나라고 생각한다.
- 의존성 주입은 handler뿐 아니라 state, 값, 서비스 등 다 포함된다.
- 그런데 **handler를 넘기면 내부적으로 필요한 state들이 캡슐화**돼서, 컴포넌트 입장에서는 의존성이 줄어든다.

즉, state를 다 따로따로 props로 넘기지 않고 handler 하나로 묶으면 확장에 더 유연해진다.

## 사례

- 원래는 CertificateSection 내부에서 삭제/추가/이미지 변경 핸들러를 처리
- 하지만 삭제 버튼에 `삭제할 자격증 id를 담는 상태값을 갱신`하는 로직을 추가하려다 보니, 이후에도 새로운 요구사항이 생길 때마다 CertificateSection에 props가 계속 늘어날 우려 존재

- 수정 전

```jsx
<CertificateSection
  onCertificateChange={handleMentoringDataChange}
  handleCertificateImageFilesChange={handleCertificateImageFilesChange}
/>
```

CertificateSection 컴포넌트

```jsx
 const [certificates, setCertificates] =
    useState<CertificateItem[]>(initialCertificates);

  const handleAddButtonClick = () => {
    ...
  };

  const handleDeleteButtonClick = (id: string) => {
    ...
  };

  const handleCertificateChangeById = (
    id: string,
    changed: Partial<CertificateItem>,
  ) => {
    ...
  };
```

- 수정 후

자격증 관련 상태(certificates)와 핸들러 로직을 상위 컴포넌트인 MentoringCreateForm으로 이동

```jsx
  const [certificates, setCertificates] = useState<CertificateItem[]>([]);

  const onAddButtonClick = () => {
    ...
  };

  const onDeleteButtonClick = (id: string) => {
    ...
  };

  const onCertificateChangeById = (
    id: string,
    changed: Partial<CertificateItem>,
  ) => {
    ...
  };

  ...
<CertificateSection
  certificates={certificates}
  onAddButtonClick={onAddButtonClick}
  onCertificateChangeById={onCertificateChangeById}
  onDeleteButtonClick={onDeleteButtonClick}
/>
```
