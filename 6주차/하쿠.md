## 9장에서의 핵심 1문장
- 결합도를 낮추고 유연성을 확보해라.

## 프론트엔드(함수형) 관점으로 9장 내용 생각해보기
9장에 나오는 유연한 설계를 위한 원칙들은 대부분 클래스 기반의 OOP 관점이라 프론트엔드 개발에 그대로 대입하면 맥락상 어색한 부분이 많다고 느껴집니다.</br>
따라서 이 원칙들의 핵심 목표를 뽑아서 생각해보기로 했습니다. 앞서 핵심 1문장으로 정리하기도 했지만 결합도를 낮추고 유연성을 확보하는 것이 9장에 나오는 원칙들의 핵심 목표라 생각됩니다.</br>
중요한 것은 문자 그대로 따르는게 아니라 이 안에 깊은 의도를 파악하고 재해석하는 것이라 생각합니다.</br>
결국 핵심은 '구체적인 구현이 아니라 추상적인 인터페이스에 의존'하도록 설계의 방향을 잡아야하는 것입니다.

핵심을 토대로 프론트엔드 관점으로 대입하기 어렵다고 느껴졌던 3가지 원칙들을 정리해보겠습니다.
1. 생성 사용 분리 - 컴포넌트 역할에만 충실
   - OOP에서의 의미: new 키워드를 통해 클래스를 직접 생성하는 로직과, 이를 통해 생성된 객체를 사용하는 로직 분리
   - 프론트엔드에서의 의미: 컴포넌트가 자신의 의존성(API 클라이언트, 유틸리티 함수)을 직접 만들고 설정하지 않게 하는 것

컴포넌트의 주된 책임은 UI를 렌더링하고 사용자 인터렉션을 처리하는 것이라 생각이 드는데 부수적인 책임을 컴포넌트가 직접 떠안으면 재사용성과 테스트가 어렵습니다.

2. 의존성 주입 - 필요한 것은 외부에서
   - OOP에서의 의미: 생성자나, setter를 통해 외부에서 의존성 전달
   - 프론트엔드에서의 의미: 필요한 의존성을 외부에서 props나 context API를 통해 전달
   
컴포넌트가 필요로 하는 기능을 외부에서 주입해주면, 컴포넌트는 어떻게 동작하는지 몰라도 **무엇을** 해야하는지에만 집중할 수 있습니다.
  
3. 의존성 역전 원칙 - 구체적인 구현이 아니라 약속에 의존
   - OOP에서의 의미: 추상 클래스나 인터페이스에 의존
   - 프론트엔드에서의 의미: 컴포넌트가 훅이나 다른 컴포넌트 내부 구현에 의존하지 말고 props 인터페이스나 hook 반환값 구조에 의존
  
여기서 약속이란 props 인터페이스를 통해 특정 형태의 props를 받거나 hook의 인터페이스를 통해 특정 형태의 값을 반환하기로 하는 것처럼 주입할 의존성의 형태를 정하는 것을 말합니다.

정리하자면 프론트엔드에서 api 클라이언트, 전역 상태는 컴포넌트 외부에서 만들고 이렇게 외부에서 만든 의존성은 props나 context를 통해 컴포넌트에 전달해야 합니다. 이렇게 각 컴포넌트는 구체적인 구현이 아니라 약속에만 의존하여 결합도가 낮고 유연성을 확보한 프론트엔드 아키텍쳐를 만들 수 있습니다.
