## 9장 유연한 설계

### 개방 폐쇄 원칙 OCP 
이 개념을 한 문장으로 설명하면 "기존 코드를 수정하지 않고 동작 추가나 변경이 가능해야 한다."라는 말이다. 처음 봤을 때는 이 말이 무엇을 말하는지 의문이 들었다. 코드를 수정하지 않고 동작을 추가하고 변경할 수 없는거 아닌가? 

책에서는 여기서 말하는 "코드를 수정하지 않는다"는 것이 단순히 소스 코드 자체를 전혀 건드리지 않는다는 뜻이 아니라, 컴파일 타임 의존성을 추상(인터페이스)에 두고, 런타임에는 실제 구현체(구체 클래스)에 의존하도록 설계하라는 의미라고 설명한다.

그럼 이런 OCP의 개념을 리액트에서도 찾아볼 수 있었다. 

먼저 props를 interface로 정의하고 외부에서 주입할 때

```tsx
interface ButtonProps = {
  label: string;
  onClick: () => void;
};

export const Button = ({ label, onClick }: ButtonProps) => {
  return <button onClick={onClick}>{label}</button>;
};
```

우리는 이렇게 사용하는데 이 때 컴파일 타임에 이 버튼 컴포넌트의 props는 추상화된 interface에 의존한다.

```tsx
<Button label="저장" onClick={() => saveS()} />
<Button label="삭제" onClick={() => deleteS()} />
```
그리고 실제 런타임에 해당 props로 전달된 구체 함수에 의존한다.

이렇게 Button 컴포넌트를 변경하지 않고도 다른 동작을 수행할 수 있다. 컴파일 타임 의존성을 수정하지 않으면서 런타임 의존성을 변경할 수 있는 OCP의 개념을 알 수 있었다. 와

---
또 책에서는 OCP를 지키기 위해서 추상화에 의존하는 것이 핵심이라고 말하고 있다. 

OCP 관점에서 공통적인 부분, 추상화된 부분은 수정할 필요가 없어야 한다고 말한다.

추상화는 기능의 확장을 가능하게 하고, 추상화에 대한 의존은 폐쇄를 가능하게 한다고 한다.

이 개념에서 커스텀 훅이 생각났다. 내 코드에 있는 커스텀 훅을 한번 보겠다.

```tsx
const useMapView = () => {
  const [viewMode, setViewMode] = useState<'map' | 'list'>('map');

  const handleViewModeChange = () => {
    if (viewMode === 'map') {
      setViewMode('list');
    } else {
      setViewMode('map');
    }
  };

  return { viewMode, handleViewModeChange };
};

export default useMapView;
```

이 커스텀 훅을 2가지 부분으로 나눠서 설명해보면

**1. 컴파일 타임 의존성**
```ts
return { viewMode, handleViewModeChange };
```
이 부분을 보면 이걸 사용하는 컴포넌트는 `useMapView`가 뭘 반환하는지만 알고 있으면 된다. 즉 컴파일 타임에는 "viewMode는 string 리터럴 union 타입이고, handleViewModeChange는 함수다" 라는 계약만 의존하고 있다.

**2. 런타임 의존성**
그래서 내부 구현은 바깥에서 모르고 실제로 어떤 값을 사용할지, 상태가 어떻게 바뀔지는 런타임에서 결정된다. 그렇지만 외부 입장에서는 반환되는 값의 계약만 유지되면 문제가 없다.

**OCP 관점에서 본 커스텀 훅**
OCP의 핵심은 "확장에는 열려 있고, 수정에는 닫혀 있어야 한다"는 것이다. useMapView 훅을 보면 새로운 viewMode를 지원하고 싶다면 내부 구현만 변경하면 된다. 이 훅을 사용하는 컴포넌트는 반환 타입(추상화)에만 의존하므로 수정할 필요가 없다.

결국 중요한 건 변하는 부분과 변하지 않는 부분을 잘 구분해 추상화하는 것이다. 만약 변하는 부분을 추상화에 포함시켜 버리면, 내부 구현이 바뀔 때마다 외부 코드도 함께 수정해야 한다. 책에서 추상화가 개방-폐쇄 원칙을 가능하게 만드는 이유라는 것을 이해하게 되었다.

---
### 생성 사용 분리
**순수한 가공물에 책임 할당하기**

시스템을 객체로 분해하는데 두가지 방식이 존재한다고 한다. 

표면적 분해, 행위적 분해

표면적 분해: 도메인 모델에 있는 개념과 관계를 따름 → 객체지향 설계를 위한 가장 기본적인 접근법

근데 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 있는데 이떄는 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결해야 한다.

이런 책임을 할당하기 위해서 만들어지는 도메인과 무관한 인공적인 객체를 순수한 가공물이라고 부른다고 한다.

이렇게 추가된 pure fabrication은 특정한 행동을 표현하는게 일반적이여서 행위적 분해에 의해 생성되는 것이 일반적이라고 한다.

프론트 관점에서 보면, 순수한 가공물은 common/hooks이나 common/components 같은 폴더에서 흔히 볼 수 있다. 예를 들어 useAsyncLock 훅은 현실 세계에는 없는 개념이지만, 버튼 중복 클릭을 막기 위해 내가 만든 순수 가공물이다. 만약 이 책임을 도메인 훅에 그대로 넣었다면 로직이 불필요하게 복잡해졌을 것이다. 하지만 별도의 훅으로 분리하면서 도메인 로직은 본질적인 책임(비즈니스 규칙)에만 집중할 수 있게 되었다.

또 모달 컴포넌트를 컴파운드 패턴으로 만든 경험도 있다. 모달은 현실 세계에는 존재하지 않는 UI 개념이지만, 순수한 가공물로 만들어냈다. 이 덕분에 코드의 재사용성과 일관성이 크게 높아졌다.

결국 프론트엔드 개발에서도 순수 가공물은 필요할 수밖에 없고 이것이 실세계 모방과는 거리가 정말 멀지만, 설계 품질이나 유연성을 지키는데 핵심 장치이다.

### 의존성 역전 원칙 DIP
의존성 역전 원칙은 두가지로 설명할 수 있다.
1. 상위 수준 모듈은 하위 수준 모듈에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존하면 안된다. 구체적인 사항은 추상화에 의존해야 한다. 

이 부분에서는 아래와 같은 코드가 생각났다.

```tsx
const MOVING_STRATEGY_STORAGE_KEY = 'movingStrategy';

export const useMovingStrategy = () => {
  const [movingStrategy, setMovingStrategy] = useSessionStorage<MovingStrategyType>(
    MOVING_STRATEGY_STORAGE_KEY,
    'DRIVING',
  );

  return {
    movingStrategy,
    setMovingStrategy,
  };
};
```

원래는 `useSessionStorage` 같은 추상화 훅을 쓰지 않고, 직접 `sessionStorage`를 다루고 있었다.

```tsx
const [movingStrategy, setMovingStrategy] = useState(() => {
  const saved = sessionStorage.getItem(MOVING_STRATEGY_STORAGE_KEY);
});
```

이렇게 되면 useMovingStrategy라는 고수준 훅이 곧바로 sessionStorage(저수준 구현)에 의존하게 된다. 그래서 localStorage나 다른 로직으로 바꾸려면 훅 내부를 수정해야 한다. 

그래서 앞의 첫번째 코드처럼 `useSessionStorage`라는 추상화에 의존하면 스토리지의 구현을 몰라도 된다.
`useMovingStrategy`는 "스토리지에 값을 저장하고 불러올 수 있다"는 추상화에만 의존한다. 실제로 어떤 저장소를 쓸지는 `useSessionStorage` 내부에서 결정되므로, 스토리지 구현이 바뀌더라도 `useMovingStrategy`는 수정할 필요가 없다.

따라서
- 원래는 고수준(useMovingStrategy) → 저수준(sessionStorage) 직접 의존 → DIP를 위반.
- 리팩터링 후에는 고수준(useMovingStrategy) → 추상 (useSessionStorage) 의존. → 구체(sessionStorage)는 추상 안에서 감춰짐.

결과적으로 스토리지 구현을 교체하더라도 고수준 로직은 영향 없어서 → DIP 충족.

여기서 추상화의 이름을 `useSessionStorage`보다는 `useBrowserStorage`나 `useStorage`처럼 더 포괄적으로 짓는다면 특정 구현에 종속되지 않고 스토리지라는 더 일반적인 개념을 드러낼 수 있어서 의존성을 역전시킨 효과가 더욱 뚜렷해질 것 같다.

이렇게 DIP라는 객체지향의 개념이 리액트 코드에서도 변경에 유연하게 대응하도록 도와주는 것을 알 수 있었다.

## 결론
이렇게 9장에 추상화라는 개념을 다시 볼 수 있었고 OCP, DIP의 개념도 알 수 있었다. 이런 개념이 객체지향적인 언어에만 국한되지 않고 프론트엔드 코드에도 잘 적용하면 변경에 유연한 코드를 만들 수 있다는 것도 체감할 수 있었다. 

그리고 결국 가장 중요한 것은 변경되는 부분과 변경되지 말아야 할 부분을 잘 구분하는 것이다. 이 구분이 제대로 되어야만 원칙들이 효과적으로 작동한다. 그래서 변경되는 부분과 변경되지 않는 부분을 식별하는 연습을 자주 하는게 좋을 것 같다.

또 9장의 마지막 소제목인 "유연한 설계는 유연성이 필요할 때만 옳다" 부분의 내용을 봤을 때 불필요한 추상화를 도입하는 것은 오히려 불필요한 수고를 만든다는 것도 알게 되었다. 결국 구현 자체가 중요한 것이 아니라 역할, 책임, 협력에 먼저 집중해서 어디를 재사용 해야하고 어디에 확장이 필요한지 판단하는 것이 우선이다.