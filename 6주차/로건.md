# 9장 유연한 설계

## 1.1 개방-폐쇄 원칙 (OCP)

**개방-폐쇄 원칙**(Open-Closed Principle, OCP): "소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다"

이는 새로운 기능을 추가할 때 **기존의 안정적인 코드를 변경하는 것이 아니라, 새로운 코드를 추가**함으로써 시스템의 동작을 확장할 수 있어야 함을 의미합니다.

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

이는 결국 추상화에 의존하라는 얘기입니다.

#### 추상화가 핵심이다

OCP의 핵심은 **추상화에 의존하는 것**입니다.
여기서 '수정에 대해 닫혀 있는' 부분은 안정적인 추상화를 의미하며, '확장에 대해 열려 있는' 부분은 해당 추상화에 부합하는 새로운 구체적인 구현을 추가할 수 있는 능력을 의미합니다. 즉, **변하지 않는 핵심적인 부분과 변하는 부분을 분리**하고, **시스템이 변하지 않는 핵심(추상화)에 의존하도록 만드는 것**이 OCP의 핵심입니다.

#### 변화의 축 식별하기

그렇다면 어떻게 OCP를 적용시킬 수 있을까 고민해봤습니다.

이 원칙을 실질적으로 적용하기 위한 첫 단계는 **무엇이 변하고 무엇이 변하지 않는지를 식별하는 것**입니다. 예를 들어, 영화 예매 시스템에서 할인 정책을 생각해보겠습니다. '영화가 할인을 계산해야 한다'는 사실은 안정적이고 변하지 않는 부분입니다. 반면, 할인 방식(금액 할인, 비율 할인, 중복 할인 등)은 앞으로 계속 추가되거나 변경될 수 있는 가변적인 부분입니다.

이 개념을 다른 프론트엔드 예시에 적용해봤습니다.

안정적인 부분: UserProfileCard 컴포넌트는 사용자의 소셜 미디어 링크 목록을 화면에 표시해야 합니다.

가변적인 부분: 앞으로 지원해야 할 소셜 미디어 플랫폼(예: Twitter, LinkedIn, GitHub, 그리고 미래에 등장할 새로운 플랫폼)의 종류입니다.

OCP를 위반하는 설계는 새로운 소셜 미디어 링크를 추가할 때마다 UserProfileCard 컴포넌트의 내부 코드를 직접 수정해야 합니다. 반면, OCP를 준수하는 설계는 UserProfileCard 컴포넌트 자체는 전혀 건드리지 않고 새로운 플랫폼 링크 컴포넌트를 추가하여 주입하는 방식으로 기능을 확장할 수 있습니다.

변화의 축을 식별한다는 점은 알겠습니다. 실제 제 코드를 보고 OCP를 적용해보겠습니다.

예시: 쿠폰 카드 컴포넌트

**Bad Case: switch 문을 통한 OCP 위반**
CouponCard 내부에 switch 문을 사용하여 쿠폰 타입별로 다른 상세 정보 컴포넌트를 렌더링합니다. 새로운 쿠폰 타입이 추가될 때마다 이 switch 문을 수정해야 하므로, CouponCard는 '수정에 닫혀'있지 않습니다.

```tsx
// CouponCard.tsx
function SpecificCouponCard({ coupon }: { coupon: Coupon }) {
  // 새로운 쿠폰 타입이 추가되면 이 코드를 '수정'해야 한다. (OCP 위반)
  switch (coupon.discountType) {
    case CouponType.FIXED:
      return <FixedDiscountCoupon coupon={coupon} />;
    case CouponType.PERCENTAGE:
      return <PercentageDiscountCoupon coupon={coupon} />;
    default:
      return null;
  }
}

function CouponCard({ children,... }: CouponCardProps) {
  return (
    <Styled.Container>
      <CommonCoupon {...} />
      <SpecificCouponCard coupon={coupon}/>
    </Styled.Container>
  );
}
```

**Good Case: 합성을 통한 OCP 준수**
CouponCard는 children prop을 통해 렌더링할 내용을 외부에서 주입받습니다. 렌더링 결정의 책임을 상위 컴포넌트로 옮깁니다.

```tsx
// CouponCard.tsx
// 이 컴포넌트는 이제 내용물에 대해 아무것도 모른다. (수정에 닫힘)
function CouponCard({ children,... }: CouponCardProps) {
  return (
    <Styled.Container>
      <CommonCoupon {...} />
      {children} {/* 외부에서 주입된 내용 */}
    </Styled.Container>
  );
}

// ApplyCoupon.tsx (상위 컴포넌트)
// 쿠폰 타입과 컴포넌트를 매핑하는 객체 (전략 패턴)
// 새로운 쿠폰 타입이 추가되어도 CouponCard는 수정할 필요 없이,
// 이 맵에 새로운 항목만 '추가'하면 된다. (확장에 열림)
const couponComponentMap = {
 FIXED: (coupon) => <FixedDiscountCoupon coupon={coupon}/>,
 PERCENTAGE: (coupon) => <PercentageDiscountCoupon coupon={coupon}/>,
};

coupons.map((coupon) => {
  const SpecificCoupon = couponComponentMap[coupon.type];
  return (
    <CouponCard {...}>
      <SpecificCoupon />
    </CouponCard>
  );
});
```

하위 컴포넌트의 switch case문이 상위 컴포넌트의 couponComponentMap으로 변경되었습니다.
여기서 한가지 의문점이 들었습니다.
결국 switch case의 형태와 위치가 바뀌었을 뿐 달라진 게 없으므로, "아직도 OCP를 위반하고 있는 게 아닐까?", "어디선가 반드시 수정이 필요할텐데 그렇다면 OCP는 영원히 지켜질 수 없는 것 아닌가?" 란 생각이 들었습니다.

AI와 대화하면서 제 의문을 해결해봤습니다. 결론만 말하자면 **변화의 가능성이 큰 로직은 변화의 가능성이 큰 컴포넌트에 두는 것**입니다.

조건 분기 로직 자체가 사라진 것이 아니라, 책임의 위치가 이동한 것입니다. 이것이 더 좋은 구조인 이유는 변경의 영향 범위와 위험 관리 관점에서 설명할 수 있습니다.

1. 책임과 안정성의 분리 (Separation of Responsibility & Stability)

CouponCard (하위 컴포넌트): 이 컴포넌트의 핵심 책임은 '쿠폰의 공통적인 껍데기를 렌더링하는 것'입니다. 이 책임은 매우 **안정적(Stable)**이며, 비즈니스 로직이 변해도 거의 바뀔 일이 없습니다. 이런 안정적인 저수준(low-level) 모듈은 한번 만들어두면 수정 없이 계속 재사용하는 것이 이상적입니다.

ApplyCoupon (상위 컴포넌트): 이 컴포넌트의 책임은 '쿠폰을 적용하는 비즈니스 정책을 구현하는 것'입니다. "어떤 종류의 쿠폰들이 있고, 각 쿠폰은 어떻게 생겼는가"라는 정책은 비즈니스 요구사항에 따라 **변동성(Volatile)**이 매우 높습니다.

리팩터링을 통해 우리는 **변동성이 높은 로직**(couponComponentMap)을 **변동성이 높은 컴포넌트**(ApplyCoupon)로 이동시켰고, 안정적인 컴포넌트(CouponCard)는 더 안정적으로 만들었습니다. 이것이 좋은 설계의 핵심입니다. 변경이 발생할 때, 우리는 안정적인 벽돌(CouponCard)을 부수는 대신, 그 벽돌을 사용하는 설계도(ApplyCoupon)만 수정하면 됩니다.

2. 개방-폐쇄 원칙(OCP)의 진정한 의미
   OCP의 목표는 코드 수정을 완전히 없애는 것이 아니라, '안정적인 핵심부'는 수정하지 않고 '확장 가능한 주변부'만 수정하여 시스템 전체의 안정성을 높이는 것입니다.

이전 구조: 새로운 쿠폰 타입 추가 시, 안정적이어야 할 CouponCard를 수정해야 했습니다. (폐쇄 원칙 위반)

개선된 구조: 새로운 쿠폰 타입 추가 시, 안정적인 CouponCard는 그대로 두고, ApplyCoupon의 couponComponentMap에 한 줄을 추가하고, 새로운 NewCouponTypeCard.tsx 파일을 추가하기만 하면 됩니다. 이것이 바로 '수정에는 닫혀 있고, 확장에는 열려 있는' 구조의 전형입니다.

3. 결합도 감소와 명시성 증가

결합도: 이전 CouponCard는 모든 SpecificCoupon... 컴포넌트의 존재를 알아야 했습니다. 즉, 강하게 결합되어 있었습니다. 개선된 CouponCard는 이제 그 어떤 특정 쿠폰 컴포넌트와도 결합되어 있지 않습니다. 완전히 독립적이고 재사용성이 극대화되었습니다.

명시성: couponComponentMap은 "어떤 쿠폰 타입이 어떤 UI에 대응되는가"라는 비즈니스 규칙을 한눈에 파악할 수 있는 명시적인 설정(Configuration) 역할을 합니다. switch 문처럼 로직 흐름 속에 숨어있는 것보다 훨씬 파악하기 쉽습니다.

결론적으로, 로직을 상위 컴포넌트로 옮기는 것은 단순히 코드의 위치를 바꾸는 행위가 아닙니다. 그것은 컴포넌트의 책임을 명확히 분리하고, 변경이 예상되는 부분을 격리하여, 미래의 요구사항 변경에 더 적은 비용과 위험으로 대응할 수 있도록 시스템의 구조적 안정성을 높이는 매우 중요한 아키텍처 결정입니다.

## 1.2 생성 사용 분리

객체를 '생성'하는 책임과 '사용'하는 책임을 명확히 분리해야 합니다. React에서는 이 원칙이 컨테이너-프레젠테이션 패턴으로 잘 나타납니다. 데이터 페칭이나 상태 관리 로직(데이터 '생성')을 담당하는 컨테이너 컴포넌트와, 데이터를 받아 단순히 UI를 그리는(데이터 '사용') 프레젠테이션 컴포넌트를 분리하는 것입니다.

내부에서 직접 생성한다면 결합도가 매우 높아져 재사용성이 떨어집니다. 외부에서 생성 후 주입 시 결합도가 매우 낮아지며 재사용성이 높아집니다.

예시: 강아지 이미지 뷰어

**Bad Case: 하나의 컴포넌트에 생성과 사용이 혼재**
DogImageViewer 컴포넌트가 API 호출 로직(useEffect)과 UI 렌더링 로직을 모두 가지고 있습니다. 데이터 '생성'(API 호출)과 '사용'(이미지 표시)의 책임이 한곳에 섞여 있어 재사용과 테스트가 어렵습니다.

```tsx
// DogImageViewer.bad.tsx
import React, { useState, useEffect } from "react"

function DogImageViewer() {
  const [imageUrl, setImageUrl] = useState("")
  const [isLoading, setIsLoading] = useState(true)

  // 데이터 '생성' 로직 (API 호출)
  useEffect(() => {
    fetch("https://dog.ceo/api/breeds/image/random")
      .then((res) => res.json())
      .then((data) => {
        setImageUrl(data.message)
        setIsLoading(false)
      })
  })

  // 데이터 '사용' 로직 (UI 렌더링)
  if (isLoading) {
    return <div>Loading...</div>
  }
  return (
    <img
      src={imageUrl}
      alt="A cute dog"
    />
  )
}
```

**Good Case: 컨테이너와 프레젠테이션 컴포넌트로 분리**
로직과 뷰를 두 개의 컴포넌트로 분리합니다. DogImageContainer는 데이터 '생성'을, DogImagePresenter는 데이터 '사용'을 책임집니다.

```tsx
// DogImagePresenter.tsx (데이터 '사용' - 프레젠테이션)
// 이 컴포넌트는 데이터가 어떻게 오는지 전혀 모른다. 오직 props를 받아 UI를 그릴 뿐이다.
function DogImagePresenter({ isLoading, imageUrl }) {
  if (isLoading) {
    return <div>Loading...</div>
  }
  return (
    <img
      src={imageUrl}
      alt="A cute dog"
    />
  )
}

// DogImageContainer.tsx (데이터 '생성' - 컨테이너)
import React, { useState, useEffect } from "react"

function DogImageContainer() {
  const [imageUrl, setImageUrl] = useState("")
  const [isLoading, setIsLoading] = useState(true)

  // 데이터 '생성' 책임은 컨테이너가 진다.
  useEffect(() => {
    fetch("https://dog.ceo/api/breeds/image/random")
      .then((res) => res.json())
      .then((data) => {
        setImageUrl(data.message)
        setIsLoading(false)
      })
  })

  // 생성한 데이터를 프레젠테이션 컴포넌트에 전달하여 '사용'하게 한다.
  return (
    <DogImagePresenter
      isLoading={isLoading}
      imageUrl={imageUrl}
    />
  )
}
```

## 1.3 의존성 주입

의존성 주입 (DI)
의존성 주입은 이러한 분리를 달성하기 위한 구체적인 기술입니다. DI는 컴포넌트가 필요로 하는 의존성을 내부에서 직접 생성하는 대신, 외부의 소스로부터 제공(주입)받는 패턴을 의미합니다. 이 외부 소스가 의존성을 '주입'해주는 것입니다. 이를 통해 컴포넌트는 자신이 사용하는 서비스의 구체적인 구현을 알 필요가 없어지며, 오직 추상 인터페이스에만 의존하게 됩니다. 이렇게 DI를 사용한다면 컴포넌트의 재사용성과 테스트 용이성을 향상시킨다는 장점이 있습니다.

매우 간단한 예시: 로또 번호 뽑기

```tsx
// bad case
const getRandomNumber = () => {
  return Math.ceil(Math.random() * (45 - 1) + 1)
}

// good case
const getRandomNumber = (min, max) => {
  return Math.ceil(Math.random() * (max - min) + min)
}
```

이렇게 인자로 전달하는 것도 DI입니다. 인자로 전달하는 경우 추상화된 인터페이스를 통해 전달할 수 있도록 하는 것이 중요한 것 같습니다.

## 1.4 의존성 역전 원칙 (DIP)

의존성 역전 원칙(Dependency Inversion Principle, DIP)은 유연한 설계를 위한 또 다른 핵심이며, 두 가지 주요 내용으로 구성됩니다.

- 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
- 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

'역전'의 의미
'역전(Inversion)'이라는 단어는 전통적인 소프트웨어 설계의 의존성 흐름을 뒤집는다는 의미를 담고 있습니다. 전통적인 방식에서는 상위 수준의 정책을 결정하는 모듈이 하위 수준의 세부 구현을 담당하는 모듈을 직접 참조합니다.
DIP는 이러한 의존성의 방향을 역전시킵니다.

사실 이것만 봐서는 무슨 말인지 이해가 잘 안갔습니다.
버스 운전기사와 승객이라는 비유적인 표현으로 좀 더 이해하기 쉽게 풀어봤습니다.

예시: 버스 운전기사와 승객

**Bad Case: 운전기사가 특정 승객에게 직접 의존**
운전기사(상위 수준 모듈)가 학생 승객(하위 수준 모듈)의 존재를 직접 알고, 학생일 경우에만 버스를 세웁니다. 만약 '관광객'이라는 새로운 승객 타입이 추가되면 운전기사의 코드를 수정해야 합니다.

```tsx
class Student {
  // 하위 수준 모듈 (구체적인 구현)
  /* 학생 관련 로직 */
}

class BusDriver {
  // 상위 수준 모듈 (정책)
  passenger = new Student() // <-- 특정 승객(Student)을 직접 생성하고 의존

  drive() {
    // 학생인지 직접 확인해야 한다.
    if (this.passenger instanceof Student) {
      // 버스를 세운다.
    }
  }
}
```

**Good Case: 운전기사와 승객 모두 '하차 벨'이라는 약속에 의존**
운전기사는 승객이 누구인지 전혀 신경 쓰지 않습니다. 오직 '하차 벨을 누를 수 있다'는 약속(인터페이스)에만 의존합니다. 학생과 관광객은 모두 이 약속을 지키기만 하면 됩니다.

```tsx
// '하차 벨을 누를 수 있다'는 약속 (추상화)
interface StoppablePassenger {
  requestStop(): void
}

// 학생은 약속을 지킨다.
class Student implements StoppablePassenger {
  requestStop() {
    /* 벨을 누른다 */
  }
}

// 관광객도 약속을 지킨다.
class Tourist implements StoppablePassenger {
  requestStop() {
    /* 벨을 누른다 */
  }
}

class BusDriver {
  // 상위 수준 모듈
  passenger: StoppablePassenger

  // 생성자를 통해 약속을 지키는 어떤 승객이든 받을 수 있다.
  constructor(passenger: StoppablePassenger) {
    this.passenger = passenger
  }

  drive() {
    // 승객이 누구든 상관없이, 그저 약속된 행동을 호출한다.
    this.passenger.requestStop()
  }
}

// 사용하는 곳
const student = new Student()
const driverForStudent = new BusDriver(student) // 학생을 태운 버스

const tourist = new Tourist()
const driverForTourist = new BusDriver(tourist) // 관광객을 태운 버스
```

이외에도 현재 우리가 자주 사용하는 커스텀 훅 패턴도 DIP의 한 예시인 것 같습니다.
커스텀 훅에서 반환하는 값에 대해 일정한 인터페이스를 통해 협력하고 있기 때문입니다.
예를 들어 user에 대한 정보를 가져오는 데이터 페칭 훅이 커스텀 훅 내부에 있다면, 우리는 user라는 데이터를 가져오기로 약속했으므로 데이터 페칭 훅이 fetch에서 axios로 바뀐다 하더라도 user 데이터를 사용하는 쪽은 인터페이스가 변경된 게 없으므로 커스텀 훅의 내부 구현에 의존하지 않습니다.

예를 들어 useUserData라는 커스텀 훅이 있다고 가정해 보겠습니다. 이 훅을 사용하는 컴포넌트는 `const { user, isLoading } = useUserData();` 처럼 훅이 반환하는 값의 형태(인터페이스)에만 의존합니다. useUserData 훅의 내부 구현이 fetch에서 axios로 바뀌거나, SWR로 변경되더라도, 반환하는 **'약속'**만 동일하다면 이 훅을 사용하는 컴포넌트는 코드를 단 한 줄도 수정할 필요가 없습니다.

### 인터페이스의 소유권

DIP에서 종종 간과되지만 매우 중요한 점은, 추상 인터페이스의 소유권이 클라이언트, 즉 상위 수준 모듈에 있다는 것입니다.

UserProfilePage 컴포넌트(상위 수준)는 자신이 '필요로 하는' 데이터 페처의 명세, 즉 IUserDataFetcher 인터페이스를 직접 정의합니다. 그리고 AxiosUserDataFetcher 모듈(하위 수준)은 이 인터페이스를 '구현'합니다. 이 구조는 상위 수준 모듈이 자신의 필요와 무관한 하위 수준 모듈의 변경으로부터 완벽하게 보호되도록 보장합니다.

### OCP, DIP, DI 그리고 추상화

이 세 가지 원칙—OCP, DIP, DI—는 개별적으로 존재하는 것이 아니라, 변화를 효과적으로 관리하기 위한 통합된 시스템으로 작동하는 것 같습니다. OCP는 '확장 가능하고 수정에는 닫힌' 시스템이라는 목표를 설정합니다. DIP는 이 목표를 달성하기 위해 '추상화에 의존하라'는 상위 수준의 전략을 제공합니다. 그리고 DI는 이 전략을 구현하기 위해 '외부에서 의존성을 전달하라'는 구체적인 방법을 제시합니다.

## 1.5 유연성에 대한 조언

원칙을 아는 것과 그 원칙을 언제, 어떻게, 그리고 왜 적용해야 하는지를 아는 것은 별개의 문제입니다. 이 마지막 파트에서는 유연한 설계를 도입할 때 고려해야 할 전략적 측면과 현실적인 트레이드오프에 대해 논의합니다.

### 유연성의 진정한 비용

유연한 설계는 공짜로 얻어지지 않습니다. 유연성은 본질적으로 복잡성을 수반합니다. 추상화 계층을 추가하고 의존성을 주입하는 구조는 코드를 직접적으로 작성하는 것보다 더 많은 파일을 생성하고, 개발자가 런타임 시점의 객체 구조를 파악하기 위해 더 복잡한 정신 모델을 유지하도록 요구합니다. 절차적 프로그래밍에서는 코드의 구조가 곧 실행 구조이지만, 유연한 객체지향 설계에서는 이 둘 사이의 간격이 벌어집니다.

### 섣부른 추상화의 위험

가장 경계해야 할 것은 '섣부른 추상화'입니다. 결코 일어나지 않을 미래의 변경을 대비하여 설계를 복잡하게 만드는 것은 순수한 손실입니다. 복잡성이라는 비용은 지불했지만, 유연성이라는 이득은 전혀 얻지 못했기 때문입니다. 변경은 막연한 불안감이 아니라 구체적인 현실이어야 합니다. 아직 일어나지 않은 변경은 변경이 아닙니다.

이러한 설계 원칙들을 무분별하게 모든 곳에 적용하려는 시도는 오버 엔지니어링으로 이어지기 쉽습니다. 아키텍처 결정의 핵심은 비용과 이익의 균형을 맞추는 것입니다. 그렇다면 언제 이 비용을 지불할 가치가 있을까요? 그 답은 '변화의 비용 곡선'에서 찾을 수 있습니다. 강하게 결합된 시스템에서 변경을 가하는 비용은 시간이 지남에 따라 기하급수적으로 증가하는 경향이 있습니다. 반면, 느슨하게 결합된 추상화된 시스템의 변경 비용은 완만하게 증가합니다. 초기에 단순하고 결합된 솔루션은 구축 비용이 저렴하지만, 몇 번의 변경 주기 후에 각 수정 비용은 파급 효과와 회귀 테스트의 부담으로 인해 급증합니다. 추상화된 솔루션은 초기 비용이 더 높지만, 이후의 각 기능 확장은 최소한의 비용으로 이루어집니다. 따라서 이러한 설계 원칙에 대한 투자는 '코드를 예쁘게 만드는 것'이 아니라, 프로젝트의 전체 생명주기에 걸친 총 소유 비용(TCO)을 관리하는 결정입니다.

## 프론트엔드에서 어떻게 적용할 수 있을까?

### 단순함에서 시작하라

모든 설계의 기본값은 항상 가장 단순하고 직접적인 해결책이어야 합니다. '세 번의 법칙'은 좋은 경험적 규칙입니다. 어떤 로직이나 컴포넌트 패턴에 대해 세 가지의 구체적인 사용 사례가 발생하기 전까지는 추상화하지 마십시오. 이 접근법은 과도한 설계를 방지하고, 패턴이 자연스럽게 드러나도록 유도합니다.

### 경계면에 집중하라

모든 것을 추상화하는 대신, 애플리케이션의 자연스러운 '경계면(seams)'에 집중하는 것이 훨씬 효과적입니다. 이곳들이야말로 DIP와 DI를 적용했을 때 가장 큰 가치를 얻을 수 있는 지점들입니다.

- UI와 비즈니스 로직의 경계: 상태 관리와 비즈니스 로직을 커스텀 훅으로 분리하여 UI 컴포넌트가 순수하게 렌더링에만 집중하도록 만듭니다.

- 애플리케이션과 외부 서비스의 경계: 모든 데이터 페칭(API), 분석, 인증 등 외부 세계와의 통신을 추상화된 서비스 계층 뒤로 숨깁니다.

- 애플리케이션과 브라우저 API의 경계: localStorage, fetch, WebSocket과 같은 브라우저 API를 직접 사용하는 대신, 이를 감싸는 서비스 래퍼(wrapper)를 만듭니다. 이는 핵심 애플리케이션 로직을 플랫폼에 비종속적으로 만들고 테스트를 극적으로 단순화합니다.
