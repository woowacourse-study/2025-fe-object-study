## 리액트 컴포넌트를 객체지향적으로 본다면?

저번 주 토요일, 오랜만에 동아리 친구들을 만났다. 친구들은 항상 우테코를 궁금해한다.

> "우테코에서는 뭘 가장 중요하게 배워?"

한 치의 망설임도 없이 나는 대답했다.

> "객체지향."

하지만 돌아오는 친구의 반응은 시큰둥했다.

> "프론트엔드에서... 객체지향?"

---

### 프론트엔드와 객체지향, 정말 거리가 먼 걸까?

솔직히 말하자면, 나도 우테코에 들어오기 전까지는 객체지향이라는 말이 백엔드에서 주로 사용하는 단어라고 생각했다.
React를 주로 다루는 프론트엔드 개발자로서, **"컴포넌트를 나누자", "상태를 관리하자", "관심사를 분리하자"** 같은 말은 익숙했지만,
**"역할과 책임", "협력하는 객체들", "캡슐화"** 같은 용어는 잘 와닿지 않았다.

그런데 '오브젝트'(조영호 저) 2장을 읽던 중, 문득 이런 생각이 들었다.

> "혹시... 리액트의 컴포넌트를 하나의 객체로 생각해볼 수는 없을까?"

---

### 오브젝트가 말하는 객체지향

책 '오브젝트'에서는 객체를 단순한 데이터의 집합으로 보지 않는다.
객체란 **상태(state)와 행동(behavior)** 을 함께 가지는 존재이며, **스스로 판단하고 행동하는 자율적인 주체**다.
더 나아가 객체들은 고립된 존재가 아니라, **서로 협력하며 하나의 기능을 완성하는 공동체의 구성원**이다.

---

### 다시, React로 돌아와 보자

다음은 우리가 평소에 자주 볼 수 있는 React 컴포넌트다.

```tsx
const CartPage = () => {
  const {
    cartData,
    updateCartItem,
    increaseCartItem,
    removeCartItem,
    fetchCartData,
  } = useCartData();

  const {
    isCheckedArray,
    justifyIsChecked,
    controlCheckBox,
    controlAllCheckBox,
    isAllChecked,
  } = useCheckedArray(cartData);

  const { goOrderComplete } = useEasyNavigate();

  return <div css={S.CartPageWrapper}>{/* ...UI 로직 */}</div>;
};

export default CartPage;
```

이 코드를 객체지향의 관점에서 바라보면 어떨까?

- `CartPage`는 화면이라는 전체 기능을 담당하는 '객체'다.
- `useCartData`, `useCheckedArray`, `useEasyNavigate`는 각각의 역할을 맡은 객체들이다.

```js
class CartPage {
  constructor() {
    this.cartDataManager = new CartDataManager();
    this.checkedArrayManager = new CheckedArrayManager(
      this.cartDataManager.getData()
    );
    this.navigator = new Navigator();
  }

  render() {
    return `
      <div class="cart-page-wrapper">
        <!-- UI 로직 -->
      </div>
    `;
  }

  onItemIncrease(itemId) {
    this.cartDataManager.increaseItem(itemId);
  }

  onOrderComplete() {
    this.navigator.goToOrderComplete();
  }
}
```

- tsx 코드를 js의 클래스 문법을 이용해서 아주 간단히 변환한 버전이다. <br />
  이렇게 보니 프리코스와 레벨 1때가 생각이 난다.

- 어떤가? <br />
  레벨 1 때의 기억을 되살려서 이 코드가 좋은 코드일지 살펴보는 것도 재밌는 경험일 것 같다.

---

### 그렇게 보면, 이 코드는 좋은 객체지향 설계일까?

나는 아직도 고민 중이다.
이 코드가 객체지향의 의미를 조금이라도 대변할 수 있는가?

예를 들어, `CartPage`는 너무 많은 역할을 한눈에 처리하고 있지는 않은가? <br />
아니면 Page 단위라서 어쩔 수 없이 많은 역할을 담당할 수 밖에 없는건가? <br />
각 훅에서 어떤 책임을 어디까지 분리했는지 명확히 보이지 않는 부분도 있다. <br />
심지어 useCheckedArray는 인자로 바로 위 커스텀 훅에서 반환하는 cartData를 받는다.<br />
서로 굉장히 의존적이다. <br />
**이 것도 협력이라 볼 수 있는가?** <br />
단순히 훅을 나눈 것만으로 객체 간 협력이 잘 설계되었다고 말할 수 있을까?

---

### 오브젝트에서 말하는 객체지향

- 자율적인 객체: 객체는 자신이 가진 상태를 스스로 판단하고 행동한다.
- 협력: 하나의 기능은 여러 객체가 서로 메시지를 주고받으며 완성한다.
- 책임 기반 설계: 각 객체는 명확한 역할과 책임을 가진다.
- 캡슐화: 내부 상태는 숨기고, 외부에는 메시지(인터페이스)로만 소통한다.

조금의 의문점이 있다.

- 협력? <br />
  내가 말했던 컴포넌트를 객체지향적으로 보는 관점에선, <br />
  협력을 각 커스텀 훅들이 진행해야 될 것 같은데, 우리는 각 커스텀 훅에서 담당하는 기능이 적으면 적을 수록 관심사의 분리가 잘되어있다고 배워왔다. <br />
  **그렇다면 리액트에서는 이 협력의 키워드를 어떻게 적용시킬 수 있을까?**

- 캡슐화? <br />
  어떠한 로직을 커스텀 훅으로 분리한다면, 이는 캡슐화가 되었다고 확실히 말할 수 있을 것이다. <br />
  **이런 관점에서는 모든 컴포넌트에서 담당하게 될 기능을 모두 hook으로 분리시키면 좋은 코드인가?** <br />
  하나의 컴포넌트에서 관심사의 분리까지 챙길 수 있다고만 볼 수 있을까?<br />
  커스텀 훅으로 분리하는 이유에는 반복되는 로직이라는 이유도 있을텐데,
  어떤 기준에서 분리해야 할까 의문이다.

### 같이 이야기 나누어보면 좋을 점

- 리액트 컴포넌트를 하나의 객체로 바라본다면?
- 객체들이 협력한다는 것을 어떻게 이해하여 코드로 적용시켜야할까?
- 객체지향에서 강조하는 캡슐화의 관점에서는, 컴포넌트 내에 로직이 그대로 노출되어 있으면 좋지 않은 코드인 것 같은데, 그렇다면 모든 로직을 훅으로 분리하면 좋은 코드인가?
