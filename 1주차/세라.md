### 우테코에서 왜 **class형을 사용하라고 권장했을까?**

이 질문을 중심에 두고 책을 읽으며 느꼈던 점들을 공유하고 싶었다. 2장을 읽던 중 ‘**정보 은닉**’이라는 개념이 등장했는데, 자연스럽게 레벨1 과정이 떠올랐다.

레벨1에서는 “왜 우테코는 class를 쓰라고 하지?“라는 의문이 계속 들었고, 명확한 근거가 없었기에 익숙하던 함수형 방식으로 구현하는 경우가 많았다. 하지만 지금 돌아보면, class는 단지 문법적 선택이 아니라 객체지향적인 사고를 익히고 이를 React와 연결 지어 생각해보기 위한 **수단**이었던 것 같다.

결국 레벨2에 들어서도 레벨1에서 마주쳤던 고민들을 되짚으며, 배운 지식들 간의 연결을 **의식적으로 계속 시도**하는 것이 중요하다는 것을 느낀다.

정보 은닉이라는 개념을 보며, 예전에 자주 했던 setState를 props를 통해 전달하는 패턴도 **정보 은닉의 원칙에서 벗어날 수 있겠구나** 하는 깨달음이 있었다.

또, 컴포넌트나 훅의 관점에서도 state는 외부에 노출되어서는 안 되는 **내부 상태**이고, 이 내부 상태와 상호작용하는 메시지는 결국 props를 통해 오가는 것이 아닐까? 라는 생각이 들었다. 우리는 흔히 `Car`라는 객체를 그대로 바라보기보다는 `Car` 컴포넌트라는 관점에 매몰되기 쉽다.

하지만 객체지향은 `객체를 객체 그 자체로 바라보는 것`에서 출발한다고 책에서도 말하듯, 리액트나 함수형 방식으로 구현하다 보면 이러한 **객체 중심의 사고가 흐려지기 쉽다.**

다음 세 가지 구현을 예시로 들어보겠다.

class 예시

```jsx
class Car {
  #position = 0;

  move() {
    this.#position += 1;
  }
}
```

함수형 예시

```jsx
const createCar = () => {
  let position = 0;

  return {
    move: () => position++,
  };
};
```

컴포넌트 예시

```jsx
export const Car = () => {
  const [position, setPosition] = useState(0);

  const move = () => setPosition((p) => p + 1);

  return <div>{position}</div>;
};
```

이 세 가지를 비교해보면, 클래스에서는 정보 은닉이 명확하게 드러나고, 함수형이나 리액트 컴포넌트에서는 그 경계가 흐려지는 것을 알 수 있다. 즉, **class는 객체지향을 익히기에 좋은 도구**였던 셈이다.

class를 리액트 컴포넌트 혹은 훅처럼 생각해보면, state는 외부에 드러나지 않아야 하는 내부 상태이며, props를 통해 주고받는 메시지가 곧 객체 간 메시지라는 관점으로도 해석할 수 있다. 그렇다면 결국 중요한 것은 **컴포넌트이든, 훅이든, 클래스이든 그것이 객체지향을 표현하기 위한 도구일 뿐이라는 사실**이다.

진짜 중요한 건 객체지향적인 관점을 갖는 나의 **마인드셋**이며, 객체를 객체 그 자체로 바라보려는 **시선**이다.

그렇다면 객체지향이 왜 중요할까? 이 질문은 결국 1장에서 이야기한 **소프트웨어 모듈이 지녀야 할 세 가지 목적**으로 되돌아가야 할 것 같다. 물론 이 기준들도 절대적인 것은 아니고, **상황에 따라 유연하게 해석될 수 있는 지점**이 있다고 생각한다.

첫번째는 실행 중에 제대로 동작하는 것이다.
우테코에서 가장 많이 반복해서 들은 말 중 하나는 “우선 돌아가는 쓰레기를 만들라”였다. 즉, 어떤 기능이든 일단 **정확하게 동작**해야 한다는 것. 아무리 구조가 좋고 읽기 쉬운 코드라도 제대로 작동하지 않으면 의미가 없다. 이 부분은 우테코 초반 과정에서 꽤 체득한 것 같다

두번째는 변경을 위해 존재하는 것이다.
모든 소프트웨어는 **변화**한다. 단순한 요구사항 변경이더라도 시스템 전체를 건드려야 한다면 그건 이미 잘못된 구조일 수 있다. 객체지향이 중요한 이유는 여기에서 드러난다. **캡슐화**를 통해 **변화의 영향을 최소화**할 수 있기 때문이다. (그런데 나는 아직도 이 지점이 어렵게 느껴진다.)

마지막으로는 코드가 단순히 컴퓨터를 위한 것이 아니라, **사람과의 소통 도구**가 되어야 한다는 점이다.
의도가 보이지 않거나 복잡하게 꼬여 있는 코드는 오히려 문제를 키운다. **읽는 사람이 이해하기 쉬운 구조**, 즉 모듈 간의 역할이 명확하고 메시지가 잘 드러나는 코드여야 한다.

이 책을 읽어나가며, 리액트와 그동안의 학습 경험을 바탕으로 각 관점을 끊임없이 연결해보고자 한다.
