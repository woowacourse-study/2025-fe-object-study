## 좋은 품질의 퍼블릭 인터페이스를 위한 원칙과 기법

오브젝트 6장에선 퍼블릭 인터페이스를 좋게 만들기 위해 다음과 같은 원칙과 기법을 소개한다.

### 디미터 법칙

- 객체 내부의 구조에 강하게 결합되지 않도록 협력 경로를 제한해라.
- 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않음.
  - 모든 상황에 맹목적으로 위임 메서드를 추가하면, 같은 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 되어 응집도를 낮춘다.

### 묻지 말고 시켜라

- 메시지 수신자의 상태를 바꾸면 안된다!
- 대신 묻는 대상이 객체인지, 자료 구조인지에 따라 다르다.

### 의도를 드러내는 인터페이스

- 인터페이스는 객체가 어떻게 하는지가 아닌 무엇을 하는지 서술해야 한다.
  - 의도를 드러내고, 선언적

### 명령-쿼리 분리 원칙

- 명령은 객체의 상태를 변경하되, 반환값을 가지면 안된다.
- 쿼리는 반환값을 가지되, 객체의 상태를 변경하면 안된다.
- 참조 투명성(어떤 표현식이 있을 때 표현식의 위치에 해당 표현식과 같은 값으로 교체하더라도 결과가 달라지지 않는 특성)을 지킬 수 있다.
  - 쿼리는 아무리 불러도 상태를 변경하지 않기에 같은 값을 반환한다.
  - 명령은 객체의 상태를 변경하므로 부수 효과를 조심해야 한다.


## 명령-쿼리 분리 법칙과 순수 컴포넌트

명령-쿼리 분리 법칙은 반환값을 가지지 않는 명령과 반환값을 가지는 쿼리를 확실하게 분리해야 한다는 법칙이다. 해당 법칙을 따르면 명령은 객체의 상태를 변경하지만 반환값을 가지면 안되고, 쿼리는 반환값을 가지지만 객체의 상태를 변경하면 안된다. 이 법칙을 보고 나는 리액트의 ["Keeping Components Pure"](https://react.dev/learn/keeping-components-pure) 공식 문서가 떠올랐다.

해당 공식문서에 따르면 리액트의 모든 컴포넌트는 전부 순수하게 작성해야 한다는 점을 강조한다. 순수라는 키워드를 보면 순수 함수를 떠올릴 수 있다. **순수 함수란 오직 함수에 들어가는 인자만이 결과에 영향을 주는 함수**를 의미한다. 리액트는 모든 컴포넌트가 이런 순수 함수처럼 작동한다고 가정하고 설계되었다. 즉 리액트의 컴포넌트는 순수하므로 다음 두 가지 특정을 가정한다.

- 렌더링 과정에서 외부의 어떤 상태도 변경해서는 안된다. 즉, 자기 자신의 일만 처리한다.
- 동일한 입력(상태, props, 컨텍스트)에 항상 동일한 JSX 출력을 반환한다.

여기서 두 번째, 동일한 입력(상태, props, 컨텍스트)에 항상 동일한 JSX 출력을 반환한다는 내용이 명령-쿼리 분리 법칙이 떠오른 이유다. 컴포넌트를 100번 호출하면 100번 다 같은 컴포넌트가 나와야 한다. 즉 컴포넌트는 쿼리이다.


이러한 관점에서 보면, 컴포넌트는 쿼리로 반환만 수행해야 하며, 명령(부수 효과)을 컴포넌트 내부에서 직접 수행하는 것은 지양해야 한다. 명령-쿼리 분리 법칙의 관점에서 리액트 컴포넌트는 "쿼리"로 취급되기 때문이다. 즉, 리액트 컴포넌트는 **외부 상태를 변경하거나 어떤 효과를 발생시키는 명령을 내려서는 안되며**, 단순히 **입력(props, state 등)에 따라 동일한 출력(JSX)을 반환하는 쿼리**로 작성해야 한다.

## 컴포넌트의 퍼블릭 인터페이스

이제 리액트 컴포넌트의 **퍼블릭 인터페이스**를 생각해보자. 퍼블릭 인터페이스란 외부에서 해당 컴포넌트를 사용할 때 접하게 되는 모든 요소를 의미한다. 리액트에서 컴포넌트의 퍼블릭 인터페이스는 `props`다. 사용자는 이 `props`를 통해 컴포넌트를 조작하거나 데이터를 전달할 수 있다.

따라서 좋은 컴포넌트 인터페이스란 다음과 같은 특징을 갖는다.

- 명확한 의도를 전달해야 한다.
  - 어떤 `props`가 무엇을 위한 것인지, 컴포넌트를 사용하는 사람에게 의도가 명확하게 드러나야 한다.
- 부수 효과 없이 선언적이어야 한다.
  - `props`가 내부 상태를 간접적으로 조작하지 않고, 단지 출력 결과(JSX)에만 영향을 주는 형태여야 한다.
- 읽기 쉽고 예측이 가능하다. = 순수하다
  - 동일한 `props`를 주었을 때 항상 동일한 출력이 나오는 형태여야 한다. 이는 테스트 가능성에도 직접적인 영향을 준다.

이러한 특징은 앞서 설명한 명령-쿼리 분리 법칙과 정확히 맞닿아 있다. `props`를 통해 컴포넌트에 쿼리를 던지면, 그 결과로 JSX를 반환한다. 마치 객체지향에서 쿼리를 통해 객체의 상태를 조회하듯이, 리액트에서는 `props`를 통해 원하는 UI를 “조회”하는 셈이다.

## 생각점?: 부수 효과는 어디에 있어야 할까?

그렇다면 명령, 즉 **부수 효과를 포함한 로직은 어디로 가야 할까?** 리액트에서 다룰 수 있는 부수 효과는 다음과 같다.

- 이벤트 핸들러: 사용자 인터랙션에 따른 부수 효과는 `onClick`, `onChange` 등 이벤트 핸들러로 전달된 콜백 함수 내에서 수행된다. 즉, 컴포넌트 내부가 아닌 외부에서 처리되도록 한다.
- 커스텀 훅: 복잡한 상태 변경이나 리액트 시스템 외부의 효과는 `useEffect`, `useReducer` 등의 훅에서 처리한다. 이 역시 컴포넌트를 순수하게 유지하기 위한 전략이다.

해당 구조를 따르면 명령은 훅 또는 상위 컴포넌트(컨테이너)에서 담당하고, 컴포넌트는 오직 쿼리 역할에 집중하게 한다. 컴포넌트는 주어지는 props에 따라 같은 UI를 보여줄 책임을 담당하고, 해당 UI에서 상태가 바뀌는 작업은 상위 컴포넌트나 컨테이너에서 담당하게 한다. 이를 통해 관심사의 분리를 명확히 하여 테스트와 유지보수를 수월하게 한다.

## 제 컴포넌트를 소개합니다
![스토리북 링크](https://github.com/user-attachments/assets/35cc924d-6738-4e85-8264-d2b1a73aafa0)

지금 만들고 있는 포게더 앱에서, 적절한 퍼블릭 인터페이스를 생각한 컴포넌트를 하나 가져왔다. SpaceHomeTopActionBar는 사진 목록에서 선택 버튼을 눌러 사진을 선택할 수 있는 선택 모드로 들어올 수 있게 하는 책임을 가지고 있다. 선택 모드로 들어왔을 때 전체 선택 버튼이 표시되고 이를 눌러 모든 사진을 전부 선택할 수 있다.

사실 내가 만든 컴포넌트는 아니고, 같은 팀원이 만들어준 컴포넌트였지만 코드 리뷰를 통해 적절한 인터페이스가 무엇인지 생각해 볼 수 있었다. 처음에는 toggleSelectMode, toggleAllSelected라는 기능을 표시하는 인터페이스가 달려있는 컴포넌트였다.

하지만 해당 컴포넌트를 사용할 때 기능명으로 인터페이스를 받는 것보단, 버튼을 눌렀을 때 어떤 동작을 한다는 `on-` 인터페이스를 제안했다. 이 제안을 통해 기대할 수 있는 이점은 다음과 같이 정리할 수 있다.

- 만약 선택 버튼을 눌렀을 때 선택 모드를 토글하는 것 이외에 추가적인 동작을 한다면 해당 동작에 대한 인터페이스를 추가적으로 뚫어줘야 한다.

- 이 컴포넌트를 봤을 때 사용자가 기대하는 것은 컴포넌트 내 두 버튼을 눌렀을 때 어떤 동작을 하는지이다. `on-` 인터페이스는 두 버튼을 눌렀을 때 동작하는 함수라는 점을 사용자로 하여금 인터페이스만 보고 확실하게 알게 한다.

- 내부 구현에 대한 정보를 숨길 수 있다. 선택 버튼을 눌렀을 때 선택 모드를 토글한다는 기능을 숨기고 버튼을 눌렀을 때 어떤 동작을 하는지에만 집중한다. (디미터 법칙)

![깃허브 리뷰](https://github.com/user-attachments/assets/3014fa2d-3df0-4ca6-ba41-1341c0ce05e0)

한편으론 더 개선할 여지가 있는 인터페이스라고도 생각한다.

- 선택 모드를 켰을 때만 전체 선택 버튼이 활성화된다. 따라서 전체 선택 버튼을 눌렀을 때 어떤 동작을 하는지 정의를 해도 해당 함수를 실행시키지 못할 수 있다.

- 따라서 상태에 의존적인 인터페이스..? 라는 생각이 들기도 한다.

## 결론

**좋은 퍼블릭 인터페이스를 가진 컴포넌트란, 명령과 쿼리를 분리하고, 쿼리로서의 역할에 충실한 순수 컴포넌트이다.** 리액트 컴포넌트의 인터페이스는 데이터를 요구하고, 그에 대한 시각적 표현을 반환하는 방식으로 선언적이며 예측 가능한 구조를 갖춰야 한다. 이는 객체지향 설계에서 이야기한 "묻지 말고 시켜라", "의도를 드러내는 인터페이스", 그리고 "명령-쿼리 분리"의 철학이 리액트 개발에서도 유효하다는 것을 보여준다.

<details><summary><b>부록: 정리노트</b></summary>

![정리노트](https://github.com/user-attachments/assets/378cb04d-69c6-4dc8-9962-32f716805411)

</details>
