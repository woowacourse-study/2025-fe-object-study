### 메세지, 메서드, 오퍼레이션

메세지 ⇒ 오퍼레이션명과 인자로 이루어짐

메세지 전송 ⇒ 오퍼레이션명과 인자와 메세지 수신자를 추가

메세지를 수신했을 때 실제로 실행되는 함수 또는 프로시저 메서드라고 함

객체지향에서는 동일한 이름의 메시지를 보내더라도 수신 객체의 타입에 따라 다른 동작이 가능하다.

React로 치면,

- 메시지: 컴포넌트 이름과 받을 수 있는 props
- 메서드: 외부에 정의되어있고 그 props를 받아 내부에서 실행되는 구체적인 로직
- 퍼블릭 인터페이스: 해당 컴포넌트를 사용하는 쪽에서 알면 되는 props의 타입

이라고 생각했다.

### 인터페이스와 설계품질

좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을
만족해야 한다.

최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다. 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.

이것은 React에서도 마찬가지다. props는 필요한 것만 포함하고, 이름은 동작의 목적을 표현해야 한다. 불필요하게 많은 props를 노출하면 결합도가 높아지고, 내부 구현이 바뀔 때 사용하는 쪽도 함께 수정해야 한다. 그렇지만 필요한 최소한의 props와 추상적인 이름을 사용하면, 내부 구현 변경이 외부에 영향을 주지 않으면서 재사용성이 높아진다.

### 디미터의 법칙

디미터의 법칙은 불필요한 어떤 것도 다른 객체에게 보여주지 않는다.

메세지 수신자의 내부 구조가, 전송자에게 노출되지 않는다.

이 개념에서 자식 컴포넌트가 함수를 부모에게서 넘겨 받을 때를 생각해보았다.

자식 컴포넌트는 전송자가 된다. 메세지 수신자는 부모 컴포넌트가 된다.

메세지 수신자인 부모는 데이터를 가지고 있기 때문에 서버가 된다

메세지 전송자인 자식은 요청을 서버에게 보내고 그 결과를 제공 받는다

```tsx
const Sidebar = ({ handleViewModeChange }: SidebarProps) => {
  const {
    handleValidateToggle,
  } = useRoutieValidateContext();

return (
	<ToggleSwitch
	  active={isValidateActive}
	  onToggle={handleValidateToggle}
	/>
)}
```

- 전송자(자식): `ToggleSwitch`
    - `onToggle`이 무엇을 하는지 모른 채 호출만 함
- 수신자(부모): `Sidebar`
    - `handleValidateToggle` 내부에서 상태 변경 로직 실행

이 구조에서는 부모의 상태 관리 로직이 변경되더라도 자식은 수정할 필요가 없으므로 낮은 결합도를 유지할 수 있다.

그런데 이 코드에 디미터의 법칙 즉, 메세지 전송자가 수신자의 정보를 알고 있는 경우가 있다

```tsx
{routiePlaces.length === 0 && <EmptyRoutieMessage />}
```

- `routiePlaces`가 배열이라는 내부 구조를 알고 있다.
- 이럴때는 비어있다는 상태 자체를 부모, 여기서는 context가 `isEmpty` 같은 값으로 내려줄 수 있음

```tsx
{isRoutiePlacesEmpty && <EmptyRoutieMessage />}
```

이렇게 하면 routiePlaces가 배열이든 다른 타입의 데이터이든 상관없이 자식은 비어있다는 값만 알면되어서 수신자의 정보를 몰라도 된다. context와 혹은 부모 컴포넌트와 컴포넌트의 결합도가 낮아진다.

### 묻지 말고 시켜라

> 메시지 전송자는 수신자의 상태를 묻고 직접 변경해서는 안 된다.
> 
> 
> 무엇을 원하는지만 말하고, 구체적인 동작은 수신자가 결정해야 한다.
> 

React에서도 상태를 가진 컴포넌트가 스스로 판단하도록 설계하는 것이 중요하다. 자식은 단순히 `onToggle()` 같은 의도 중심의 함수를 호출하고, 상태 변경 로직과 부수효과는 부모가 처리한다. 이렇게 하면 정보(부모의 것)와 행동(부모의 것)이 한 곳에 모여 응집도가 높아진다. 

### 의도를 들어내는 인터페이스

> 메서드 이름은 무엇을 하는지를 드러내야 하며, 어떻게 하는지는 숨겨야 한다.
> 

React에서도 `onClick`, `onChange`처럼 제스처 중심의 이름보다는 `onSavePlace`, `onToggleValidate`, `onPlaceUpdated`처럼 의도·결과 중심으로 네이밍할 수 있다.

이 것을 확장에서 의도를 드러내는 인터페이스를 생각해 볼 수 있다고 한다. 의도를 드러내는 인터페이스를 요약하면 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것이다. 

리액트에서는 부모 쪽의 구체적인 로직을 자식이 알지 못하게 하고 협력과 관련된 의도만 props 네이밍을 통해서 드러내야 한다는 말이다.

예전 코드를 살펴보니 이런 코드가 있었다

```tsx
type ProductItemProps = {
  isChecked: boolean;
  cartCount: number;
  onAddCart: () => void;
  onIncrease: () => void;
  onDecrease: () => void;
  onDelete?: () => void;
  variant?: 'default' | 'modal';
} & Pick<Product, 'name' | 'imageUrl' | 'price' | 'quantity'>;
```

이 자식 컴포넌트는 버튼 클릭 시 `onAddCart()` 장바구니에 추가해줘 라는 메세지를 보내고 호출 내부에서 장바구니를 어떻게 추가하는지, 어디에 저장하는는 모른다. 부모는 이 자식과 카트추가 하는 로직을 `onAddCart`라는 장바구니에 추가라는 협력의 의도를 담고 있는 인터페이스에 전달한다. 만약 이 props 이름이 `onPlusButtonClick`이었다면, 언제 실행되는지만 드러나고 컴포넌트 간 협력 목적은 드러나지 않는다. 의도를 드러내는 네이밍은 단순히 읽기 편한 것을 넘어서 외부에서 어떤 props에 어떤 함수를 넘겨야 할지 명확하게 알려줄 수 있는 수단이 될 수 있다. 그러면 실수를 줄이고 협력 관계를 빠르게 이해할 수 있다고 생각한다.

### 명령-쿼리 분리 원칙

명령은 객체의 상태를 변경한다.

쿼리는 객체의 정보를 반환한다.

명령과 쿼리를 분리했을 때의 장점은 코드가 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해진다고 한다. 

이 원칙을 읽고 무슨말이지? 라고 생각했는데 useState를 떠올리니 바로 이해가 되었다. 

```tsx
const [state, setState] = useState()
```

state는 쿼리이다, setState는 명령이다. 이렇게 명령 쿼리 분리 원칙을 따르는 구조 덕분에 우리는 state는 오직 setState를 통해서만 변경된다고 예측할 수 있다.또한 state를 조회하는 동안 값이 바뀌지 않는다는 확신이 생겨, 부수효과 없이 안전하게 코드를 작성할 수 있다.

만약 useState가 쿼리와 명령으로 분리되어있지 않았더라면 조회와 변경이 섞여서 예상치 못한 값이 되어버리거나 사용자 화면도 예측 불가능하게 동작했을 것이다. 

이렇게 명령과 쿼리를 분리한 `useState` 같은 state를 사용하면 항상 같은 화면을 보여줄 수 있도록 보장하고 있고 React가 예측 가능한 UI를 제공하기 위해 이렇게 설계했구나를 깨달을 수 있었다. 

### 결론

이렇게 React를 메시지와 인터페이스 관점에서 바라보았다. 책을 읽으면서 객체지향에서 메시지로만 소통하고, 의도가 드러나는 인터페이스를 사용하는 이유는 역시나 변경에 유연하고 예측 가능한 코드를 작성할 수 있게 하기 때문이였다.

이 원칙들을 React에 적용해 보았을 때도, 컴포넌트가 변경에 강해지고 예측 가능한 코드를 작성할 수 있음을 확인할 수 있었다.

그동안 props로 넘기는 함수의 이름을 짓는 것 그리고 인터페이스를 정의하는 것이 조금 어려웠는데, 이제는 이것을 협력을 표현하는 메시지 라는 관점에서 바라보고 좀 더 협력의 의도를 담아서 작성해볼 수 있을 것 같다.