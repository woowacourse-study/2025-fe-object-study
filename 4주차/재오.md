## 묻지 말고 시켜라

- 내부 상태를 문지 말고, 원하는 일을 하라고 시켜라.
- 내부 구조를 알아야하는 것이 아니라서 결합도가 낮아진다.
- 객체의 구현 세부사항이 드러나지 않기 때문에 캡슐화 효과도 있다.

### [잘못된 예시?]
```tsx
export function useCart() {
  const [cartItems, setCartItems] = useState<CartItemType[]>([]);
  const addCartItems = (items: CartItemType[]) => setCartItems(prev => [...prev, ...items]);
  const updateCartItems = (upd: CartItemType[]) => setCartItems(upd);
  const deleteCartItems = (ids: number[]) => setCartItems(prev => prev.filter(i => !ids.includes(i.id)));
  return { cartItems, addCartItems, updateCartItems, deleteCartItems };
}

// 사용처
const { cartItems, addCartItems, deleteCartItems } = useCart();


const selected = cartItems.filter(i => i.selected);
const subtotal = selected.reduce((s, i) => s + i.price * i.quantity, 0);
```

- 컴포넌트가 카트 구조/규칙에 깊게 결합 → 구조/정책 바뀌면 컴포넌트 전역 수정
- 동일 계산이 다른 화면에서도 또 필요하면 중복
- 테스트도 어려움(UI 렌더링과 비즈니스 로직이 섞임)

```tsx
export function useCart(): { query: CartQueries; command: CartCommands } {
  const [cartItems, setCartItems] = useState<CartItemType[]>([]);

  const items = cartItems; // 혹은 ViewModel로 변환해서 최소 필드만 노출
  const selectedItems = useMemo(() => items.filter(i => i.selected), [items]);
  const subtotal = useMemo(() => selectedItems.reduce((s, i) => s + i.price * i.qty, 0), [selectedItems]);

  const add = (items: CartItemType[]) => setCartItems(prev => [...prev, ...items]);
  const update = (upd: CartItemType[]) => setCartItems(upd);
  const remove = (ids: number[]) => setCartItems(prev => prev.filter(i => !ids.includes(i.id)));
  const toggleSelect = (id: number) => setCartItems(prev => prev.map(i => i.id === id ? { ...i, selected: !i.selected } : i));
  const selectAll = () => setCartItems(prev => prev.map(i => ({ ...i, selected: true })));
  const clearSelection = () => setCartItems(prev => prev.map(i => ({ ...i, selected: false })));

  return {
    items,
    selectedItems,
    subtotal,
    add,
    update,
    remove,
    toggleSelect,
    selectAll,
    clearSelection,
  };
}
```


## 명령-쿼리 분리(CQS)

- 쿼리: 부수효과를 가지지 않는 대신 값을 반환한다.
- 명령: 부수효과를 가지는 대신 갑을 반환하지 않는다.

### 부수효과란 무엇일까?

- [리액트](https://ko.react.dev/learn/synchronizing-with-effects)에서는 이벤트 핸들러를 사용자의 특정 상호작용(버튼 클릭 등)으로 발생하는 부수효과라고 언급하고, 그것을 `Effect`라고 정의한다.
- Effect = 렌더링 이후 React 외부 시스템과 동기화하는 자동 실행되는 부수효과.
- 네트워크 요청, DOM 조작, 로깅, 브라우저 API 사용(localStorage 읽기/쓰기)도 부수효과라고 볼 수 있다.
- 하지만 이 책에서 말하는 부수효과는 일반적인 프로그래밍 개념에서 [부수효과](https://en.wikipedia.org/wiki/Side_effect_(computer_science))를 말한다.
- 일반적인 프로그래밍에서 부수효과는 "함수나 표현식이 반환값 이외의, 즉 인자로부터 값을 읽어 반환하는 기본 효과 이외에, 수정, 오류 발생, I/O, 외부 함수 호출 등과 같이 관찰 가능한 부가적인 효과를 수행하는 것"이라고 정의한다.
- 그래서 리액트의 상태 또한 부수효과라고 볼 수 있다 생각한다.


### 왜 필요한가?
- 예측 가능성: 쿼리는 몇 번 호출해도 결과가 같음
- 테스트 용이성: 쿼리는 순수 테스트, 명령은 목/스파이로 검증
- 디버깅/추론: 어디서 상태가 바뀌는지가 선경해짐

### 함수의 네이밍으로 CQS를 반영할 수 있다.
- 쿼리: `get-`/`is-`/`has-`/`calculate-`
- 명령: `set-`/`load-`/`update-`/`toggle-`/`apply-`
- 팀 컨벤션으로 정해도 좋을 것 같다는 생각을 했다.

### [잘못된 예시]
```tsx
function useUser(userId: string) {
  const [user, setUser] = useState<{ id: string; name: string } | null>(null);

  async function getUser() {
    const res = await fetch(`/api/users/${userId}`);
    const data = await res.json();
    setUser(data);
    return data;
  }

  useEffect(() => {
    getUser();
  }, [])

  return { user, getUser };
}
```

### [이렇게 하면 좋을 수도 있겠다고 생각할 수도 있겠다고 추천하고 싶을 수 있겠다고 생각하는 구조]
```tsx
export function useCartSelection(cartItems: CartItemType[]) {
  const [selectedCartItemIds, setSelectedCartItemIds] = useState<Set<number>>(...);

  const isAllItemSelected = cartItems.every((item) => selectedCartItemIds.has(item.id));
  const isSomeItemSelected = cartItems.some((item) => selectedCartItemIds.has(item.id));

  const getSelectedCartItems = useCallback(
    (items: CartItemType[]) =>
      items.filter((item) => selectedCartItemIds.has(item.id)),
    [selectedCartItemIds]
  );

  const toggleSelect = useCallback((targetId: number) => {
    setSelectedCartItemIds((prev) => {
      ...
    });
  }, []);

  const toggleAllSelect = useCallback(() => {
    setSelectedCartItemIds(() => {
      ...
    });
  }, [cartItems, isAllItemSelected]);

  const deleteSelect = useCallback((targetId: number) => {
    setSelectedCartItemIds((prev) => {
      ...
    });
  }, []);

  return {
    states: {
      selectedItemIds: [...selectedCartItemIds],
      isAllItemSelected,
      isSomeItemSelected,
    },
    actions: {
      toggle: toggleSelect,
      toggleAll: toggleAllSelect,
      delete: deleteSelect,
    },
    utils: {
      getSelectedItems: getSelectedCartItems,
    },
  };
}

function CartContents({ cartItems }: { cartItems: CartItemType[] }) {
  const cartSelection = useCartSelection(cartItems);
  const navigate = useNavigate();

  const selectCartItems = cartSelection.utils.getSelectedItems(cartItems);
  const orderPrice = calculateOrderPrice(selectCartItems);

  const disabled = !cartSelection.states.isSomeItemSelected;

  const moveToOrderCheck = () => {
    navigate(ROUTE.orderCheck, {
      state: { orderProducts: selectCartItems },
    });
  };

  if (cartItems.length === 0) {
    return <CartEmptyContent />;
  }

  return (
    <S.Container>
      <CartTitle quantity={cartItems.length} />
      <CartList
        cartItems={cartItems}
        selectedCartItemIds={cartSelection.states.selectedItemIds}
        isAllItemSelected={cartSelection.states.isAllItemSelected}
        toggleSelect={cartSelection.actions.toggle}
        deleteSelect={cartSelection.actions.delete}
        toggleAllSelect={cartSelection.actions.toggleAll}
      />
      <CartPriceSummary value={orderPrice} />
      <FooterButton disabled={disabled} onClick={moveToOrderCheck}>
        주문 확인
      </FooterButton>
      <ErrorToastMessage />
    </S.Container>
  );
}
```

- 이렇게 actions / utils / states로 객체로 구분해는 것도 명령/쿼리를 분리 관점에서 좋을 수 있다.
- actions 네이밍을 통해 부수효과가 있음을 명확히 표현할 수 있다.