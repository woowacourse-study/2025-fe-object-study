들어가기에 앞서, 메시지를 전송한다는 것과 메서드를 호출한다는 것이 결국 같은 행위처럼 느껴지지만, 책에서는 이를 구분해서 생각해야 협력이 원활해진다고 말합니다.

여러 고민 끝에 제가 내린 결론은 다음과 같습니다.

<aside>

메시지를 전송한다는 표현은 객체들이 서로 협력하기 위해 “무엇을 해야 하는지”를 요청하는, 원칙적이고 추상적인 개념이라고 생각합니다. 반면 메서드를 호출한다는 것은 그 요청이 “어떻게 실행되는지”를 구체적으로 기술하는 동작입니다. 책에서 이 둘을 분리해서 생각하라고 하는 이유는, 구현 세부사항에 얽매이기보다 협력과 설계 단계에서 객체들의 책임을 먼저 명확히 해야 하기 때문이라고 봅니다!

</aside>

이번 주차는 각 법칙들을 리액트 관점에서 적용시켜봤습니다!

## 디미터 법칙

디미터 법칙의 핵심은 “협력하는 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라!”라고 느껴졌습니다. 그 과정에 중요한 점은 2가지라고 생각했어요.

- 직접적으로 소통하기
- 내부 구조를 묻지 말고 명확한 요청만 하기

BadCase

```tsx
function OrderSummary({ order }) {
  return (
    <div>
      <h2>{order.customer.profile.personalInfo.name}</h2>
      <p>{order.shipping.address.street.fullAddress}</p>
      <p>{order.payment.method.provider.displayName}</p>
      <p>{order.items[0].product.pricing.finalPrice}원</p>
    </div>
  );
}
```

깊은 체이닝으로 내부 구조에 의존하는 코드입니다. 다음과 같은 문제점들이 발생합니다.

1. 내부 구조에 강하게 결합하게 된다.
   1. 데이터 구조가 조금만 바뀌어도 코드를 수정해야 한다.
2. 캡슐화를 위반하게 된다. order의 표현 방식을 모두 알아야 하기 때문에, 지나치게 많은 정보를 알게 된다.

GoodCase

```tsx
function useOrderSummary(order) {
  return useMemo(
    () => ({
      customerName: order?.customer?.profile?.personalInfo?.name || "이름 없음",
      shippingAddress:
        order?.shipping?.address?.street?.fullAddress || "주소 없음",
      paymentMethod:
        order?.payment?.method?.provider?.displayName || "결제수단 없음",
      firstItemPrice: order?.items?.[0]?.product?.pricing?.finalPrice || 0,
    }),
    [order]
  );
}

function OrderSummary({ order }) {
  const { customerName, shippingAddress, paymentMethod, firstItemPrice } =
    useOrderSummary(order);

  return (
    <div>
      <h2>{customerName}</h2>
      <p>{shippingAddress}</p>
      <p>{paymentMethod}</p>
      <p>{firstItemPrice}원</p>
    </div>
  );
}
```

해당 코드는 hook을 통해, 중간 계층을 캡슐화한 코드이다.

1. 직접적인 협력관계를 갖는 `useOrderSummary`를 통해서만 데이터를 요청하기 때문에 내부 구조 변경에 영향이 적다.
2. OrderSummary는 단순한 데이터만 받아서 사용함으로써 컴포넌트가 복잡한 내부 구조를 몰라도 되고, 각자의 역할이 명확히 분리된다.
3. 비즈니스의 의도가 명확히 드러난다.
4. 복잡성이 한곳에 집중되어 캡슐화가 강화된다.

## 묻지 말고 시켜라

상태 판단 로직, 비즈니스 의도, 데이터 변환을 캡슐화하면, 외부에서는 복잡한 내부 상태를 직접 확인할 필요 없이 명확한 의도만 전달할 수 있다고 생각한다.

BadCase

```tsx
function EventManagement() {
  const [guests, setGuests] = useState([...]);
  const [checkedIds, setCheckedIds] = useState(new Set());

  const handleGuestChecked = (guestId, isChecked) => {
    const isCurrentlyChecked = checkedGuestIds.has(guestId);

    if (isCurrentlyChecked !== isChecked) {
      const newCheckedIds = new Set(checkedGuestIds);

      if (isChecked) {
        newCheckedIds.add(guestId);
      } else {
        newCheckedIds.delete(guestId);
      }

      setCheckedGuestIds(newCheckedIds);
    }
  };

  const handleAllGuestChecked = (isAllChecked) => {
    if (isAllChecked) {
      const uncheckedGuestIds = guests
        .filter(guest => !checkedGuestIds.has(guest.organizationMemberId))
        .map(guest => guest.organizationMemberId);

      if (uncheckedGuestIds.length > 0) {
        const allGuestIds = guests.map(guest => guest.organizationMemberId);
        setCheckedGuestIds(new Set(allGuestIds));
      }
    } else {
      if (checkedGuestIds.size > 0) {
        setCheckedGuestIds(new Set());
      }
    }
  };

  const guestDataWithChecked = guests.map(guest => ({
    ...guest,
    isChecked: checkedGuestIds.has(guest.organizationMemberId)  // 매번 확인
  }));

  return (
	  <GuestViewSection
	    guests={guestData}
	    onGuestChecked={handleGuestChecked}
	    onAllChecked={handleAllGuestChecked}
	  />
  };
```

현재 코드는 상태를 직접 확인하고, 그에 맞춰 조건을 판단해 명령을 내린다.

이 방식에는 다음과 같은 문제가 있다.

1. 각 상태를 매번 직접 확인하고, 복잡한 조건문을 작성해야 한다.
2. 비즈니스 로직이 이벤트 핸들러 안에 섞여 있다.
3. 요구사항이 늘어날수록 조건문이 복잡해진다.

GoodCase

```tsx
const {
  toggleAll: toggleGuestAllChecked, // "전체를 토글해줘"
  toggleItem: toggleGuestChecked, // "이 아이템을 토글해줘"
  getCheckedGuests: getCheckedGuests, // "체크된 게스트들을 가져와줘"
} = useCheckableGuests(guests);

<GuestViewSection
  onGuestChecked={toggleGuestChecked} // 세부사항 몰라도 됨
  onAllChecked={toggleGuestAllChecked} // 세부사항 몰라도 됨
/>;
```

**의도가 드러나는 명령**을 전달하면 다음과 같은 장점이 있다.

- 부모 컴포넌트는 전체 토글해줘, 개별 토글해줘라는 **의도만 전달하면 된다.**
- **복잡한 상태 관리 로직**이 `useCheckableGuests` 안에 **캡슐화된다.**
- 새로운 요구사항이 생겨도 **hook 내부만 수정**하면 된다.

더 나아가면 이 패턴을 적용하면 각각의 책임이 명확히 분리되어 단일 책임 원칙을 준수할 수 있다.

- useCheckableGuests: 체크 상태 관리만 담당
- GuestViewSection: UI 렌더링만 담당
- 부모 컴포넌트: 데이터 흐름 조정만 담당

## **의도를 드러내는 인터페이스**

책에서는 의도를 드러내려면 두가지에 대해 집중해 생각하라고 한다.

1. 메소드 명을 어떤 작업을 수행하는지 드러내야 한다.
2. 메소드 명도 결국은 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.

BadCase

```tsx
function ProductList() {
  const [products, setProducts] = useState([]);

  const fetchProductDataFromAPIAndUpdateState = async () => {
    const response = await fetch("/api/products");
    const data = await response.json();
    setProducts(data);
  };

  const renderProductListItemsWithPriceFormatting = () => {
    return products.map((product) => (
      <div key={product.id}>
        {product.name} - {formatCurrency(product.price)}
      </div>
    ));
  };

  const handleClickEventOnRefreshButton = () => {
    fetchProductDataFromAPIAndUpdateState();
  };

  return (
    <div>
      <button onClick={handleClickEventOnRefreshButton}>새로고침</button>
      {renderProductListItemsWithPriceFormatting()}
    </div>
  );
}
```

1. 구현 방식을 노출시켜 구체적인 과정을 메소드에 드러내고 있다
   1. `fetchProductDataFromAPIAndUpdateState`: API에서 가져와서 상태를 업데이트한다는 **구체적인 절차**를 드러내고 있다.
   2. `renderProductListItemsWithPriceFormatting`: 상품 목록을 렌더링하면서 가격을 포맷팅한다는 **구현 세부사항**을 노출하고 있다.
2. 책임이 아니라 절차를 중시하는 것 처럼 보이고, 이를 호출하는 쪽에서 절차를 이해해야 사용이 가능하다.
3. 다른 객체/함수와 어떤 책임을 주고 받는지 보이지 않는다.
   1. 다른 객체/함수와 어떤 책임을 주고받는지 보이지 않는다.
   2. 단순히 구현된 작업들을 나열하는 수준이다.

GoodCase

```tsx
function ProductList() {
  const [products, setProducts] = useState([]);

  const refreshProducts = async () => {
    const response = await fetch("/api/products");
    const data = await response.json();
    setProducts(data);
  };

  const showProducts = () => {
    return products.map((product) => (
      <ProductCard key={product.id} product={product} />
    ));
  };

  const handleRefreshRequest = () => {
    refreshProducts();
  };

  return (
    <div>
      <button onClick={handleRefreshRequest}>상품 새로고침</button>
      {showProducts()}
    </div>
  );
}
```

1. 코드를 요구사항 문서처럼 읽히게 만들어, 개발자 간의 소통 비용을 줄이고, 유지보수성을 높일 수 있게 된다.
   - `refreshProducts`: "상품을 새로고침한다" - 무엇을(What) 하는지 명확해진다.
   - `showProducts`: "상품을 보여준다" - 작업의 의도가 드러난다.
2. 의도가 명확히 드러난다. 인터페이스에 내부 구현은 숨기고 무슨 역할을 하는지만 드러낸다. (책임 중심적 사고가 가능해진다.)
   - 각 메서드가 협력 안에서 맡은 책임을 표현할 수 있다.
   - `refreshProducts` → 데이터 갱신 책임
   - `showProducts` → 표현 책임
   - `handleRefreshRequest` → 사용자 요청 처리 책임
3. 협력 관계가 명확해진다.

   ```tsx
   const handleRefreshRequest = () => {
     refreshProducts();  *//* "새로고침 요청" → "상품 새로고침" 위임
   };
   ```

## **명령-쿼리 분리**

BadCase

```tsx
function Counter() {
  const [count, setCount] = useState(0);

  const incrementAndGet = () => {
    const newCount = count + 1;
    setCount(newCount);
    return newCount;
  };

  const getCountWithLog = () => {
    console.log("카운트 조회");
    return count;
  };

  return (
    <div>
      <p>현재 카운트: {getCountWithLog()}</p>
      <button
        onClick={() => {
          const newValue = incrementAndGet();
          alert(`새로운 값: ${newValue}`);
        }}
      >
        증가
      </button>
    </div>
  );
}
```

1. 예측이 불가능하다.
   1. 호출자가 `incrementAndGet()`를 호출할 때, 단순히 값을 얻으려고 했는데 상태까지 바뀌는 부수효과가 발생한다.
   2. “읽기”라고 생각한 것이 사실은 “쓰기” 역할을 겸하고 있다.
2. 의도가 불명확하다.
   1. 메서드 이름에 “increment”와 “get”이 모두 들어있어 “이게 상태를 바꾸는 건지, 값을 조회하는 건지” 즉시 파악하기 어렵다.
3. 재사용이 어렵다.
   1. 만약 단순히 현재 값만 필요해도 `incrementAndGet()`를 쓰면 카운트가 의도치 않게 변경된다.
   2. 로직 재사용을 위해 비슷한 함수를 새로 만들어야 하는 중복 가능성 증가한다.

GoodCase

```tsx
function Counter() {
  const [count, setCount] = useState(0);

  const getCount = () => count;
  const isEven = () => count % 2 === 0;
  const isMaxReached = () => count >= 100;

  const increment = () => setCount((prev) => prev + 1);
  const decrement = () => setCount((prev) => prev - 1);
  const reset = () => setCount(0);
  const logAccess = () => console.log("카운트 조회");

  const handleCountClick = () => {
    increment();
    logAccess();

    if (isMaxReached()) {
      alert("최대값 도달!");
    }
  };

  return (
    <div>
      <p>현재 카운트: {getCount()}</p>
      <p>{isEven() ? "짝수" : "홀수"}</p>

      <button onClick={handleCountClick} disabled={isMaxReached()}>
        증가
      </button>

      <button onClick={decrement}>감소</button>
      <button onClick={reset}>리셋</button>
    </div>
  );
}
```

명령과 쿼리, 즉 부수효과와 단순 값을 반환을 구분함으로써 얻을 수 있는 이점은 다음과 같다.

1. 예측 가능성이 향상된다.
   1. 함수를 호출했을 때 읽기만 하는지 혹은 쓰기만 하는지를 이름과 시그니처로 바로 알 수 있다.
2. 의도 명확가 명확해진다.
   1. getCount()는 값 조회, increment()는 상태 변경이라는 것이 이름만 보고도 분명해진다.
3. 부작용이 최소화된다.
   1. 값을 가져오는 함수(쿼리)는 절대 상태를 변경하지 않으므로, 로직 실행 순서나 호출 횟수에 의한 부작용이 없다.
4. 재사용성 증가된다.
   1. 상태 변경과 조회 로직이 분리되어, 서로 다른 시나리오에서 필요한 기능만 가져다 쓸 수 있다.
