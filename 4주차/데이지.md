# 1. 명령 - 쿼리 분리

- **명령(Command)**: 객체 상태를 변경하는 행위
- **쿼리(Query)**: 객체 상태를 조회하거나 값을 반환하는 행위

명령과 쿼리가 하나의 메서드에서 혼합되면 예상치 못한 부작용이 발생하고, 코드의 예측 가능성과 유지보수성이 떨어진다.
따라서 명령과 쿼리를 명확히 분리하여, 상태 변경은 별도의 메서드에서 처리하고 조회 메서드는 순수하게 값을 반환하도록 설계하는 것이 좋다.

이 원칙을 따르면, 함수 호출이 예측 가능해지고, 테스트와 디버깅이 쉬워지며, 부수효과를 최소화할 수 있다.

## JavaScript에서의 명령과 쿼리 구분 예시

아래 예시는 로또 미션에서 로또 결과를 관리하는 `LottoResult` 클래스에서 명령과 쿼리가 섞여 있을 때 발생하는 문제의 코드이다.

---

### 수정 전 코드

```tsx
class LottoResult {
  constructor(lottoStatus, price) {
    this.lottoStatus = lottoStatus;
    this.price = price;
    this.winningHistory = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
  }

  getWinningHistory() {
    this.lottoStatus.forEach((status) => {
      this.winningHistory[status.RANK] += 1;
    });
    return this.winningHistory;
  }
}
```

- `getWinningHistory` 메서드가 상태 업데이트(명령)와 값 반환(쿼리)을 동시에 수행하고 있다.
- 이렇게 명령과 쿼리가 혼합되면, 메서드를 호출할 때마다 `winningHistory`가 누적되어 값이 계속 증가한다는 문제가 발생한다.

```tsx
lottoResult.getWinningHistory(); // { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1 }
lottoResult.getWinningHistory(); // { 1: 2, 2: 2, 3: 2, 4: 2, 5: 2 }
```

- 호출 횟수가 늘어날수록 `winningHistory`가 누적된 값이 반환된다.

---

### 수정 후 코드

```tsx
class LottoResult {
  constructor(lottoStatus, price) {
    this.lottoStatus = lottoStatus;
    this.price = price;
    this.winningHistory = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
    this.updateWinningHistory();
  }

  updateWinningHistory() {
    this.lottoStatus.forEach((status) => {
      this.winningHistory[status.RANK] += 1;
    });
  }

  getWinningHistory() {
    return this.winningHistory;
  }
}
```

- 상태 업데이트(명령)는 `updateWinningHistory` 메서드에 위임하여 한 번만 수행한다.
- 값 반환(쿼리)은 `getWinningHistory` 메서드에서 순수하게 `winningHistory`를 반환만 한다.
- 이로 인해 `getWinningHistory`를 여러 번 호출해도 반환값은 변하지 않고 일관성을 유지한다.

```tsx
lottoResult.getWinningHistory(); // { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1 }
lottoResult.getWinningHistory(); // { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1 }
```

## 리액트 관점의 명령-쿼리 분리

React는 함수형 프로그래밍 개념을 차용하지만, 근본적으로는 JavaScript라는 명령형 언어 위에서 동작한다.

따라서 명령-쿼리 분리(CQS) 원칙을 적용하면 참조 투명성의 장점을 제한적으로 누릴 수 있다.

자바가 그랬듯이 참조 투명성을 제한적으로 누리기 위해 리액트에서도 명령-쿼리 분리 원칙을 적용한 거 같았다.

- 명령(Command)은 상태 변경과 같은 부수 효과를 발생시키는 작업을 의미한다 (`setState` 호출 등).
- 쿼리(Query)는 현재 상태를 기반으로 UI를 계산하고 렌더링하는 작업을 의미한다 (JSX 반환).

React는 명령과 쿼리를 명확히 분리한다. 특히 UI를 그려내는 렌더링 함수는 참조 투명성을 가진 순수 함수여야 한다.

## 리액트 렌더링 순수성

React 공식 문서에는 “React의 렌더링 과정은 항상 순수해야 한다.”고 명시되어 있다.

즉, React 컴포넌트는 같은 입력(props, state)을 받으면 항상 같은 JSX(객체)를 반환하는 순수 함수여야 한다는 의미이다.

명령-쿼리 분리 원칙에 따라 컴포넌트의 렌더링을 순수하게 유지하지 않으면 부수효과가 발생한다.

여기서 부수효과란 호출 시마다 다른 화면을 표시하거나 외부 상태를 변경해 예측 불가능한 버그를 유발하는 것을 의미한다.

만약 JSX가 항상 같은 값을 반환하지 않는다면, 호출될 때마다 다른 JSX를 생성하게 되고, 이는 서로 다른 화면을 보여주거나 외부 상태를 변경하여 버그를 초래할 수 있다.

따라서 컴포넌트의 렌더링은 반드시 순수해야 한다.

입력(props)에 대해 항상 일정한 출력을 반환하며, 부수효과가 발생하지 않는다는 점에서 순수 함수라고 할 수 있다.

## 리액트에서의 부수효과

부수효과는 렌더링 과정 이외에서 발생할 수 있다. 대표적인 예시는 다음과 같다.

- **이벤트 핸들러**
  - 사용자 입력(클릭, 키 입력 등)에 반응하여 실행되며, 상태 변경이나 외부 API 호출 등 부수효과를 일으킨다.
  - 예를 들어 버튼 클릭 시 `setState`를 호출하거나 서버에 데이터를 전송하는 작업이 이에 해당한다.
- **`useEffect` 훅**
  - 컴포넌트가 렌더링된 이후에 실행되도록 설계된 훅으로, 네트워크 요청, 구독(subscription), 타이머 설정 등 부수효과 처리를 위해 사용한다.
  - 이 훅 내에서는 DOM 직접 조작이나 외부 라이브러리 연동도 가능하다.

이처럼 명령(부수효과)과 쿼리(렌더링)를 분리함으로써 제한적이나마 참조 투명성의 장점을 얻을 수 있다.

## 리액트에서의 참조 투명성

명령-쿼리 분리에 따른 장점은 다음과 같다.

### 1. 예측 가능성

순수한 렌더링은 동일한 입력에 대해 항상 동일한 출력을 보장하므로 컴포넌트의 동작을 예측하고 이해하기 쉬워진다. 순수하지 않은 컴포넌트는 호출될 때마다 다른 결과를 생성하거나 외부 상태를 변경하여 예측 불가능한 버그를 유발할 수 있다.

### 2. 최적화

입력이 변경되지 않았을 경우 렌더링을 건너뛰는 등의 최적화를 수행할 수 있다. `React.memo()` 와 같은 성능 최적화 기법은 props의 얕은 비교에 의존하는데, 컴포넌트가 순수해야 의미가 있다.

`count`가 변경돼도 `ItemList` 의 props(`items`) 참조는 동일하므로, 콘솔에 `Rendering ItemList` 가 **한 번만** 찍힌다.

### 3. 동시성

React 18에 도입된  [`useTransition`](https://github.com/reactwg/react-18/discussions/64) 과 같은 동시성 렌더링 기능은 렌더링 작업을 일시 중단하고 재개하거나 폐기할 수 있도록 한다. 순수한 함수는 언제든지 연산을 중단하고 재개하는 것이 안전하므로 이러한 동시성 기능을 효율적으로 구현할 수 있는 기반이 된다.

### 4. 서버 렌더링

순수한 컴포넌트는 서버 환경에서도 예측 가능하게 동일한 출력을 생성할 수 있으므로 서버 렌더링 및 초기 로딩 성능 향상에 유리하다.

# 2. 책임에 초점을 맞춘 설계

책임에 초점을 맞춰라를 접목시키기 위해 interface를 먼저 설계하라는 시지프의 수업을 떠올렸다.

- 메시지는 컴포넌트가 받아서 처리해야 할 동작이나 이벤트(=props로 전달되는 함수 또는 데이터)이다.
- 어떤 데이터를 어디서 받아올지보다 컴포넌트가 어떤 메시지를 받고 어떤 행동을 할지 먼저 정한다.
- 특히 공통 컴포넌트 설계 시 인터페이스(메시지)를 명확히 하면 재사용성과 확장성을 높일 수 있다.

```tsx
function Button({
  onClick,
  variant = 'primary',
  size = 'fit',
  customStyle,
  children,
  ...rest
}: PropsWithChildren<ComponentProps<'button'> & ButtonProps>) {
  return (
    <StyledContainer
      customStyle={customStyle}
      variant={variant}
      size={size}
      onClick={onClick}
      {...rest}
    >
      {children}
    </StyledContainer>
  );
}
```

- 메시지(`onClick`, `variant` 등 props들) 받아서 처리한다.
- 컴포넌트는 어떤 데이터 소스에서 왔는지 알지 못하고 관심도 두지 않는다.
- 메시지 처리에 집중해 역할과 책임을 명확히 한다.

```

```
