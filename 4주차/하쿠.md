## 6장 내용 장바구니 미션 중 OrderConfirmSection 컴포넌트에 적용해보기

거대한 `props`를 가진 `OrderConfirmSection` 컴포넌트를 '오브젝트'의 원칙에 따라 "자율적인 객체"로 만들어보는 리팩토링 과정을 공유하려고 합니다.

원래코드: 모든 것을 알고 있는 상위 컴포넌트와 수동적인 자식

먼저 리팩토링 전의 코드를 살펴보겠습니다.

```tsx
// OrderConfirmSectionProps 인터페이스
interface OrderConfirmSectionProps {
  itemsData: { ... };
  stateHandlers: { ... };
  priceInfo: { ... };
}

export default function OrderConfirmSection({ itemsData, stateHandlers, priceInfo }: OrderConfirmSectionProps) {
  // 상위 컴포넌트에서 계산된 모든 가격 정보와 상태 핸들러를 props로 받음
  const { setIsModalOpen, setIsIslandChecked, isIslandChecked } = stateHandlers;
  const { orderPrice, shippingFee, ... } = priceInfo;

  const handleCheckboxChange = () => setIsIslandChecked((prev) => !prev);
  // ...
}
```
'오브젝트'에서 지적하는 데이터 중심 설계의 특징을 보여줍니다.

수동적인 객체: OrderConfirmSection 컴포넌트는 스스로 할 수 있는 일이 거의 없습니다. 모든 계산된 값(priceInfo)과 상태를 변경하는 함수(stateHandlers)를 부모로부터 주입받아야만 동작할 수 있습니다.

캡슐화 위반: isModalOpen, isIslandChecked 같은 내부 UI 상태가 stateHandlers라는 이름으로 외부(부모 컴포넌트)에 그대로 노출되어 있습니다.

높은 결합도: 부모 컴포넌트는 OrderConfirmSection을 렌더링하기 위해 주문 금액, 배송비, 할인 금액 등 모든 것을 직접 계산하고, 모달과 체크박스 상태까지 관리해야 합니다. OrderConfirmSection의 작은 UI 변경이 부모 컴포넌트의 수정을 야기할 수 있습니다.

한마디로, OrderConfirmSection은 자율성이 없고 부모에게 심하게 의존하는 객체라고 할 수 있습니다.

리팩토링: 컴포넌트에 '책임'을 부여하기
이제 OrderConfirmSection을 **"주문 확인에 대한 모든 책임을 수행하는 자율적인 객체"**로 만들어 보겠습니다. 핵심은 책임의 이동입니다. 외부(부모)에 흩어져 있던 책임들을 OrderConfirmSection 안으로 가져옵니다.

1. 책임과 상태의 캡슐화
가장 먼저, UI 상태를 컴포넌트 내부에서 useState로 관리하여 외부로부터 캡슐화합니다. 가격 계산과 같은 핵심 로직도 내부로 가져옵니다. 계산 로직이 복잡하다면, 높은 응집도를 위해 별도의 커스텀 Hook(useOrderCalculations)으로 분리할 수 있습니다.
```TypeScript
// 가격 계산 책임을 위임받은 커스텀 Hook (높은 응집도)
function useOrderCalculations(items, selectedItemIds, isIslandChecked) {
  // ... 모든 가격 계산 로직이 여기에 캡슐화됩니다.
  const orderPrice = ...;
  const shippingFee = ...;
  const totalPrice = ...;

  return { orderPrice, shippingFee, totalPrice, ... };
}

// 메인 컴포넌트
export default function OrderConfirmSection({ initialItems, selectedItemIds, onConfirm }) {
  // 캡슐화: UI 상태를 내부에서 직접 관리합니다.
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isIslandChecked, setIsIslandChecked] = useState(false);

  // 책임 위임: 계산 책임을 Hook에 맡깁니다.
  const { ... } = useOrderCalculations(initialItems, selectedItemIds, isIslandChecked);
  // ...
}
```

2. 명확하고 단순한 인터페이스(Props)
컴포넌트의 props는 객체의 "퍼블릭 인터페이스"입니다. 이제 OrderConfirmSection은 자신의 책임을 수행하는 데 필요한 최소한의 데이터만 요구합니다.
```TypeScript
// Before
interface OrderConfirmSectionProps {
  itemsData: { ... };
  stateHandlers: { ... };
  priceInfo: { ... };
}

// After: 훨씬 단순하고 명확해진 인터페이스
interface OrderConfirmSectionProps {
  initialItems: CartItemsResponse;
  selectedItemIds: number[];
  onConfirm: (paymentInfo: object) => void;
}

```

3. 외부와의 협력: "묻지 말고 시켜라"
리팩토링 후, 부모는 자식의 상태를 묻지 않습니다. 그저 initialItems를 주며 "주문 확인 화면을 그려줘"라고 시키는 것입니다.

모든 과정이 끝나고 사용자가 "결제하기" 버튼을 누르면, OrderConfirmSection은 onConfirm 콜백 함수를 호출하여 계산된 최종 정보를 부모에게 알려줍니다.
```TypeScript
// 부모는 자식의 상태를 묻지 않고, 행동(onConfirm)만 주입합니다.
const handleConfirm = () => {
  onConfirm({ totalPrice, orderPrice, ... }); // 계산된 결과를 외부에 알림
};

return (
  // ...
  <button onClick={handleConfirm}>결제하기</button>
  // ...
);
```

리팩토링 코드: 자율성을 되찾은 컴포넌트
최종적으로 개선된 OrderConfirmSection 컴포넌트입니다.
```TypeScript
// 전체 리팩토링 코드 (위 본문 참고)
export default function OrderConfirmSection({ initialItems, selectedItemIds, onConfirm }) {
  // 1. 상태 캡슐화
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isIslandChecked, setIsIslandChecked] = useState(false);

  // 2. 책임 위임 (계산)
  const { ... } = useOrderCalculations(initialItems, selectedItemIds, isIslandChecked);

  // 3. 행동 캡슐화
  const handleCheckboxChange = () => setIsIslandChecked((prev) => !prev);
  const handleCouponButtonClick = () => setIsModalOpen(true);
  const handleConfirm = () => {
    onConfirm({ totalPrice, ... });
  };
  
  // 4. UI 렌더링
  return (
    // ...
  )
}
```


결론
6장에서의 내용을 적용하여 다음과 같은 이점을 확인할 수 있었습니다.

향상된 재사용성: 이제 OrderConfirmSection은 부모의 복잡한 구현에 의존하지 않으므로, 어떤 페이지에서든 쉽게 재사용할 수 있습니다.

쉬운 유지보수: 주문 확인과 관련된 로직을 수정해야 할 때, 우리는 OrderConfirmSection과 useOrderCalculations Hook만 살펴보면 됩니다. 부모 컴포넌트를 건드릴 필요가 없습니다.

명확한 책임: 각 컴포넌트와 Hook이 어떤 책임을 지는지 명확해져 코드를 이해하기 훨씬 쉬워졌습니다.

단순히 UI를 그리는 것을 넘어, 각 컴포넌트를 역할과 책임을 가진 자율적인 객체로 바라보는 것만으로도 코드의 품질을 한 단계 끌어올릴 수 있습니다.
