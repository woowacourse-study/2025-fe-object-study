# 6장 메시지와 인터페이스

**객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성**한다.

> 컴포넌트의 경우 props가 메시지
> props가 컴포넌트의 퍼블릭 인터페이스를 구성한다고 볼 수 있다.

## 협력과 메시지

### 클라이언트 - 서버 모델

객체는 2가지 종류의 메시지 집합으로 구성된다.

- 객체가 수신하는 메시지의 집합
- 외부의 객체에게 전송하는 메시지의 집합

두 객체 사이의 **협력을 가능하게 해주는 매개체가 바로 메시**지다.

### 메시지와 메시지 전송

한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송(message sending)이라고 한다.

메시지를 전송하는 객체를 메시지 전송자(message sender)

메시지를 수신하는 객체를 메시지 수신자(message receiver)

메시지는 오퍼레이션명(operation name)과 인자(argument)로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것.

- 메시지 전송은 **메시지 수신자, 오퍼레이션명,인자**의 조합

- isSatisfiedBy(screening)이 ‘메시지’이고, 여기에 메시지 수신자인 condition을 추가한 condition.isSatisfiedBy(screening)이 ‘메시지 전송’이다.

**메시지 전송자는 클라이언트, 메시지 수신자는 서버**

condition.isSatisfiedBy(screening) = 서버.메시지

---

> 그렇다면 프론트엔드 관점에서 무엇이 클라이언트고 서버일까?
> 메시지 흐름으로 해석해봤다.

#### 메시지 흐름으로 해석 (개인적 생각)

- **하위 컴포넌트 → 상위 컴포넌트**  
   하위 컴포넌트가 “이 상태 좀 바꿔주세요”라는 요청을 **핸들러 함수 호출**로 보냄 → 이게 **메시지 전송**.
  - 하위 컴포넌트 = **메시지 전송자(클라이언트)**
  - 상위 컴포넌트 = **메시지 수신자(서버)**
- **상위 컴포넌트 → 하위 컴포넌트**  
   렌더링 시 props로 상태나 데이터를 내려주는 건 “결과 응답”에 해당.
  - 이건 서버가 클라이언트에 데이터 제공하는 것과 비슷한 흐름.

##### 정리

- **상위 컴포넌트 = 서버**
  - 상태(데이터) 보관
  - 외부 요청(핸들러 호출이 됨)에 따라 상태 변경
  - 변경된 데이터 다시 내려줌
- **하위 컴포넌트 = 클라이언트**
  - 직접 데이터 변경은 못함
  - 서버에 “이거 좀 해줘” 하고 메시지를 보냄 (핸들러 호출이 되었다고 알림)
  - 받은 데이터를 UI로 표시

---

퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션

오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화.
메시지를 수신했을 때 실제로 실행되는 코드는 메서드.

**오퍼레이션은 추상화.**
**메서드는 오퍼레이션에 대한 구현.**

**시그니처 = 오퍼레이션의 이름 + 파라미터 목록**

---

> 프론트엔드 관점에서 퍼블릭 인터페이스는 뭘까?

#### 컴포넌트 예시로 보는 퍼블릭 인터페이스(개인적 생각)

```tsx
// 퍼블릭 인터페이스
interface BaseCoupon {
  calculate: (coupon: CouponType) => void // 시그니처
  isValid: Boolean // props
  coupon: CouponType // props
}

function BaseCoupon(calculate, isValid, coupon) {
  if (!isValid) {
    return false
  }
  //...
}
```

> \*\*내가 생각하는 퍼블릭 인터페이스(props) 는
> 시그니처(오퍼레이션 + 파라미터) + 다른 props(데이터) 인 것 같다.

---

## 인터페이스와 설계 품질

좋은 인터페이스는 **최소한의 인터페이스와 추상적인 인터페이스**

퍼블릭 인터페이스의 품질에 영향을 미치는 다음과 같은 원칙과 기법

1. 디미터 법칙
2. 묻지 말고 시켜라
3. 의도를 드러내는 인터페이스
4. 명령-쿼리 분리

### 디미터 법칙

- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 법칙을 의미한다. 
  **낯선 자에게 이야기하지 마라 + 인접한 이웃하고만 말하라**

> 프론트엔드에서 컴포넌트는 필요한 데이터만 받도록 하는 게 디미터 법칙을 준수하는 것 같다.
> props로 받은 객체를 어떻게 사용하느냐 가 중요한 것 같다.
> 구조분해 해서 꺼내서 쓰면 되는 걸까?
>
> ✅ **객체를 통째로 props로 넘겨도 괜찮은 것 같다.**
> ❌ **그 객체의 내부에 있는 또 다른 객체에 깊숙이 접근(체인 호출)하면 안 되는 것 같다.**

```tsx
// Bad Case
export interface BaseCoupon {
  id: number;
  code: string;
  data: {
	  description: string;
	  expirationDate: string; // YYYY-MM-DD
	  discountType: "fixed" | "buyXgetY" | "freeShipping" | "percentage";
  }
}

function CommonCoupon({ coupon, ... }) {
	const { description, expirationDate, data } = coupon;
	// ...
	return <Styled.Title>{data.description}</Styled.Title>;
}
```

```tsx
// Good Case
export interface BaseCoupon {
  id: number;
  code: string;
  description: string;
  expirationDate: string; // YYYY-MM-DD
  discountType: "fixed" | "buyXgetY" | "freeShipping" | "percentage";
}

function CommonCoupon({ coupon, ... }) {
	const { description, expirationDate } = coupon;
	// ...
	return <Styled.Title>{description}</Styled.Title>;
}
```

### 묻지 말고 시켜라

디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.

묻지 말고 시켜라(Tell, Don’t Ask)는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다.

내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하는가?
그렇다면 해당 **객체가 책임져야 하는 어떤 행동이 객체 외부로 누수**된 것이다.

**상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함**으로써 인터페이스를 향상시켜라.

객체가 어떻게 작업을 수행하는지를 노출해서는 안 된다.
**인터페이스는 객체가 어떻게 하는지가 아니라 무엇을 하는지를 서술해야 한다**.

### 의도를 드러내는 인터페이스

메서드를 명명하는 두 가지 방법

1. **어떻게 수행**하는지를 나타내도록 이름 짓는 것.
   - 메서드의 이름이 내부의 구현을 노출.
2. **무엇을 수행**하는지를 나타내도록 이름 짓는 것.
   - 내부의 구현을 노출하지 않는다.

#### 협력, 행동(책임), 상태로 보는 컴포넌트 간의 좋은 인터페이스 (매우 개인적인 생각)

명확한 정답은 없는 것 같다.
어떤 관점으로 보느냐에 따라 달라지는 것 같다.
특히 컴포넌트는 UI 렌더링 및 비즈니스 로직을 전부 담고 있기 때문에 더더욱 정답이 없는 것 같다.

어떻게 보다는 무엇을 이 중요하다고 하지만, 직관에 의한 명확함이 필요한 경우 어떻게가 드러나는 경우가 더 좋을 때가 있는 것 같다.
반대로 유연함이 필요할 때는 무엇을 드러내는 게 훨씬 중요한 것 같기도 하다.

##### 상위/하위 컴포넌트 인터페이스 네이밍 비교

| 구분                        | 네가 받은 답변                                                                                    | 내가 수정한 버전                                                                                                                                                         |
| --------------------------- | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **상위 컴포넌트 관점**      | **무엇을** 중심<br>예: `handleApplicationStatusUpdate`<br>비즈니스 로직 목적을 이름에 포함.       | ✅ 동일 — 상위는 **무엇을** 중심.<br>다만 UI 의존어(`handleActionButtonsClick`)는 지양.<br>예: `updateApplicationStatus`, `refreshProducts`                              |
| **하위 컴포넌트 관점**      | **어떻게**(UI 이벤트) 중심이 좋다고 함.<br>예: `onActionButtonsClick`<br>UI 구현 세부사항을 노출. | ❌ 수정 — 하위도 **무엇을** 중심.<br>다만 "요청/이벤트 발생" 관점에서 네이밍.<br>UI 세부사항(버튼, 클릭 등)은 숨김.<br>예: `onStatusUpdateRequest`, `onRefreshRequested` |
| **'묻지 말고 시켜라' 해석** | UI 이벤트 이름에 구현 세부사항을 포함해도 캡슐화 강화된다고 설명.                                 | 수정 — 구현 세부사항이 드러나면 캡슐화 약화 가능성 ↑.<br>메시지(함수명)는 가능한 한 도메인 의미로 추상화.                                                                |
| **유연성**                  | 하위 네이밍이 UI에 고정될 수 있음 (버튼 → 다른 UI 변경 시 이름 변경 필요).                        | 하위 네이밍이 UI 변경에도 유지됨 (버튼→드롭다운 변경 시 그대로 사용 가능).                                                                                               |
| **예시 종합**               | 하위: `onActionButtonsClick`<br>상위: `handleApplicationStatusUpdate`                             | 하위: `onStatusUpdateRequest`<br>상위: `updateApplicationStatus`                                                                                                         |
