## 개요

역할, 책임, 협력에 관해 이야기한다. 이 중 객체의 책임에 관해서 인상깊게 읽어서 리액트 컴포넌트를 나누는 기준을 "컴포넌트가 수행해야 하는 하나의 책임" 으로 생각해 볼 것이다.

## 책임

협력에 참여하기 위해 객체가 수행하는 행동을 **책임** 이라고 부른다.

책임은 하는것과 아는 것 두가지로 나뉜다.

**하는 것**

- 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
- 다른 객체의 행동을 시작시키는 것
- 다른 객체의 활동을 제어하고 조절하는 것

**아는 것**

- 사적인 정보에 관해 아는 것
- 관련된 객체에 관해 아는 것
- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

위의 것들을 토대로 책임에 관련되 이야기를 더 해보겠다?

### 작은 책임들의 상호작용으로 더 큰 책임을 수행

페이먼츠 미션에서 CardForm 컴포넌트는 "카드 정보를 입력 받는" 책임이 있다. 여기서 입력값을 검증해주는 훅의 리턴값들이 있다.
onChangeCardValidityPeriod, onChangeCardCVC, onChangeCardPassword

이 세가지를 props로 받아서 서로 협력한다. 그러면 CardForm은 카드 정보를 입력받는 책임만 있었는데 props로 저것들을 받아서 검증하는 책임까지 더해져서 "카드 정보를 입력받고 검증하는 책임"이라는 큰 책임으로 확장된다.

- 원래 `CartForm의 책임: 입력 폼 렌더링 및 이벤트 수집
- 훅의 리턴값을 props로 주입받은 이후 `CardForm`의 확장된 책임: **입력값을 받아서 검증 함수와 협력하여 상태 갱신 및 검증 흐름 제어**

```
  const { cardNumber, onChangeCardNumber } = useCardNumber(onChangeStep);
  const { cardValidityPeriod, onChangeCardValidityPeriod } =
    useCardValidityPeriod(onChangeStep);
  const { cardCVC, onChangeCardCVC } = useCardCVC(onChangeStep);
  const { cardPassword, onChangeCardPassword } = useCardPassword();

  ...

  return (
    <AppLayout>
      ...
      <CardForm
        {...cardInfo}
        onChangeCardNumber={onChangeCardNumber}
        handleChangeCardCompany={handleChangeCardCompany}
        onChangeCardValidityPeriod={onChangeCardValidityPeriod}
        onChangeCardCVC={onChangeCardCVC}
        onChangeCardPassword={onChangeCardPassword}
      />
```

이렇게 작은 책임을 가진 객체들이 협력해 더 큰 책임을 수행해 나가는 것을 볼 수 있다.

## 책임을 생각한 컴포넌트 확장 - 단순 스타일 확장

장바구니 미션에서 아래 사진과 같이 css를 조금만 수정하면 ProductItem 컴포넌트를 하나로 사용할 수 있었다.

![alt text](image.png)

이 컴포넌트의 props로 isRow를 추가해서 이 값에 따라 스타일을 변경해주는 식의 확장을 했다.

```
<ProductItem isRow={true} />
```

이렇게 분리를 해도 되는 이유는 두가지이다.

- Props 목적: 단순한 시각적 표현 변경 (레이아웃 분기)
- 책임 변화 없음: UI 구조/데이터 처리 책임 변화 없음

## 책임을 생각한 컴포넌트 확장 - 확장하지 못하는 사례

<사진 추가 필요>

아래처럼 `<details>`와 `<summary>` 태그를 이용해 GitHub README용 토글로 감싸면 됩니다:

<details>
<summary>원본 코드</summary>

```tsx
interface BaseProps {
  id: number;
  imageUrl: string;
  name: string;
  price: number;
  quantity: number;
}

interface ControlProps extends BaseProps {
  mode: 'control';
  onChange: () => void;
  isFetching: boolean;
}

interface InfoProps extends BaseProps {
  mode: 'info';
  onChange?: () => void;
  isFetching?: boolean;
}

type CartProductProps = ControlProps | InfoProps;

export function CartProduct({
  id,
  imageUrl,
  name,
  price,
  quantity,
  onChange,
  isFetching,
  mode,
}: CartProductProps) {
  return (
    <div
      id={`cartProduct-${id}`}
      aria-label={`${id} 항목`}
      css={CartProductLayout}
      data-testid="cart-product"
    >
      <div css={ProductImg(imageUrl)} />
      <div css={TitleLayout}>
        <p css={ProductName}>{name}</p>
        <p css={ProductPrice}>{price.toLocaleString()}원</p>
        {mode === 'control' ? (
          <QuantitySelector
            quantity={quantity}
            cartId={id}
            onChange={onChange}
            isFetching={isFetching}
          />
        ) : (
          <p css={quantityText}>{quantity}개</p>
        )}
      </div>
    </div>
  );
}
```

</details>

이런 경우 책임이 두가지가 된다.

1. 수량을 조절이 가능한 상품 아이템
2. 수량을 나타내는 상품

작은 책임을 가진 하나의 객체가 다른 객체와 서로 상호작용하며 큰 책임을 수행해나가는 것과 반대로 하나의 객체에서 많은 책임을 수행하는 것을 볼 수 있다.

### 작은 책임으로 분리

1. 공통 레이아웃 분리

```
function CartProductLayoutBase({ id, imageUrl, name, price, children }: PropsWithChildren<BaseProps>) {
  return (
    <div id={`cartProduct-${id}`} aria-label={`${id} 항목`} css={CartProductLayout} data-testid="cart-product">
      <div css={ProductImg(imageUrl)} />
      <div css={TitleLayout}>
        <p css={ProductName}>{name}</p>
        <p css={ProductPrice}>{price.toLocaleString()}원</p>
        {children}
      </div>
    </div>
  );
}
```

2. 책임별로 컴포넌트 분리

```
export function CartProductControl({
  id,
  imageUrl,
  name,
  price,
  quantity,
  onChange,
  isFetching,
}: ControlProps) {
  return (
    <CartProductLayoutBase id={id} imageUrl={imageUrl} name={name} price={price}>
      <QuantitySelector
        quantity={quantity}
        cartId={id}
        onChange={onChange}
        isFetching={isFetching}
      />
    </CartProductLayoutBase>
  );
}

export function CartProductInfo({
  id,
  imageUrl,
  name,
  price,
  quantity,
}: InfoProps) {
  return (
    <CartProductLayoutBase id={id} imageUrl={imageUrl} name={name} price={price}>
      <p css={quantityText}>{quantity}개</p>
    </CartProductLayoutBase>
  );
}
```

이렇게 3개의 컴포넌트로 분리하면 하나의 책임을 담당하는 컴포넌트가 된다.
이처럼 **조건 분기 로직이 생기기 시작햇을 때** 컴포넌트를 나눌 시점이구나 라는 생각을 해보면 좋을 거 같다.

### 결론

책임의 관점에서 컴포넌트를 바라보며 예전에 짰던 컴포넌트들을 다시 생각해 볼 수 있는 시간이어서 좋았다. 단순히 컴포넌트를 재사용하는 것이 좋은 컴포넌트 설계라고 생각했는데 책임에 맞게 작게 나누어 컴포넌트를 분리할 수 있다면 유지보수성에 더 좋은 설계가 될 거 같다.
