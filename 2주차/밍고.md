## 개요

오브젝트의 3장에선 객체지향 패러다임 중 중요한 요소로 꼽히는 역할, 책임, 협력을 소개한다. 해당 내용을 살펴보면 직접적인 구현과는 상관없이 자율적인 객체라는 개념 자체를 어필한다. 그렇기에 객체지향 패러다임은 이론상 클래스 기반 언어 뿐만 아니라 프로토타입 기반 언어인 자바스크립트에서도 충분히 적용할 수 있다.

하지만 개인적으론 실제 프론트엔드 코드를 짜면서 객체지향적인 사고를 하기 어려웠다. 또한 많은 사람들은 객체지향 프로그래밍을 마치 백엔드 혹은 자바에만 적용할 수 있는 개념으로만 생각하곤 한다.

## 왜 프론트엔드에선 객체지향 패러다임을 적용하기 어려울까?
![react 페이지](https://github.com/user-attachments/assets/f159abed-3a27-4028-b655-40211dc27aff)

프론트엔드의 개발은 오늘날 대부분 리액트 환경에서 진행된다. 공식문서 첫 문장에도 소개되듯 리액트는 컴포넌트를 이용해 앱을 만든다. 이 컴포넌트 위주의 사고가 객체지향 프로그래밍을 하기 어렵게 하는 요소 중 하나이다.

물론 컴포넌트를 객체로 바라보면 리액트로 만든 앱은 객체지향적으로 잘 짜여진 형태이다. 리액트의 한 페이지 안에는 많은 컴포넌트(객체)가 있고, 이 컴포넌트들의 협력은 하나의 페이지의 모든 기능을 만든다. 또한 컴포넌트는 각자의 책임이 뚜렷이 있고 이 책임을 수행하기 위한 자율적인 요소로 구성되어 있다.

### 리액트의 컴포넌트 중심 개발

우리가 하나의 서비스를 만든다고 생각해보자. 예시를 위해 행성이 페이지 화면을 가져왔다.

![행성이](https://github.com/user-attachments/assets/8c198522-9819-4cd6-a7a3-76bb650d17e5)

이 서비스를 만들기 위해 보통 우리가 맨 처음 하는 일은 무엇일까? 바로 컴포넌트를 분리하는 작업일 것이다.

![컴포넌트분리](https://github.com/user-attachments/assets/f9ba2529-46b8-49f7-a9cd-d536d4ee6b2c)

즉 우리는 객체(컴포넌트)를 먼저 만들고 그다음 해당 객체에 기능을 불어넣는 방식으로 전체적인 협력을 구상한다. 이는 오브젝트 3장에서 소개하는 "책임 주도 설계"의 관점에선 잘못된 접근이다.

"책임 주도 설계"의 전반적인 순서는 다음과 같다.

1. 협력을 위해 필요한 메시지를 먼저 식별한다.
2. 식별한 메시지를 처리할 수 있는 적절한 객체를 부여한다.
3. 이어서 필요한 메시지를 식별하고, 적절한 객체를 그에 맞춰 찾아 부여한다...

핵심은 필요한 메시지를 먼저 식별하고 객체를 이에 맞춰 찾아나간다는 것이다. 하지만 리액트에선 컴포넌트 위주로 접근하는 것이 직관적이다. 따라서 필요한 메시지를 식별하기 전에 객체(컴포넌트)를 먼저 정의한다. 그렇기에 책임 주도 설계의 전반적인 순서에 공감을 하지 못한다. 책임보단, 객체 그 자체에 집중하게 된다.

## 컴포넌트 관점으로 바라본 위성이

메시지 관점으로 먼저 바라보면 어떤 설계를 할 수 있을까? 이를 알아보기 위한 하나의 예시로 위 서비스의 위성이 컴포넌트를 가져왔다.

https://github.com/user-attachments/assets/66add26c-eea6-4e68-920d-e2d2824240fd

컴포넌트로 위성이를 먼저 바라본다면 우선 Satellite라는 리액트 컴포넌트를 만들 것이다.

```tsx
import * as S from "./Satellite.styles";

interface SatelliteProps {
  size: number;
  name: string;
}

const Satellite = ({ size, name }: SatelliteProps) => {
  return (
    <S.Container size={size}>
      <S.BodyImage src={`/satellite/${name}.png`} alt="위성이" />
    </S.Container>
  );
};

export default Satellite;
```

다음으로 궤도를 따라 이동하는 기능을 추가하기 위해, 커스텀 훅으로 Container의 x, y, zIndex를 지정한다. 자체적으로 회전하는 요소이므로 animate 속성도 이용했다.

```tsx
import * as S from "./Satellite.styles";
import useOrbitalMoving from "./hooks/useOrbitalMoving"

interface SatelliteProps {
  size: number;
  name: string;
  center: {x: number, y: number};
  radius: number;
}

const Satellite = ({ size, name, center, radius }: SatelliteProps) => {
  const {x, y, zIndex} = useOrbitalMoving(center, radius);

  return (
    <S.Container size={size} style={{ x, y, zIndex }} 
      animate={{
        rotate: "360deg",
        transition: {
          ease: "linear",
          duration: 10,
          repeat: Infinity,
        },
      }}>
      <S.BodyImage src={`/satellite/${name}.png`} alt="위성이" />
    </S.Container>
  );
};

export default Satellite;
```

이렇게 컴포넌트와 커스텀 훅이라는 객체들의 협력을 이용해 위성이를 구현할 수 있었다. 컴포넌트는 위성이의 위치와 형체를 담당하고, 커스텀 훅은 위성이가 어떻게 움직일지 도메인 로직을 가지고 있다. 하지만 위 구조엔 몇 가지 꺼림칙한 면이 있다.

- 위성이의 props에 궤도의 중앙 정보와 반경을 받도록 추가된다.
- 위성이가 아니라 다른 요소가 돌도록, 혹은 위성이를 가만히 있도록 요구사항이 변경되면 이를 반영하기 어렵다.

## 책임 관점으로 바라보면 어떨까?

그렇다면 책임 관점으로 위성이를 바라보면 어떨까? 위성이가 가져야 할 메시지를 나열해보자.

- 위성이는 표시된다.
- 위성이는 궤도를 따라 움직인다.

다음으로 메시지를 처리할 수 있는 적절한 객체를 할당한다.

- 위성이는 표시된다. -> Satellite
- 위성이는 궤도를 따라 움직인다. -> OrbitalMoving

둘 다 UI적으로 표시할 책임이지만, 자체적으로 표시되는 책임과 궤도를 따라 움직이는 책임을 따로 본다면 이 둘을 다른 컴포넌트로 구현해봐야겠다는 생각을 할 수 있었다. 이렇게 구현한 코드는 다음과 같다.

```tsx
import * as S from "./Satellite.styles";

interface SatelliteProps {
  size: number;
  name: string;
}

const Satellite = ({ size, name }: SatelliteProps) => {
  return (
    <S.Container size={size}>
      <S.BodyImage src={`/satellite/${name}.png`} alt="위성이" />
    </S.Container>
  );
};

export default Satellite;
```

```tsx
import * as S from "./OrbitalMoving.styles";

interface OrbitalMovingProps {
  center: { x: number; y: number; zIndex?: number };
  radius: { x: number; y: number };
  children: React.ReactNode;
  speed?: number; // 초당 회전 속도 (deg/sec)
  initialAngle?: number; // 시작 각도
  initialOrbitRotationAngle?: number; // 타원 기울기 초기 각도 (deg 단위)
  orbitRotationSpeed?: number; // 타원 기울기 변화 속도 (deg/sec)
}

const OrbitalMoving = ({
  center,
  radius,
  children,
  speed = 30,
  initialAngle = 0,
  initialOrbitRotationAngle = 0,
  orbitRotationSpeed = 5,
}: OrbitalMovingProps) => {

  // 대충 x, y, zIndex 구하는 로직 ~~
  const x = ~~
  const y = ~~
  const zIndex = ~~

  return (
    <S.Container
      style={{ x, y, zIndex }}
      animate={{
        rotate: "360deg",
        transition: {
          ease: "linear",
          duration: 10,
          repeat: Infinity,
        },
      }}
    >
      {children}
    </S.Container>
  );
};

export default OrbitalMoving;
```

OrbitalMoving 컴포넌트는 도는 기능에만 집중하여 구현했다. 실제로 돌 요소는 children으로 받는다. 이렇게 구현하니 여러 장점이 있었다.

- 분리가 되어 있으므로 도메인에 집중한 props를 받을 수 있었다. 따라서 center, radius뿐만 아니라 속도, 시작 각도, 타원의 회전 속도 등 더 세밀한 조작이 가능하다.
- children에 들어오는 요소를 바꾸기만 하면 쉽게 도는 요소를 변경할 수 있다. 또한 위성이와 도는 로직 간 의존성이 완전히 분리되어서, 위성이 단독으로 요소를 불러올 수 있었다.

  ```tsx
  <OrbitalMoving
    center={{ x: 0, y: 0, zIndex: 13 }}
    radius={{ x: 200, y: 80 }}
    speed={50}
    initialAngle={0}
    initialOrbitRotationAngle={-30}
  >
    <Satellite name={selectedSatellite.name} size={80} />
  </OrbitalMoving>
  ```

https://github.com/user-attachments/assets/86672a53-56e0-4256-902f-4bfe6317345c

## 결론

리액트에선 컴포넌트를 이용해 UI를 구성하고 있다. 프론트엔드 개발자로서 컴포넌트의 구조를 잘 구성하고, 깔끔한 컴포넌트를 만드는 것은 중요하다. 이 때 책임 관점으로 서비스를 바라보면 다양한 시점으로 구조를 개선할 수 있지 않을까?


<details><summary><b>책 내용 정리(3장)</b></summary>

#### 협력

- 다양한 객체들이 한 기능을 구현하기 위해 메시지를 주고 받으며 상호작용

#### 책임

- 객체가 협력에 참여하기 위해 수행하는 로직

#### 역할

- 책임의 집합

### 협력

- 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법
- 메시지 전송 → 메서드 실행을 통해 협력한다.
  - 자율성: 객체는 메시지를 전달받으면 무엇을 할 지 스스로 결정해 반환한다.
- 객체의 자율성을 보장할 수 있다.
  - 내부 구현을 캡슐화하는 방식
  - 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청한다.
- 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 객체가 보유하고 있기 때문이다.
  - 행동을 결정하는 것은 객체가 함께하는 협력
  - 협력이 존재하기에 객체가 존재한다.
  - 객체의 상태는 행동이 결정한다.
- **객체를 설계하기 위해 필요한 문맥을 제공**한다.

### 책임

- 협력에 참여하기 위해 수행하는 행동
  - 하는 것 + 아는 것의 밀접한 연관
- **객체 지향 설계의 핵심은 객체에게 얼마나 적절한 책임을 할당하느냐**이다.
- 가장 잘 아는 사람에게 책임을 할당하자: 정보 전문가
  - 메시지를 먼저 식별하고, 나중에 메시지에 맞는 적절한 객체를 선택한다.
  - 협력에 필요한 메시지 찾기 → 메시지에 적절한 객체를 선택 → 반복…
  - 책임 주도 설계 → 책임을 분할하고 적절한 객체를 찾아 할당

#### 책임 할당의 고려 요소

- 메시지가 객체를 선택
  - 최소한의 인터페이스: 메시지가 식별될 때까지 추가되지 않는다.
  - 추상적인 인터페이스: 무엇을 수행할 지에 초점을 맞추는 인터페이스를 만든다.
    - “어떻게”가 아니다!
- **행동**이 상태를 결정
  - 객체의 상태가 아니라 행동에 집중
  - 어떤 걸 가져야지~가 아니라 이 객체는 어떤 행동을 해야지~로 결정

### 역할

- 책임의 집합
- **동일한 협력을 수행하는 객체들을 추상화시켜 중복을 줄일 수 있다.**
- 책임에 대한 대표자(역할)을 생각
  - 다른 것으로 교체할 수 있는 책임의 집합
  - 하나의 슬롯
  - 추상화 / 인터페이스 → 인터페이스 업캐스팅, 다형성, 늦은 바인딩, 상속 등등…
- 이 객체가 무슨 역할을 수행해야 하는가?를 생각해보자

### 객체와 역할의 차이?

- 하나의 슬롯에 하나의 객체만 있다면 객체로 혼용해도 무방하다.
- 하나의 슬롯에 여러 개의 객체가 들어갈 수 있다면 역할로 정의하자.
- 최대한 단순하게 객체로 먼저 정의하고, 복잡해져서 여러 개의 객체가 들어갈 수 있다면 역할로 정의하는 것이 좋다고 한다~

</details>

<details><summary><b>부록: 정리노트</b></summary>

![정리노트](https://github.com/user-attachments/assets/9162cfb3-c572-4f9f-a18d-e2ee0a64b735)

</details>
