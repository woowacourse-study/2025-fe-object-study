객체지향의 핵심은 복잡한 프로그램을 `협력하는 객체들의 공동체를 창조하는 것` 이라는 말에 영감을 받아, 이 글에서는 객체지향의 주요 개념들을 우테코라는 현실 공동체에 빗대어 쉽게 설명해보려고 합니다.

## 객체지향으로 바라본 우테코

### **시스템 =**= **공동체**

객체지향에서 시스템은 여러 객체들이 모여 협력하며 문제를 해결하는 공동체라고 소개하고 있습니다. 이 관점에서 봤을 때 우테코도 하나의 시스템이라고 느껴졌습니다.

- 다양한 크루들과 코치들이 모여
- 각자의 역할과 책임을 다하며
- 레벨별 미션이라는 문제를 함께 해결하고 있다.

결론적으로 우테코라는 공동체는 서로 협력하며 상호작용하는 객체들로 구성된 하나의 시스템이라는 생각이 들었습니다.

### 협력 == 메시지 전송을 통한 상호작용

책에서는 하나의 객체가 다른 객체에게 도움을 요청할 때 협력이 시작된다고 말하는데요. 저는 이 부분을 보며, 협력이 없다면 공동체 자체가 성립될 수 없기 때문에, 협력은 공동체를 구성하는 필수 조건이라는 생각이 들었습니다. 그리고 이 개념에서 가장 중요한 포인트는 바로, **“객체는 메시지를 처리할 방법을 스스로 선택한다”**는 점입니다.

처음에는 이 말이 잘 와닿지 않았는데요. 예를 들어 “10시에 등교하라”는 메시지를 받았을 때, 이를 어떻게 실행할지는 온전히 나에게 달려 있다는 뜻이었습니다. 자전거를 탈 수도 있고, 걸어서 갈 수도 있으며, 심지어 등교하지 않을 수도 있습니다. 즉, 메시지에는 반응하되, 그 방식은 객체가 자율적으로 결정한다는 점이 핵심입니다. 그리고 이것이 객체의 자율성을 보여주는 대표적인 특징이자, 객체 간 협력이 가능한 이유라고 생각합니다.

우테코를 예시로 바라본 객체간 협력은 다음과 같은데요.

- **코치 → 크루:** 미션 제출 요청
- **크루 → 크루**: 페어 프로그래밍 진행
- **크루 → 코치**: 원온원 신청

서로 정해진 역할 안에서 메시지를 주고받고, 각자가 자율적으로 이를 처리함으로써 협력이 이루어지고 있는 것입니다.

### **역할 =**= **맥락 속 정체성**

객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 **역할**이라고 책에서는 소개하는데요. 이는 같은 객체라도 맥락에 따라 다른 역할을 가질 수 있다는 의미입니다.

예를 들면, 같은 '세라'여도 우테코 크루로서는 10시에 등교하고, 10시 30분에 수업을 듣고, 월요일 1시에는 청소를 합니다. 하지만 집에서는 자식의 역할로, 집안일을 하고, 효도를 합니다. 즉 객체는 맡은 역할에 따라 다른 책임을 수행합니다. 따라서 역할과 책임은 고정된 것이 아니라 맥락에 따라 유동적이라는 점을 인지해야 합니다.

### 객체 == 크루/코치/리뷰어

객체는 시스템을 구성하는 자율적인 단위라고 책에서 소개합니다. 이 관점에서 볼 때, 우테코의 크루, 코치, 리뷰어는 각각 하나의 객체라고 볼 수 있습니다.

각자 고유한 상태를 가지고, 서로 다른 역할과 책임을 수행하며, 외부로부터 전달받은 메시지에 스스로 판단하고 반응하는 자율적인 존재입니다. 이런 자율성이 객체 지향의 핵심이라고 소개합니다. 자율성이 강조되는 이유는, 자신이 맡은 일을 다른 객체가 대신하게 될 경우 역할과 책임의 경계가 무너지고, 협력보다는 구현에 초점이 맞춰지기 때문입니다.

예를 든다면, 세라라는 크루가 수행해야 할 페어 프로그래밍을 다른 크루가 대신 해버린다면, 세라의 책임은 흐려지고 ‘누가 무엇을 해야 하는가’보다는 ‘어떻게 구현할 것인가’에만 집중하게 됩니다. 이는 객체 간 협력이라는 본질을 흐릴 수 있습니다.

### 책임 == **객체가 수행하는 행동**

책임은 아는 것과 하는 것으로 나눠지는데요.

**아는 것**은 자신이 관리해야 할 상태나 정보를 알고 있는 것을 의미합니다. 예를 들어, 코치 객체는 어떤 크루가 어떤 미션을 제출했는지를 알고 있어야 합니다. **하는 것**은 외부로부터 받은 메시지에 반응해 스스로 행동을 수행하는 것을 뜻합니다. 예를 들어, 미션에 대한 피드백을 주거나, 원온원 요청을 처리하는 행동이 이에 해당합니다.

이처럼 객체가 어떤 정보를 알고 있으며, 그에 따라 어떤 행동을 할 수 있는지를 명확히 하는 것은 **자율적인 협력에 참여하기 위한 기반**이 됩니다.

## 리액트에서 바라본 책임,역할,협력

### **CVCForm**

**역할**

CVC 입력 폼의 전체적인 흐름을 조율하는 컨트롤러

**책임**

- **아는 것**: CVC 입력의 전체 상태, 에러 정보, 유효성 검사 결과
- **하는 것**
  - 하위 컴포넌트들 간의 협력 조율
  - 입력 완료 시 다음 단계로 진행 신호 전송
  - CVC 폼 레이아웃 구성

### **useCardForm**

**역할**

카드 정보 전체의 상태 저장소

**책임**

- **아는 것**: 전체 카드 폼 데이터 (카드번호, 만료일, CVC 등)
- **하는 것**: 상태 업데이트 처리, 다른 컴포넌트에게 현재 상태 제공

### **useSingleCardInput**

**역할**

단일 입력 필드의 유효성 검사

**책임**

- **아는 것**: 현재 입력값, 유효성 상태, 에러 메시지
- **하는 것**:
  - 입력값 변경 처리
  - 실시간 유효성 검사
  - 유효할 때 자동으로 다음 단계 진행

### **Input, Text, CardInputLayout**

**역할**

각각의 UI 표현

**책임**

- **아는 것**: 자신만의 스타일링과 표현 방식
- **하는 것**: 사용자와의 직접적인 인터랙션 처리

## 협력 구조

### 메시지 흐름 분석

```jsx
const { formData, dispatch } = useCardForm(); // 1

const {
  state: CVCNumber,
  error,
  handleChange,
} = useSingleCardInput({
  // 2
  onValid: onNext, // 3
  setState: (cvc) => dispatch({ type: "CVC", payload: { ...formData, cvc } }), // 4
});

<Input onChange={handleChange} />; // 5
```

1. CVCForm → useCardForm: "현재 카드 데이터 줘”
2. CVCForm → useSingleCardInput: "CVC 입력 관리해줘"
3. CVCForm → useSingleCardInput: "유효하면 다음 단계로 가줘"
4. CVCForm → useSingleCardInput: "상태 업데이트해줘"
5. CVCForm → Input: "사용자 입력 받아줘"

### **자율성**과 **캡슐화**

```jsx
const {
  state: CVCNumber,
  error,
  handleChange,
} = useSingleCardInput({
  onValid: onNext,
});
```

`useSingleCardInput`은 스스로 유효성 판단 및 상태 관리를 수행하며, 외부에는 최소한의 인터페이스만 제공합니다. 이는 캡슐화가 잘 이루어져 있다는 의미이며, 객체의 자율성을 잘 보여준다고 생각합니다.

**as-is**

```jsx
setState: (cvc) =>
  dispatch({
    type: 'CVC',
    payload: { ...formData, cvc },
  }),
```

이 부분에서는 `CVCForm`이 상태 업데이트의 구체적인 구현까지 알고 있어, `useSingleCardInput`과 `useCardForm` 사이의 자율성이 떨어진다는 점이 아쉬웠습니다.

**to-be**

```jsx
const cardManager = useCardForm();

const {
  state: CVCNumber,
  error,
  handleChange,
} = useSingleCardInput({
  onValid: onNext,
  setState: cardManager.updateCVC,
});
```

이렇게 개선하면 CVCForm은 **“CVC를 업데이트해줘”**라는 메시지만 전달하고, 구체적인 처리 방식은 useCardForm 내부에서 스스로 판단하게 됩니다. 이는 각 객체가 자신의 책임과 역할에 집중할 수 있도록 돕고, 전체 구조의 자율성과 유연성을 높여준다고 생각합니다.

https://github.com/keemsebin/react-payments/blob/step-2/src/components/features/CardFormFiled/CVCForm.tsx
