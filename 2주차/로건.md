### 협력이 설계를 위한 문맥을 결정한다

객체란 **상태와 행동**을 함께 캡슐화하는 실행 단위다.
어떤 기준으로 객체가 가질 수 있는 상태와 행동을 결정해야 할까?

어떤 객체가 필요하다면 그 이유는 단 하나여야 한다. 그 객체가 어떤 **협력에 참여**하고 있기 때문이다.
그리고 객체가 협력에 참여할 수 있는 이유는 **협력에 적절한 행동을 보유**하고 있기 때문이다.

> 리액트에서 컴포넌트 또한 협력(애플리케이션의 기능)을 하고 있기 때문에 객체라고 볼 수 있을 것 같다.
> 컴포넌트를 마치 레고처럼 조합해서 UI를 구성하고 기능을 구성한다.
> 컴포넌트가 협력에 참여할 수 있는 이유는 협력에 필요한 행동(UI, 기능)을 보유하고 있기 때문이다.

협력이 바뀌면 제공하는 행동도 바뀌어야 한다.

협력이 객체의 행동을 결정한다.
객체의 행동이 상태를 결정한다.
객체는 상태와 행동을 갖는다.

협력 -> 행동 -> 상태

영화 예매 -> 영화 요금 계산 -> 요금 계산에 필요한 기본 요금과 할인 정책

협력이 행동과 상태를 결정하므로 문맥을 제공한다.

> 상태를 먼저 정하고 행동을 정하는 역순은 안된다. 상태에 맞춰 행동을 정하면 협력에 적절하지 못하게 된다.
>
> 1. 협력 -> 행동 -> 상태 // good
> 2. 상태 -> 행동 -> 협력 // bad
>
> 2번은 왜 나쁘지? 결국 도달하는 결과는 같아질 것 같은데?

#### "협력 -> 행동 -> 상태"의 역순이 안되는 이유 (개인적 생각)

##### 1. "협력 -> 행동 -> 상태" 와 "상태 -> 행동 -> 협력" 의 차이점

먼저 두 가지 접근 방식의 사고 흐름을 그림으로 표현해봤다.

**A. "협력 -> 행동 -> 상태" (객체지향적인 사고, RDD)**

```
             [외부의 요청/목표]
                     ↓
             어떤 객체들이 서로 '협력'해야 이 요청을 처리할 수 있을까?
             (예: 영화 예매 시스템이 예매 요청을 처리하려면, 영화 객체와 상영 객체가 협력해서 요금을 계산해야 해.)
                     ↓
             각 객체는 '협력'을 위해 어떤 '행동(책임)'을 해야 할까?
             (예: Movie 객체는 '영화 요금 계산'이라는 행동을 해야 해. Screening 객체는 '상영 정보 제공'이라는 행동을 해야 해.)
                     ↓
             각 '행동'을 수행하기 위해 어떤 '상태(데이터)'가 필요할까?
             (예: Movie의 '요금 계산' 행동을 위해선 '기본 요금'과 '할인 정책' 상태가 필요해.
                  Screening의 '상영 정보 제공' 행동을 위해선 '영화', '상영 순서', '상영 시간' 상태가 필요해.)
```

"협력 -> 행동 -> 상태" 순으로 진행 하면 다음과 같은 이점이 있는 것 같다.

1. 협력(기능)에 필요한 행동들을 작게 나눌 수 있다.
2. 행동들이 곧 책임이 되기 때문에 하나의 책임만 수행할 수 있도록 객체를 결정할 수 있다.
3. 객체가 협력에 필요한 행동을 하기 위한 상태(데이터)가 무엇이 필요한지 넣을 수 있다.
   1. 예매를 하기 위해선 예매하기, 요금 계산하기가 필요할 것 같아
   2. 영화의 요금을 계산 하기 위해서는 '기본 요금'과 '할인 정책'이 필요하겠네. 이 둘을 갖는 Movie 객체를 만들자
   3. 예매하기 위해선 '상영 순서', '상영 시간', '영화' 정보가 필요하네. Screening 객체를 만들자. 그리고 영화 요금을 계산할 때 '영화 정보' 뿐만 아니라 '상영 순서', '상영 시간' 에 따라 할인이 달라질 수 있으니까 이걸 Movie 객체에 보내서 요금 계산을 요청하면 될 것 같아.
   4. 각각의 객체가 하나의 책임만 가지고 협력한다.

이 순서로 진행하면 책임을 작게 나누고, 필요한 데이터를 적재적소에 넣을 수 있는 것 같다.

그러나 만약 역순으로 진행한다면 어떨까?

**B. "상태 -> 행동 -> 협력" (데이터 중심적인 사고, 절차 지향적인 사고에 가까움)**

```
             [내 머릿속에 떠오르는 데이터]
                     ↓
             음... 영화 예매를 하려면 '영화 제목', '가격', '할인율', '상영 시간', '좌석 수' 같은 '상태'가 필요할 것 같아.
                     ↓
             이 '상태'들을 가지고 어떤 '행동'을 만들 수 있을까?
             (예: '할인율'과 '가격'으로 '요금 계산' 함수를 만들자. '좌석 수'로 '좌석 예약' 함수를 만들자.)
                     ↓
             이 '행동'들을 조합해서 '영화 예매'라는 '협력(전체 기능)'을 만들어보자.
             (예: 요금 계산 함수 호출하고, 좌석 예약 함수 호출하고...)
```

"상태 -> 행동 -> 협력" 순으로 진행 하면 다음과 같은 과정으로 될 것 같다.

1. 필요한 상태(데이터)를 모은다.
2. 어떤 데이터가 어떤 객체에 필요한지 모르기에 객체를 나누기가 어렵다.
3. 일단 데이터를 가지는 객체를 만들고, 필요한 행동들을 생각하고 구현한다.
   1. '기본 요금'과 '할인 정책'으로 요금 계산을 할 것 같다.
   2. '기본 요금'과 '할인 정책' 그리고 '상영 순서', '상영 시간'도 포함하는 객체가 만들어져야 하나?
   3. Screening에 다 넣자!
   4. Screening이 그럼 요금 계산도 하고, 영화 예매도 하게 된다.
   5. 너무 많은 책임..?

### 교훈

결국, 두 방식 모두 최종적인 "결과"는 같아 보일 수 있지만,
그 결과에 도달하는 설계 과정과 그 과정이 만들어내는 시스템의 품질에서 큰 차이가 발생하는 것 같다.
"협력 -> 행동 -> 상태"는 단순히 기능을 구현하는 것을 넘어, 변화에 유연하고 확장 가능한, 견고한 설계를 지향하는 방식.
시지프의 인터페이스를 먼저 짜고 그 이후에 구현을 생각하는 게 좋다 라는 수업 내용과 비슷한 맥락인 것 같다.

### AI를 통해 만들어본 예제 코드

<details>
<summary> 1. "협력 -> 행동 -> 상태" (객체지향적인 사고, RDD)</summary>

```tsx
// Movie 클래스: 영화의 요금 계산 책임을 가짐
class Movie {
  #fee // private field (ES2022)
  #discountPolicy // private field

  constructor(name, duration, fee, discountPolicy) {
    // this.name = name; // 이름, 상영 시간 등은 필요하면 추가
    // this.duration = duration;
    this.#fee = fee
    this.#discountPolicy = discountPolicy
  }

  // 행동: 요금 계산
  calculateMovieFee(screening) {
    // Screening 객체로부터 필요한 정보를 얻어 할인액을 계산
    const discountAmount =
      this.#discountPolicy.calculateDiscountAmount(screening)
    return this.#fee - discountAmount
  }

  // Movie 객체 자체가 필요한 상태 (외부 노출용)
  getFee() {
    return this.#fee
  }
}

// DiscountPolicy 인터페이스 (JavaScript에서는 클래스 또는 함수로 구현)
class AmountDiscountPolicy {
  #amount
  // ... 기타 할인 조건들

  constructor(amount) {
    this.#amount = amount
  }

  calculateDiscountAmount(screening) {
    // 예시: 특정 상영 순서일 때만 할인 적용
    if (screening.isSequence(1)) {
      return this.#amount
    }
    return 0
  }
}

// Screening 클래스: 특정 상영 정보를 가짐
class Screening {
  #movie // private field: Movie 객체와 협력
  #sequence // private field
  #whenScreened // private field

  constructor(movie, sequence, whenScreened) {
    this.#movie = movie
    this.#sequence = sequence
    this.#whenScreened = whenScreened
  }

  // 행동: 상영 시작 시간 제공
  getStartTime() {
    return this.#whenScreened
  }

  // 행동: 특정 순서인지 확인
  isSequence(sequence) {
    return this.#sequence === sequence
  }

  // 행동: 영화 요금 정보 요청 (movie 객체에게 위임)
  getMovieFee() {
    return this.#movie.getFee()
  }

  // 협력: 외부에서 Screening 객체를 통해 영화 요금 계산을 요청
  calculateFee() {
    // Movie 객체에게 'calculateMovieFee' 행동을 요청하며 자신(Screening)을 전달
    return this.#movie.calculateMovieFee(this)
  }
}

// --- 사용 예시 (협력 시작점) ---
const baseMovieFee = 10000
const discount = new AmountDiscountPolicy(2000) // 2000원 할인
const inceptionMovie = new Movie("인셉션", "150분", baseMovieFee, discount)

const screening1 = new Screening(
  inceptionMovie,
  1,
  new Date("2025-07-22T10:00:00"),
) // 1회차
const screening2 = new Screening(
  inceptionMovie,
  2,
  new Date("2025-07-22T13:00:00"),
) // 2회차

console.log(
  "[협력 -> 행동 -> 상태] 1회차 영화 요금:",
  screening1.calculateFee(),
  "원",
) // Screening이 Movie에게 요금 계산을 요청
console.log(
  "[협력 -> 행동 -> 상태] 2회차 영화 요금:",
  screening2.calculateFee(),
  "원",
)
```

</details>

<details>
<summary> 2. "상태 -> 행동 -> 협력" (데이터 중심적인 사고, 절차 지향적)</summary>

```tsx
// 1. 필요한 모든 상태(데이터)를 하나의 클래스에 담는다.
class MovieScreening {
  #title
  #basePrice
  #discountRate // 할인율
  #sequence // 상영 순서
  #screeningTime // 상영 시간
  #availableSeats

  constructor(
    title,
    basePrice,
    discountRate,
    sequence,
    screeningTime,
    availableSeats,
  ) {
    this.#title = title
    this.#basePrice = basePrice
    this.#discountRate = discountRate
    this.#sequence = sequence
    this.#screeningTime = screeningTime
    this.#availableSeats = availableSeats
  }

  // 2. 이 상태들을 가지고 어떤 행동(메서드)을 만들 수 있을까?
  // 행동: 요금 계산 (내부 상태에 직접 접근)
  calculateFinalFee() {
    let finalPrice = this.#basePrice
    if (this.#sequence === 1) {
      // 1회차 추가 할인
      finalPrice = this.#basePrice * (1 - this.#discountRate - 0.05)
    } else {
      finalPrice = this.#basePrice * (1 - this.#discountRate)
    }
    return finalPrice
  }

  // 행동: 좌석 예약 (내부 상태 변경)
  bookSeats(numToBook) {
    if (this.#availableSeats < numToBook) {
      console.log("좌석이 부족합니다.")
      return false // 예약 실패
    }
    this.#availableSeats -= numToBook
    return true // 예약 성공
  }

  // 상태를 반환하는 Getter (필요시)
  getAvailableSeats() {
    return this.#availableSeats
  }
  getTitle() {
    return this.#title
  }
  getScreeningTime() {
    return this.#screeningTime
  }
}

// --- 사용 예시 (협력 시작점) ---
// 3. 행동들을 조합해서 '영화 예매'라는 협력(전체 기능)을 만들어보자.
const myMovieScreening = new MovieScreening(
  "스파이더맨",
  13000,
  0.1, // 10% 기본 할인
  1, // 1회차
  new Date("2025-07-22T20:00:00"),
  40,
)

console.log(
  `[상태 -> 행동 -> 협력] 초기 남은 좌석: ${myMovieScreening.getAvailableSeats()}`,
)

// 영화 예매라는 협력
const fee = myMovieScreening.calculateFinalFee() // 요금 계산 행동
const isBooked = myMovieScreening.bookSeats(1) // 좌석 예약 행동

if (isBooked) {
  console.log(
    `[상태 -> 행동 -> 협력] 영화 ${myMovieScreening.getTitle()} ${myMovieScreening
      .getScreeningTime()
      .toLocaleString()} 1석 예매 완료.`,
  )
  console.log(
    `최종 요금: ${fee}원, 남은 좌석: ${myMovieScreening.getAvailableSeats()}`,
  )
}
```

</details>
