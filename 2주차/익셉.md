벌써 2주차네요...<br />
지난 1주차 스터디에서, 밍고와 재오가 협력 vs 책임으로 논쟁하던 모습이 떠오르네요.. <br />
그 때 논쟁에서 착안하여, 이런 주제를 잡게 되었습니다.

## 책임으로만 나누면 협력은 알아서 되는거 아닌가?

협력은 메세지 전달을 통해 이루어지고, 각 객체는 자신이 받은 메세지에 따라 행동하거나, 다른 객체에게 메세지를 전달한다는데,
도대체 프론트에서 메세지를 전달한다는게 뭘까요? (특히 리액트)

지난 1주차 스터디 때도 말씀드렸던, 리액트에서 흔히 말하는 좋은 코드는 조금 형식적이라는 생각이 들었습니다. <br />
'컴포넌트는 최대한 UI만 담당하고, 로직은 전부 커스텀 훅으로 분리한다' <br />
그렇게 되면 보통 아래와 같은 코드가 나오게 되는데요.<br />

```tsx
const UserSearch = () => {
  const { keyword, users, loading, setKeyword } = useUserSearch();

  return (
    <div>
      <input value={keyword} onChange={(e) => setKeyword(e.target.value)} />
      {loading ? '로딩 중...' : <ul>{users.map(...)} </ul>}
    </div>
  );
};
```

지금까지 저는 항상 이렇게 생각해왔습니다. <br />
'로직도 훅으로 전부 분리하고, 컴포넌트가 최대한 UI만 담당하게 했으니, 결국 이게 좋은 코드 아님?'<br />
'리액트에서 좋은 코드 만들기 쉽네 ㅋㅋ'<br />

왜 좋은 코드인지 알지도 못하면서, 아주 거만하기 짝이 없었죠. <br />

지금부터 왜 위 코드가 좋은 코드인지, 오브젝트 3장의 주제인 협력과 메세지, 그리고 책임의 관점에서 알아보고자 합니다.

사실 지금까지 개발인생 2년동안은, 오로지 '책임'을 기준으로 설계했었습니다. <br />

위에서 봤던 코드의 안좋은 버전을 한 번 살펴볼까요?

```tsx
const BadComponent = () => {
  const [keyword, setKeyword] = useState('');
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);

  const fetchUsers = async () => {
    const res = await axios.get(`/api/users?search=${keyword}`);
    setUsers(res.data);
  };

  useEffect(() => {
    fetchUsers();
  }, [keyword]);

  return (
    <div>
      <input value={keyword} onChange={(e) => setKeyword(e.target.value)} />
      {loading ? '로딩 중...' : <ul>{users.map(...)} </ul>}
    </div>
  );
};
```

이 컴포넌트 하나가 UI 렌더링, 상태 관리, API 호출까지 전부 책임지고 있어요.

그래서 '책임'을 기준으로 리팩토링 해보았습니다!

```tsx
 //UI만 담당하게
const UserSearch = () => {
  const { keyword, users, loading, setKeyword } = useUserSearch();

  return (
    <div>
      <input value={keyword} onChange={(e) => setKeyword(e.target.value)} />
      {loading ? '로딩 중...' : <ul>{users.map(...)} </ul>}
    </div>
  );
};

// 훅으로 분리 - 상태 관리와 로직 담당

const useUserSearch = () => {
  const [keyword, setKeyword] = useState('');
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // 서버 호출 로직 분리
    ...
  }, [keyword]);

  return { keyword, users, loading, setKeyword };
};

// API 모듈

const fetchUsers = async (keyword) => {
  const res = await axios.get(`/api/users?search=${keyword}`);
  return res.data;
};
```

⸻

오로지 책임이라는 기준만을 가지고 분리해보았어요. <br />
그러다 보니 문득 이런 생각이 들더라구요.<br />
도대체 협력이 뭘까? <br />

이렇게만 분리해도 꽤 준수한 코드인 것 같은데, 여기서 협력까지 고려하라고?

협력에 대해 이해하고 싶어, AI에게 협력을 이해하기 위한 방법을 물어봤어요.

사용자가 입력한다고 가정해보라더군요.

상상하며 이 코드에서 협력이 무엇일지 생각해봅시다.

[사용자 입력] <br />
↓ <br />
UserSearch: onChange → setKeyword(keyword) <br />
↓<br />
useUserSearch: keyword 상태 변경 감지 (useEffect 트리거)<br />
↓<br />
useUserSearch → fetchUsers(keyword) 호출<br />
↓<br />
fetchUsers: 서버와 통신 후 결과 반환<br />
↓<br />
useUserSearch: users 상태 업데이트<br />
↓<br />
UserSearch: users를 기반으로 화면 렌더링<br />

⸻

오브젝트에서 말하는 협력은 '두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청
할 때 시작된다.'고 하던데, 여기서 힌트를 얻었습니다. <br />

결국 협력은 뭔가를 해달라고 요청하는 것?
즉, 협력은 어떤 한 객체의 트리거 역할을 하는것!

<br />

UserSearch에서 onChange를 통해 keyword를 전달하여 검색을 useUserSearch 훅에 요청! <br />
useUserSearch 훅에서 fetchUsers에 검색 결과를 요청!<br />
useUserSearch 훅에서 UserSearch로 상태를 전달하여 UI에 반영 요청!<br />

결국 메세지라는 의미도, 요청과 비슷하다고 생각이 들었어요.<br />
행위에 대한 요청이 결국 메세지가 아닐까?<br />
말을 메세지라고 하니까 진짜 뭔가 텍스트와 같은, 혹은 메서드같은 것들을 전달해야 하나? 라고 생각했었는데 말이죠.<br />

그래서 여러분들과 이야기 나누고 싶은 부분은 무엇이냐면,

### 책임을 기준으로만 나누어도 협력은 자동으로 뒤따라 오지 않을까?

### 협력이라는 개념이, 프론트에서 필요한 개념일까?
