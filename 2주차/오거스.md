# 오브젝트 3장 [역할, 책임 협력]

## 현재 프로젝트에 어떻게 적용할 수 있을까?

이번 2차 데모를 준비하며 단순히 기능을 나누는 것을 넘어, 각 컴포넌트가 어떤 역할을 맡고, 어떤 책임을 수행하며, 서로 어떻게 협력할 수 있을까를 고민해봤다.
<br>
오브젝트 3장에서 다룬 “역할, 책임, 협력” 개념을 기반으로, 현재 내가 담당한 컴포넌트들에 객체지향적인 사고를 적용해 구조를 다시 정리해봤다.

### 적용 표

| 컴포넌트 / 기능     | 역할 (Role)         | 책임 (Responsibility)                | 협력 (Collaboration)               | 적용 전략 (리액트)                          |
| ------------------- | ------------------- | ------------------------------------ | ---------------------------------- | ------------------------------------------- |
| 장소 추가 버튼      | PlaceCreatorTrigger | 모달 열기 + API 요청 트리거          | 모달, API 처리 훅                  | `onClick → openModal()`, `useCreatePlace()` |
| 모달                | ModalManager        | 활성화 여부 제어, 외부 트리거에 반응 | 장소 추가 버튼, 장소 생성 폼       | `useModal()` 훅으로 상태 캡슐화             |
| 토글 버튼           | ToggleController    | 토글 상태 관리 (전역 or local)       | 안내 컴포넌트, 토글 스위치, 텍스트 | `useToggleStore()` 혹은 props로 내려주기    |
| 토글 텍스트         | ToggleLabel         | 상태에 따라 동적 텍스트 표시         | Toggle 상태                        | `isOn ? '켜짐' : '꺼짐'`                    |
| 토글 스위치         | ToggleSwitch        | 사용자 인터랙션 처리                 | Toggle 상태 set 함수               | `onClick={() => toggle()}`                  |
| 루티 스페이스 이름  | SpaceNameDisplay    | 현재 이름 표시                       | 이름 상태, 수정 모드               | props로 name 상태 전달                      |
| 수정 버튼           | EditButton          | 편집 모드 진입 트리거                | 이름 상태 관리 훅                  | `onClick → setEditing(true)`                |
| 이름 상태           | useSpaceName        | 이름 값 + 편집 모드 관리             | 입력 필드, 버튼                    | `useState(name)`, `isEditing` 캡슐화        |
| 일정 시간 입력      | ScheduleTimeInput   | 시작/종료 입력값 관리                | 일정 상태, 검증/검출기             | `useScheduleTime()` 훅으로 관리             |
| 일정 상태           | useScheduleTime     | 시작/종료 시간 보존 + 유효성 처리    | 입력 컴포넌트, 안내 메시지         | `useReducer`로 시간 + 에러 통합 관리        |
| 소화 가능 여부 안내 | FeasibilityGuide    | 조건에 따른 안내 텍스트 표시         | 토글 상태, 일정 상태               | `useEffect(() => { setMent(...) })`         |

### 적용 전략 요약

1. 메시지 중심 설계

- 각 컴포넌트는 명령을 받지 않고 메시지로 요청만 받는다
- 예: `onClick={() => toggle()}` → 메시지 전달
- 실제 toggle 로직은 `useToggleStore`나 내부 훅이 자율적으로 처리

2. 역할 중심 추상화

- 각 기능 단위를 “이름 붙인 역할”로 설계 → `useScheduleTime`, `useModal`, `usePlaceCreation`
- 여러 컴포넌트가 동일한 역할(예: form field, display field)을 교체 가능한 구조로 만듦

3. 책임 분리

- **표시(렌더)**와 **행동(처리)**을 분리해서 협력하게 한다
- 예: ToggleSwitch는 클릭만 처리하고, 상태 변경은 외부 훅에 위임

4. 협력하는 공동체 구조

- 예를 들어 다음과 같은 구조를 만든다:

```txt
[장소 추가 버튼]
    ↓ 메시지
[모달 상태 useModal]
    ↔
[모달 컴포넌트]
    ↔
[장소 추가 Form]
    ↔
[useCreatePlace] API 훅
```

- 또는 토글과 안내 컴포넌트:

```txt
[토글 스위치]  → onToggle()
[useToggleStore] 상태 관리
   ↓
[안내 멘트] ← useEffect로 동기화
```

### 개발 전에 구조 설계 질문 리스트

1. 이 컴포넌트는 어떤 역할을 맡고 있는가?
2. 이 역할은 어떤 책임들을 수행해야 하는가?
3. 이 컴포넌트는 어떤 다른 컴포넌트/훅과 협력해야 하는가?
4. 협력을 위해 어떤 **메시지(props, context, store)**를 주고받는가?

---

<details>
<summary>
책 내용 정리
</summary>

### 📘 오브젝트 3장 요약 (역할, 책임, 협력)

1. 협력 (Collaboration)

- 객체들은 메시지(Message)를 주고받으며 함께 기능을 완성한다.
- 메시지를 받은 객체는 스스로 판단하여 처리하고 행동한다 ￼.

2. 책임 (Responsibility)

- 협력에 참여하기 위한 객체의 역할(행동 + 정보)을 의미.
- “무엇을 아는가(knowing)”와 “무엇을 할 수 있는가(doing)” 로 나눌 수 있다.

3. 역할 (Role)

- 협력에서 객체가 수행하는 책임들의 집합.
- 역할은 추상화 단위로, 여러 객체가 동일한 API 계약을 제공할 수 있게 한다.

4. 메시지가 객체를 선정한다

- 먼저 메시지(인터페이스)를 정의하고, 그 메시지를 어떤 객체가 처리할지 결정한다.
- 이로써 느슨한 결합과 추상화된 인터페이스가 가능해진다.

5. 행동이 상태를 결정한다

- 협력에서 필요한 행동을 먼저 정의하고, 이를 기반으로 객체의 상태(데이터)를 결정한다.
- 상태는 행동이 필요로 하는 “재료” 역할만 하며, 협력이 중심이어야 한다 ￼.

⸻

### 🎯 프론트엔드(리액트) 적용 관점 핵심 5가지

1. 메시지 중심 설계

- 컴포넌트 간 props와 함수 핸들러(onSubmit, onToggle 등)는 메시지로 취급.
- 대상 컴포넌트는 메시지를 받아 스스로 판단하여 행동해야 한다.

2. 역할(Role) 추상화

- useDataProvider, useAuthHandler처럼 역할 기반 추상화된 훅/컴포넌트를 만든다.
- 여러 구현체를 대체 가능하게 설계하여 테스트와 확장성 강화.

3. 책임에서 상태 디자인으로

- 메시지가 무엇을 요청하는지 정의 → 클릭 버튼 → 행동(예: API 요청) → 해당 행동을 위한 상태 설계(loading, data, error)
- 순서가 행동 → 상태의 흐름이어야 한다.

4. 캡슐화된 책임 수행

- useFormValidator, useCacheFetcher 등 훅 내에서 책임을 감싸 외부는 메시지만 주고받도록 한다.
- 외부에서 내부 구현을 알 필요 없이 API만 호출.

5. 협력하는 컴포넌트 공동체 구성

- Parent → Child → 다시 Parent 혹은 다른 Child로 메시지를 전달하며 협력 구조를 만든다.
- 예: FormContainer, FormFields, SubmitButton 등이 서로 메시지로 연계되어 협력하여 기능 완성.

⸻

### ✅ 요약 테이블

| 개념                 | 설명                             | Frontend 적용 예시                               |
| -------------------- | -------------------------------- | ------------------------------------------------ |
| **협력**             | 메시지 기반 상호작용             | `props` 전달 + `callback` 함수 (`onClick`)       |
| **책임**             | 객체가 “아는 것” + “하는 것”     | `useXxx` 훅 내부에서 로직 + 상태 모두 처리       |
| **역할**             | 메시지 계약이 정의된 추상 형태   | `DataFetcher`, `Validator`, `ModalController` 등 |
| **메시지 중심 설계** | 메시지 선정 → 객체가 이를 수행함 | `onClick`, `onSubmit`, `onClose` 등 이벤트 props |
| **행동 → 상태**      | 행동 설계 → 그에 맞는 상태 구성  | `const [loading, setLoading] = useState(false)`  |

⸻

### 🎯 결론

- 오브젝트 3장은 객체지향의 핵심인 **“협력하는 객체들의 공동체”**를 만드는 법을 제시한다.
- 이 개념을 리액트에서는 컴포넌트/훅 간 메시지 설계 + 책임 기반 모듈화로 풀어 적용할 수 있다.
- 이렇게 하면 유연하고 추상적인, 확장성과 재사용에 강한 프론트엔드 구조를 설계할 수 있다.

</details>
