# 리액트에서 '행동'이란 무엇일까?

객체가 수행하는 행동을 책임이라고 부른다.

### 오브젝트에서 말하는 "행동"이란?
- 객체는 **자신이 맡은 책임(행동)**을 수행함으로써 시스템의 일부가 됩니다.
- 예) 고객 객체는 “할인율 계산”이라는 책임(행동)을 가지고 있음.
- 행동은 객체의 존재 이유이자 협력의 출발점입니다.

이 정의를 프론트엔드, 특히 **React**에 적용하면 어떻게 해석할 수 있을까?

- 리액트 컴포넌트가 외부 데이터나 내부 상태에 따라 UI를 판단해 그리는 행위는 충분히 ‘행동’으로 정의할 수 있습니다.

즉,  
컴포넌트가 상황에 따라 **"이렇게 보여줘야 해"** 라고 판단해서 UI를 구성한다면,  
이는 다음을 모두 포함하는 자율적인 행동입니다:

- **알고 있는 것** (props, state 등)
- **판단한 것** (조건 분기, 로직)
- **표현한 것** (UI 렌더링)

---

## 🎯 리액트에서의 행동 = 두 가지로 나뉜다

| 구분 | 설명 | 예시 |
|------|------|------|
| **표현적 행동 (Presentation Logic)** | 상태나 props에 따라 적절한 UI를 구성 | 조건부 렌더링, 스타일 분기, 대체 이미지 표시 |
| **처리적 행동 (Business Logic)** | 이벤트 처리, 데이터 저장/요청 등 앱의 로직 실행 | 버튼 클릭 → API 요청, 모달 열기, 상태 업데이트 등 |

---

## ✨ 왜 표현과 처리를 나눠야 할까?

### 1. 관심사의 분리 (Separation of Concerns)

| 역할 | 책임 |
|------|------|
| 표현 컴포넌트 | **어떻게 보여줄지**에만 집중 |
| 처리 로직 | **무엇을 해야 하는지**에만 집중 (비즈니스 로직, 사이드 이펙트 등) |

### 2. 분리를 안 하면 생기는 문제

- 컴포넌트가 **너무 많은 역할**을 하게 됨
- **테스트가 어려워지고**, **로직 변경 시 버그 가능성 증가**
- **재사용이 힘들어짐** (특정 로직이 묶여 있음)

---

## 🔁 실제로 어떻게 나눌 수 있을까?

### [관심사 분리 전]
```tsx
interface Props {
  newsletterId: string;
}

function SubscribeButton({ newsletterId }: Props) {
  const [isSubscribed, setIsSubscribed] = useState(false);

  const toggleSubscribe = async () => {
    if (isSubscribed) {
      await unsubscribeFromNewsletter(newsletterId);
    } else {
      await subscribeToNewsletter(newsletterId);
    }
    setIsSubscribed((prev) => !prev);
  };

  return (
    <button
      onClick={toggleSubscribe}
      className={`px-4 py-2 rounded ${
        isSubscribed ? 'bg-gray-300' : 'bg-blue-500 text-white'
      }`}
    >
      {isSubscribed ? '구독됨' : '구독하기'}
    </button>
  );
}

export default SubscribeButton;
```

### [관심사 분리 후]
```ts
// useSubscribe.ts
import { useState } from 'react';
import { subscribeToNewsletter, unsubscribeFromNewsletter } from '../api/subscribe';

export function useSubscribe(newsletterId: string) {
  const [isSubscribed, setIsSubscribed] = useState(false);

  const toggleSubscribe = async () => {
    if (isSubscribed) {
      await unsubscribeFromNewsletter(newsletterId);
    } else {
      await subscribeToNewsletter(newsletterId);
    }
    setIsSubscribed((prev) => !prev);
  };

  return { isSubscribed, toggleSubscribe };
}
```

```tsx
// SubscribeButton.tsx
import { useSubscribe } from '../hooks/useSubscribe';

interface Props {
  newsletterId: string;
}

function SubscribeButton({ newsletterId }: Props) {
  const { isSubscribed, toggleSubscribe } = useSubscribe(newsletterId);

  return (
    <button
      onClick={toggleSubscribe}
      className={`px-4 py-2 rounded ${
        isSubscribed ? 'bg-gray-300' : 'bg-blue-500 text-white'
      }`}
    >
      {isSubscribed ? '구독됨' : '구독하기'}
    </button>
  );
}

export default SubscribeButton;

```

---


### 훅의 책임이 많아졌을때는 어떻게 분리하면 좋을까?

```tsx
// usePostForm.ts
function usePostForm() {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const isValid = title.length > 0 && content.length > 0;

  const handleChangeTitle = (e: React.ChangeEvent<HTMLInputElement>) => {
    setTitle(e.target.value);
  };

  const handleChangeContent = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setContent(e.target.value);
  };

  const submit = async () => {
    if (!isValid) {
      setError('제목과 내용을 입력해주세요.');
      return;
    }

    setIsSubmitting(true);
    try {
      await postArticle({ title, content });
      alert('게시글이 등록되었습니다.');
    } catch (e) {
      setError('등록 중 오류가 발생했습니다.');
    } finally {
      setIsSubmitting(false);
    }
  };

  useEffect(() => {
    trackEvent('post_form_view');
  }, []);

  return {
    title,
    content,
    isValid,
    isSubmitting,
    error,
    handleChangeTitle,
    handleChangeContent,
    submit,
  };
}
```

```ts
function usePostFormState() {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');

  const handleChangeTitle = (e: React.ChangeEvent<HTMLInputElement>) => {
    setTitle(e.target.value);
  };

  const handleChangeContent = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setContent(e.target.value);
  };

  return {
    title,
    content,
    handleChangeTitle,
    handleChangeContent,
    isValid: title.length > 0 && content.length > 0,
  };
}

function usePostSubmit(title: string, content: string, isValid: boolean) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const submit = async () => {
    if (!isValid) {
      setError('제목과 내용을 입력해주세요.');
      return;
    }

    setIsSubmitting(true);
    try {
      await postArticle({ title, content });
      alert('게시글이 등록되었습니다.');
    } catch (e) {
      setError('등록 중 오류가 발생했습니다.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return { submit, isSubmitting, error };
}

function usePostAnalytics() {
  useEffect(() => {
    trackEvent('post_form_view');
  }, []);
}

function usePostForm() {
  const { title, content, handleChangeTitle, handleChangeContent, isValid } = usePostFormState();
  const { submit, isSubmitting, error } = usePostSubmit(title, content, isValid);
  usePostAnalytics();

  return {
    title,
    content,
    isValid,
    handleChangeTitle,
    handleChangeContent,
    submit,
    isSubmitting,
    error,
  };
}
```

### `usePostForm` 훅이 “많은 책임을 갖고 있다”고 말할 수 있을까?

- `usePostForm`은 많은 책임을 “가지고 있는 것처럼 보이지만”, 실제로는 “많은 훅과 협력하고 있는 하나의 조정자”일 뿐.
- 즉, `usePostForm`은 많은 일을 “직접” 하지는 않고, 역할이 분리된 작은 훅들 사이의 “협력”을 조율하는 책임만 가진다.